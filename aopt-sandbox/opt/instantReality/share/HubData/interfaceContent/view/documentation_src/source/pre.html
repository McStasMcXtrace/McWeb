<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var pre;
(function (pre) {
    (function () {
        var glMatrix = '/** ' + '       * @fileoverview gl-matrix - High performance matrix and vector operations' + '       * @author Brandon Jones' + '       * @author Colin MacKenzie IV' + '       * @version 2.2.1' + '       */' + '       /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.' + '        Redistribution and use in source and binary forms, with or without modification,' + '        are permitted provided that the following conditions are met:' + '        * Redistributions of source code must retain the above copyright notice, this' + '        list of conditions and the following disclaimer.' + '        * Redistributions in binary form must reproduce the above copyright notice,' + '        this list of conditions and the following disclaimer in the documentation' + '        and/or other materials provided with the distribution.' + '        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND' + '        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED' + '        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE' + '        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR' + '        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES' + '        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;' + '        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON' + '        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT' + '        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS' + '        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */' + '    (function(e){&quot;use strict&quot;;var t={};typeof exports==&quot;undefined&quot;?typeof define==&quot;function&quot;&amp;&amp;typeof define.amd==&quot;object&quot;&amp;&amp;define.amd?(t.exports={},define(function(){return t.exports})):t.exports=typeof window!=&quot;undefined&quot;?window:e:t.exports=exports,function(e){if(!t)var t=1e-6;if(!n)var n=typeof Float32Array!=&quot;undefined&quot;?Float32Array:Array;if(!r)var r=Math.random;var i={};i.setMatrixArrayType=function(e){n=e},typeof e!=&quot;undefined&quot;&amp;&amp;(e.glMatrix=i);var s=Math.PI/180;i.toRadian=function(e){return e*s};var o={};o.create=function(){var e=new n(2);return e[0]=0,e[1]=0,e},o.clone=function(e){var t=new n(2);return t[0]=e[0],t[1]=e[1],t},o.fromValues=function(e,t){var r=new n(2);return r[0]=e,r[1]=t,r},o.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e},o.set=function(e,t,n){return e[0]=t,e[1]=n,e},o.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e},o.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e},o.sub=o.subtract,o.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e},o.mul=o.multiply,o.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e},o.div=o.divide,o.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e},o.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e},o.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e},o.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e},o.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return Math.sqrt(n*n+r*r)},o.dist=o.distance,o.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return n*n+r*r},o.sqrDist=o.squaredDistance,o.length=function(e){var t=e[0],n=e[1];return Math.sqrt(t*t+n*n)},o.len=o.length,o.squaredLength=function(e){var t=e[0],n=e[1];return t*t+n*n},o.sqrLen=o.squaredLength,o.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e},o.normalize=function(e,t){var n=t[0],r=t[1],i=n*n+r*r;return i&gt;0&amp;&amp;(i=1/Math.sqrt(i),e[0]=t[0]*i,e[1]=t[1]*i),e},o.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]},o.cross=function(e,t,n){var r=t[0]*n[1]-t[1]*n[0];return e[0]=e[1]=0,e[2]=r,e},o.lerp=function(e,t,n,r){var i=t[0],s=t[1];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e},o.random=function(e,t){t=t||1;var n=r()*2*Math.PI;return e[0]=Math.cos(n)*t,e[1]=Math.sin(n)*t,e},o.transformMat2=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i,e[1]=n[1]*r+n[3]*i,e},o.transformMat2d=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i+n[4],e[1]=n[1]*r+n[3]*i+n[5],e},o.transformMat3=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[3]*i+n[6],e[1]=n[1]*r+n[4]*i+n[7],e},o.transformMat4=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[4]*i+n[12],e[1]=n[1]*r+n[5]*i+n[13],e},o.forEach=function(){var e=o.create();return function(t,n,r,i,s,o){var u,a;n||(n=2),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u&lt;a;u+=n)e[0]=t[u],e[1]=t[u+1],s(e,e,o),t[u]=e[0],t[u+1]=e[1];return t}}(),o.str=function(e){return&quot;vec2(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;)&quot;},typeof e!=&quot;undefined&quot;&amp;&amp;(e.vec2=o);var u={};u.create=function(){var e=new n(3);return e[0]=0,e[1]=0,e[2]=0,e},u.clone=function(e){var t=new n(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t},u.fromValues=function(e,t,r){var i=new n(3);return i[0]=e,i[1]=t,i[2]=r,i},u.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},u.set=function(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e},u.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e},u.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e},u.sub=u.subtract,u.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e},u.mul=u.multiply,u.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e},u.div=u.divide,u.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e},u.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e},u.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e},u.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e},u.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(n*n+r*r+i*i)},u.dist=u.distance,u.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return n*n+r*r+i*i},u.sqrDist=u.squaredDistance,u.length=function(e){var t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)},u.len=u.length,u.squaredLength=function(e){var t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r},u.sqrLen=u.squaredLength,u.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},u.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=n*n+r*r+i*i;return s&gt;0&amp;&amp;(s=1/Math.sqrt(s),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s),e},u.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]},u.cross=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2];return e[0]=i*a-s*u,e[1]=s*o-r*a,e[2]=r*u-i*o,e},u.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e},u.random=function(e,t){t=t||1;var n=r()*2*Math.PI,i=r()*2-1,s=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*s,e[1]=Math.sin(n)*s,e[2]=i*t,e},u.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12],e[1]=n[1]*r+n[5]*i+n[9]*s+n[13],e[2]=n[2]*r+n[6]*i+n[10]*s+n[14],e},u.transformMat3=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=r*n[0]+i*n[3]+s*n[6],e[1]=r*n[1]+i*n[4]+s*n[7],e[2]=r*n[2]+i*n[5]+s*n[8],e},u.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},u.rotateX=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[0],s[1]=i[1]*Math.cos(r)-i[2]*Math.sin(r),s[2]=i[1]*Math.sin(r)+i[2]*Math.cos(r),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.rotateY=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[2]*Math.sin(r)+i[0]*Math.cos(r),s[1]=i[1],s[2]=i[2]*Math.cos(r)-i[0]*Math.sin(r),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.rotateZ=function(e,t,n,r){var i=[],s=[];return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[0]*Math.cos(r)-i[1]*Math.sin(r),s[1]=i[0]*Math.sin(r)+i[1]*Math.cos(r),s[2]=i[2],e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},u.forEach=function(){var e=u.create();return function(t,n,r,i,s,o){var u,a;n||(n=3),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u&lt;a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2];return t}}(),u.str=function(e){return&quot;vec3(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;)&quot;},typeof e!=&quot;undefined&quot;&amp;&amp;(e.vec3=u);var a={};a.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e},a.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},a.fromValues=function(e,t,r,i){var s=new n(4);return s[0]=e,s[1]=t,s[2]=r,s[3]=i,s},a.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},a.set=function(e,t,n,r,i){return e[0]=t,e[1]=n,e[2]=r,e[3]=i,e},a.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e},a.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e},a.sub=a.subtract,a.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e[3]=t[3]*n[3],e},a.mul=a.multiply,a.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e[3]=t[3]/n[3],e},a.div=a.divide,a.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e[3]=Math.min(t[3],n[3]),e},a.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e[3]=Math.max(t[3],n[3]),e},a.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e},a.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e},a.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return Math.sqrt(n*n+r*r+i*i+s*s)},a.dist=a.distance,a.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return n*n+r*r+i*i+s*s},a.sqrDist=a.squaredDistance,a.length=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)},a.len=a.length,a.squaredLength=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i},a.sqrLen=a.squaredLength,a.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e},a.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s;return o&gt;0&amp;&amp;(o=1/Math.sqrt(o),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e[3]=t[3]*o),e},a.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]},a.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e[3]=u+r*(n[3]-u),e},a.random=function(e,t){return t=t||1,e[0]=r(),e[1]=r(),e[2]=r(),e[3]=r(),a.normalize(e,e),a.scale(e,e,t),e},a.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12]*o,e[1]=n[1]*r+n[5]*i+n[9]*s+n[13]*o,e[2]=n[2]*r+n[6]*i+n[10]*s+n[14]*o,e[3]=n[3]*r+n[7]*i+n[11]*s+n[15]*o,e},a.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},a.forEach=function(){var e=a.create();return function(t,n,r,i,s,o){var u,a;n||(n=4),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u&lt;a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],e[3]=t[u+3],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2],t[u+3]=e[3];return t}}(),a.str=function(e){return&quot;vec4(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;)&quot;},typeof e!=&quot;undefined&quot;&amp;&amp;(e.vec4=a);var f={};f.create=function(){var e=new n(4);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},f.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},f.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},f.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},f.transpose=function(e,t){if(e===t){var n=t[1];e[1]=t[2],e[2]=n}else e[0]=t[0],e[1]=t[2],e[2]=t[1],e[3]=t[3];return e},f.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*s-i*r;return o?(o=1/o,e[0]=s*o,e[1]=-r*o,e[2]=-i*o,e[3]=n*o,e):null},f.adjoint=function(e,t){var n=t[0];return e[0]=t[3],e[1]=-t[1],e[2]=-t[2],e[3]=n,e},f.determinant=function(e){return e[0]*e[3]-e[2]*e[1]},f.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*u+s*a,e[1]=i*u+o*a,e[2]=r*f+s*l,e[3]=i*f+o*l,e},f.mul=f.multiply,f.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+s*u,e[1]=i*a+o*u,e[2]=r*-u+s*a,e[3]=i*-u+o*a,e},f.scale=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1];return e[0]=r*u,e[1]=i*u,e[2]=s*a,e[3]=o*a,e},f.str=function(e){return&quot;mat2(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;)&quot;},f.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2))},f.LDU=function(e,t,n,r){return e[2]=r[2]/r[0],n[0]=r[0],n[1]=r[1],n[3]=r[3]-e[2]*n[1],[e,t,n]},typeof e!=&quot;undefined&quot;&amp;&amp;(e.mat2=f);var l={};l.create=function(){var e=new n(6);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},l.clone=function(e){var t=new n(6);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t},l.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e},l.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},l.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=n*s-r*i;return a?(a=1/a,e[0]=s*a,e[1]=-r*a,e[2]=-i*a,e[3]=n*a,e[4]=(i*u-s*o)*a,e[5]=(r*o-n*u)*a,e):null},l.determinant=function(e){return e[0]*e[3]-e[1]*e[2]},l.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1],c=n[2],h=n[3],p=n[4],d=n[5];return e[0]=r*f+s*l,e[1]=i*f+o*l,e[2]=r*c+s*h,e[3]=i*c+o*h,e[4]=r*p+s*d+u,e[5]=i*p+o*d+a,e},l.mul=l.multiply,l.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=Math.sin(n),l=Math.cos(n);return e[0]=r*l+s*f,e[1]=i*l+o*f,e[2]=r*-f+s*l,e[3]=i*-f+o*l,e[4]=u,e[5]=a,e},l.scale=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1];return e[0]=r*f,e[1]=i*f,e[2]=s*l,e[3]=o*l,e[4]=u,e[5]=a,e},l.translate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1];return e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=r*f+s*l+u,e[5]=i*f+o*l+a,e},l.str=function(e){return&quot;mat2d(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;)&quot;},l.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+1)},typeof e!=&quot;undefined&quot;&amp;&amp;(e.mat2d=l);var c={};c.create=function(){var e=new n(9);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},c.fromMat4=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e},c.clone=function(e){var t=new n(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t},c.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},c.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},c.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=i}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e},c.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=l*o-u*f,h=-l*s+u*a,p=f*s-o*a,d=n*c+r*h+i*p;return d?(d=1/d,e[0]=c*d,e[1]=(-l*r+i*f)*d,e[2]=(u*r-i*o)*d,e[3]=h*d,e[4]=(l*n-i*a)*d,e[5]=(-u*n+i*s)*d,e[6]=p*d,e[7]=(-f*n+r*a)*d,e[8]=(o*n-r*s)*d,e):null},c.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8];return e[0]=o*l-u*f,e[1]=i*f-r*l,e[2]=r*u-i*o,e[3]=u*a-s*l,e[4]=n*l-i*a,e[5]=i*s-n*u,e[6]=s*f-o*a,e[7]=r*a-n*f,e[8]=n*o-r*s,e},c.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8];return t*(f*s-o*a)+n*(-f*i+o*u)+r*(a*i-s*u)},c.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8];return e[0]=h*r+p*o+d*f,e[1]=h*i+p*u+d*l,e[2]=h*s+p*a+d*c,e[3]=v*r+m*o+g*f,e[4]=v*i+m*u+g*l,e[5]=v*s+m*a+g*c,e[6]=y*r+b*o+w*f,e[7]=y*i+b*u+w*l,e[8]=y*s+b*a+w*c,e},c.mul=c.multiply,c.translate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1];return e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=u,e[5]=a,e[6]=h*r+p*o+f,e[7]=h*i+p*u+l,e[8]=h*s+p*a+c,e},c.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=Math.sin(n),p=Math.cos(n);return e[0]=p*r+h*o,e[1]=p*i+h*u,e[2]=p*s+h*a,e[3]=p*o-h*r,e[4]=p*u-h*i,e[5]=p*a-h*s,e[6]=f,e[7]=l,e[8]=c,e},c.scale=function(e,t,n){var r=n[0],i=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=i*t[3],e[4]=i*t[4],e[5]=i*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},c.fromMat2d=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e},c.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=r*o,c=r*u,h=i*o,p=i*u,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-c-d,e[3]=l-g,e[6]=h+m,e[1]=l+g,e[4]=1-f-d,e[7]=p-v,e[2]=h-m,e[5]=p+v,e[8]=1-f-c,e},c.normalFromMat4=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(a*C-o*A-f*N)*O,e[2]=(o*L-u*C+f*T)*O,e[3]=(i*L-r*A-s*k)*O,e[4]=(n*A-i*C+s*N)*O,e[5]=(r*C-n*L-s*T)*O,e[6]=(v*x-m*S+g*E)*O,e[7]=(m*w-d*x-g*b)*O,e[8]=(d*S-v*w+g*y)*O,e):null},c.str=function(e){return&quot;mat3(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;)&quot;},c.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+Math.pow(e[6],2)+Math.pow(e[7],2)+Math.pow(e[8],2))},typeof e!=&quot;undefined&quot;&amp;&amp;(e.mat3=c);var h={};h.create=function(){var e=new n(16);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.clone=function(e){var t=new n(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},h.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},h.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[3],s=t[6],o=t[7],u=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=s,e[11]=t[14],e[12]=i,e[13]=o,e[14]=u}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e},h.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(i*L-r*A-s*k)*O,e[2]=(v*x-m*S+g*E)*O,e[3]=(h*S-c*x-p*E)*O,e[4]=(a*C-o*A-f*N)*O,e[5]=(n*A-i*C+s*N)*O,e[6]=(m*w-d*x-g*b)*O,e[7]=(l*x-h*w+p*b)*O,e[8]=(o*L-u*C+f*T)*O,e[9]=(r*C-n*L-s*T)*O,e[10]=(d*S-v*w+g*y)*O,e[11]=(c*w-l*S-p*y)*O,e[12]=(u*N-o*k-a*T)*O,e[13]=(n*k-r*N+i*T)*O,e[14]=(v*b-d*E-m*y)*O,e[15]=(l*E-c*b+h*y)*O,e):null},h.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15];return e[0]=u*(h*g-p*m)-c*(a*g-f*m)+v*(a*p-f*h),e[1]=-(r*(h*g-p*m)-c*(i*g-s*m)+v*(i*p-s*h)),e[2]=r*(a*g-f*m)-u*(i*g-s*m)+v*(i*f-s*a),e[3]=-(r*(a*p-f*h)-u*(i*p-s*h)+c*(i*f-s*a)),e[4]=-(o*(h*g-p*m)-l*(a*g-f*m)+d*(a*p-f*h)),e[5]=n*(h*g-p*m)-l*(i*g-s*m)+d*(i*p-s*h),e[6]=-(n*(a*g-f*m)-o*(i*g-s*m)+d*(i*f-s*a)),e[7]=n*(a*p-f*h)-o*(i*p-s*h)+l*(i*f-s*a),e[8]=o*(c*g-p*v)-l*(u*g-f*v)+d*(u*p-f*c),e[9]=-(n*(c*g-p*v)-l*(r*g-s*v)+d*(r*p-s*c)),e[10]=n*(u*g-f*v)-o*(r*g-s*v)+d*(r*f-s*u),e[11]=-(n*(u*p-f*c)-o*(r*p-s*c)+l*(r*f-s*u)),e[12]=-(o*(c*m-h*v)-l*(u*m-a*v)+d*(u*h-a*c)),e[13]=n*(c*m-h*v)-l*(r*m-i*v)+d*(r*h-i*c),e[14]=-(n*(u*m-a*v)-o*(r*m-i*v)+d*(r*a-i*u)),e[15]=n*(u*h-a*c)-o*(r*h-i*c)+l*(r*a-i*u),e},h.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8],l=e[9],c=e[10],h=e[11],p=e[12],d=e[13],v=e[14],m=e[15],g=t*o-n*s,y=t*u-r*s,b=t*a-i*s,w=n*u-r*o,E=n*a-i*o,S=r*a-i*u,x=f*d-l*p,T=f*v-c*p,N=f*m-h*p,C=l*v-c*d,k=l*m-h*d,L=c*m-h*v;return g*L-y*k+b*C+w*N-E*T+S*x},h.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=t[9],p=t[10],d=t[11],v=t[12],m=t[13],g=t[14],y=t[15],b=n[0],w=n[1],E=n[2],S=n[3];return e[0]=b*r+w*u+E*c+S*v,e[1]=b*i+w*a+E*h+S*m,e[2]=b*s+w*f+E*p+S*g,e[3]=b*o+w*l+E*d+S*y,b=n[4],w=n[5],E=n[6],S=n[7],e[4]=b*r+w*u+E*c+S*v,e[5]=b*i+w*a+E*h+S*m,e[6]=b*s+w*f+E*p+S*g,e[7]=b*o+w*l+E*d+S*y,b=n[8],w=n[9],E=n[10],S=n[11],e[8]=b*r+w*u+E*c+S*v,e[9]=b*i+w*a+E*h+S*m,e[10]=b*s+w*f+E*p+S*g,e[11]=b*o+w*l+E*d+S*y,b=n[12],w=n[13],E=n[14],S=n[15],e[12]=b*r+w*u+E*c+S*v,e[13]=b*i+w*a+E*h+S*m,e[14]=b*s+w*f+E*p+S*g,e[15]=b*o+w*l+E*d+S*y,e},h.mul=h.multiply,h.translate=function(e,t,n){var r=n[0],i=n[1],s=n[2],o,u,a,f,l,c,h,p,d,v,m,g;return t===e?(e[12]=t[0]*r+t[4]*i+t[8]*s+t[12],e[13]=t[1]*r+t[5]*i+t[9]*s+t[13],e[14]=t[2]*r+t[6]*i+t[10]*s+t[14],e[15]=t[3]*r+t[7]*i+t[11]*s+t[15]):(o=t[0],u=t[1],a=t[2],f=t[3],l=t[4],c=t[5],h=t[6],p=t[7],d=t[8],v=t[9],m=t[10],g=t[11],e[0]=o,e[1]=u,e[2]=a,e[3]=f,e[4]=l,e[5]=c,e[6]=h,e[7]=p,e[8]=d,e[9]=v,e[10]=m,e[11]=g,e[12]=o*r+l*i+d*s+t[12],e[13]=u*r+c*i+v*s+t[13],e[14]=a*r+h*i+m*s+t[14],e[15]=f*r+p*i+g*s+t[15]),e},h.scale=function(e,t,n){var r=n[0],i=n[1],s=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},h.rotate=function(e,n,r,i){var s=i[0],o=i[1],u=i[2],a=Math.sqrt(s*s+o*o+u*u),f,l,c,h,p,d,v,m,g,y,b,w,E,S,x,T,N,C,k,L,A,O,M,_;return Math.abs(a)&lt;t?null:(a=1/a,s*=a,o*=a,u*=a,f=Math.sin(r),l=Math.cos(r),c=1-l,h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8],E=n[9],S=n[10],x=n[11],T=s*s*c+l,N=o*s*c+u*f,C=u*s*c-o*f,k=s*o*c-u*f,L=o*o*c+l,A=u*o*c+s*f,O=s*u*c+o*f,M=o*u*c-s*f,_=u*u*c+l,e[0]=h*T+m*N+w*C,e[1]=p*T+g*N+E*C,e[2]=d*T+y*N+S*C,e[3]=v*T+b*N+x*C,e[4]=h*k+m*L+w*A,e[5]=p*k+g*L+E*A,e[6]=d*k+y*L+S*A,e[7]=v*k+b*L+x*A,e[8]=h*O+m*M+w*_,e[9]=p*O+g*M+E*_,e[10]=d*O+y*M+S*_,e[11]=v*O+b*M+x*_,n!==e&amp;&amp;(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e)},h.rotateX=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[4],o=t[5],u=t[6],a=t[7],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&amp;&amp;(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*i+f*r,e[5]=o*i+l*r,e[6]=u*i+c*r,e[7]=a*i+h*r,e[8]=f*i-s*r,e[9]=l*i-o*r,e[10]=c*i-u*r,e[11]=h*i-a*r,e},h.rotateY=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&amp;&amp;(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i-f*r,e[1]=o*i-l*r,e[2]=u*i-c*r,e[3]=a*i-h*r,e[8]=s*r+f*i,e[9]=o*r+l*i,e[10]=u*r+c*i,e[11]=a*r+h*i,e},h.rotateZ=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[4],l=t[5],c=t[6],h=t[7];return t!==e&amp;&amp;(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i+f*r,e[1]=o*i+l*r,e[2]=u*i+c*r,e[3]=a*i+h*r,e[4]=f*i-s*r,e[5]=l*i-o*r,e[6]=c*i-u*r,e[7]=h*i-a*r,e},h.fromRotationTranslation=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=r+r,a=i+i,f=s+s,l=r*u,c=r*a,h=r*f,p=i*a,d=i*f,v=s*f,m=o*u,g=o*a,y=o*f;return e[0]=1-(p+v),e[1]=c+y,e[2]=h-g,e[3]=0,e[4]=c-y,e[5]=1-(l+v),e[6]=d+m,e[7]=0,e[8]=h+g,e[9]=d-m,e[10]=1-(l+p),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e},h.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=r*o,c=r*u,h=i*o,p=i*u,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-c-d,e[1]=l+g,e[2]=h-m,e[3]=0,e[4]=l-g,e[5]=1-f-d,e[6]=p+v,e[7]=0,e[8]=h+m,e[9]=p-v,e[10]=1-f-c,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},h.frustum=function(e,t,n,r,i,s,o){var u=1/(n-t),a=1/(i-r),f=1/(s-o);return e[0]=s*2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s*2*a,e[6]=0,e[7]=0,e[8]=(n+t)*u,e[9]=(i+r)*a,e[10]=(o+s)*f,e[11]=-1,e[12]=0,e[13]=0,e[14]=o*s*2*f,e[15]=0,e},h.perspective=function(e,t,n,r,i){var s=1/Math.tan(t/2),o=1/(r-i);return e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=(i+r)*o,e[11]=-1,e[12]=0,e[13]=0,e[14]=2*i*r*o,e[15]=0,e},h.ortho=function(e,t,n,r,i,s,o){var u=1/(t-n),a=1/(r-i),f=1/(s-o);return e[0]=-2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*f,e[11]=0,e[12]=(t+n)*u,e[13]=(i+r)*a,e[14]=(o+s)*f,e[15]=1,e},h.lookAt=function(e,n,r,i){var s,o,u,a,f,l,c,p,d,v,m=n[0],g=n[1],y=n[2],b=i[0],w=i[1],E=i[2],S=r[0],x=r[1],T=r[2];return Math.abs(m-S)&lt;t&amp;&amp;Math.abs(g-x)&lt;t&amp;&amp;Math.abs(y-T)&lt;t?h.identity(e):(c=m-S,p=g-x,d=y-T,v=1/Math.sqrt(c*c+p*p+d*d),c*=v,p*=v,d*=v,s=w*d-E*p,o=E*c-b*d,u=b*p-w*c,v=Math.sqrt(s*s+o*o+u*u),v?(v=1/v,s*=v,o*=v,u*=v):(s=0,o=0,u=0),a=p*u-d*o,f=d*s-c*u,l=c*o-p*s,v=Math.sqrt(a*a+f*f+l*l),v?(v=1/v,a*=v,f*=v,l*=v):(a=0,f=0,l=0),e[0]=s,e[1]=a,e[2]=c,e[3]=0,e[4]=o,e[5]=f,e[6]=p,e[7]=0,e[8]=u,e[9]=l,e[10]=d,e[11]=0,e[12]=-(s*m+o*g+u*y),e[13]=-(a*m+f*g+l*y),e[14]=-(c*m+p*g+d*y),e[15]=1,e)},h.str=function(e){return&quot;mat4(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;, &quot;+e[9]+&quot;, &quot;+e[10]+&quot;, &quot;+e[11]+&quot;, &quot;+e[12]+&quot;, &quot;+e[13]+&quot;, &quot;+e[14]+&quot;, &quot;+e[15]+&quot;)&quot;},h.frob=function(e){return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2)+Math.pow(e[2],2)+Math.pow(e[3],2)+Math.pow(e[4],2)+Math.pow(e[5],2)+Math.pow(e[6],2)+Math.pow(e[6],2)+Math.pow(e[7],2)+Math.pow(e[8],2)+Math.pow(e[9],2)+Math.pow(e[10],2)+Math.pow(e[11],2)+Math.pow(e[12],2)+Math.pow(e[13],2)+Math.pow(e[14],2)+Math.pow(e[15],2))},typeof e!=&quot;undefined&quot;&amp;&amp;(e.mat4=h);var p={};p.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},p.rotationTo=function(){var e=u.create(),t=u.fromValues(1,0,0),n=u.fromValues(0,1,0);return function(r,i,s){var o=u.dot(i,s);return o&lt;-0.999999?(u.cross(e,t,i),u.length(e)&lt;1e-6&amp;&amp;u.cross(e,n,i),u.normalize(e,e),p.setAxisAngle(r,e,Math.PI),r):o&gt;.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(u.cross(e,i,s),r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=1+o,p.normalize(r,r))}}(),p.setAxes=function(){var e=c.create();return function(t,n,r,i){return e[0]=r[0],e[3]=r[1],e[6]=r[2],e[1]=i[0],e[4]=i[1],e[7]=i[2],e[2]=-n[0],e[5]=-n[1],e[8]=-n[2],p.normalize(t,p.fromMat3(t,e))}}(),p.clone=a.clone,p.fromValues=a.fromValues,p.copy=a.copy,p.set=a.set,p.identity=function(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},p.setAxisAngle=function(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e},p.add=a.add,p.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*l+o*u+i*f-s*a,e[1]=i*l+o*a+s*u-r*f,e[2]=s*l+o*f+r*a-i*u,e[3]=o*l-r*u-i*a-s*f,e},p.mul=p.multiply,p.scale=a.scale,p.rotateX=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+o*u,e[1]=i*a+s*u,e[2]=s*a-i*u,e[3]=o*a-r*u,e},p.rotateY=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a-s*u,e[1]=i*a+o*u,e[2]=s*a+r*u,e[3]=o*a-i*u,e},p.rotateZ=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+i*u,e[1]=i*a-r*u,e[2]=s*a+o*u,e[3]=o*a-s*u,e},p.calculateW=function(e,t){var n=t[0],r=t[1],i=t[2];return e[0]=n,e[1]=r,e[2]=i,e[3]=-Math.sqrt(Math.abs(1-n*n-r*r-i*i)),e},p.dot=a.dot,p.lerp=a.lerp,p.slerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3],a=n[0],f=n[1],l=n[2],c=n[3],h,p,d,v,m;return p=i*a+s*f+o*l+u*c,p&lt;0&amp;&amp;(p=-p,a=-a,f=-f,l=-l,c=-c),1-p&gt;1e-6?(h=Math.acos(p),d=Math.sin(h),v=Math.sin((1-r)*h)/d,m=Math.sin(r*h)/d):(v=1-r,m=r),e[0]=v*i+m*a,e[1]=v*s+m*f,e[2]=v*o+m*l,e[3]=v*u+m*c,e},p.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s,u=o?1/o:0;return e[0]=-n*u,e[1]=-r*u,e[2]=-i*u,e[3]=s*u,e},p.conjugate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e},p.length=a.length,p.len=p.length,p.squaredLength=a.squaredLength,p.sqrLen=p.squaredLength,p.normalize=a.normalize,p.fromMat3=function(e,t){var n=t[0]+t[4]+t[8],r;if(n&gt;0)r=Math.sqrt(n+1),e[3]=.5*r,r=.5/r,e[0]=(t[7]-t[5])*r,e[1]=(t[2]-t[6])*r,e[2]=(t[3]-t[1])*r;else{var i=0;t[4]&gt;t[0]&amp;&amp;(i=1),t[8]&gt;t[i*3+i]&amp;&amp;(i=2);var s=(i+1)%3,o=(i+2)%3;r=Math.sqrt(t[i*3+i]-t[s*3+s]-t[o*3+o]+1),e[i]=.5*r,r=.5/r,e[3]=(t[o*3+s]-t[s*3+o])*r,e[s]=(t[s*3+i]+t[i*3+s])*r,e[o]=(t[o*3+i]+t[i*3+o])*r}return e},p.str=function(e){return&quot;quat(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;)&quot;},typeof e!=&quot;undefined&quot;&amp;&amp;(e.quat=p)}(t.exports)})(this);';

        var webgl_debug = &quot;/*  ** Copyright (c) 2012 The Khronos Group Inc.  **  ** Permission is hereby granted, free of charge, to any person obtaining a  ** copy of this software and/or associated documentation files (the  ** 'Materials'), to deal in the Materials without restriction, including  ** without limitation the rights to use, copy, modify, merge, publish,  ** distribute, sublicense, and/or sell copies of the Materials, and to  ** permit persons to whom the Materials are furnished to do so, subject to  ** the following conditions:  **  ** The above copyright notice and this permission notice shall be included  ** in all copies or substantial portions of the Materials.  **  ** THE MATERIALS ARE PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,  ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.  */  /* Various functions for helping debug WebGL apps.*/  WebGLDebugUtils = function() {      /**      * Wrapped logging function.      * @param {string} msg Message to log.      */     var log = function(msg) {         if (window.console &amp;&amp; window.console.log) {             window.console.log(msg);         }     };      /**      * Wrapped error logging function.      * @param {string} msg Message to log.      */     var error = function(msg) {         if (window.console &amp;&amp; window.console.error) {             window.console.error(msg);         } else {             log(msg);         }     };       /**      * Which arguments are enums based on the number of arguments to the function.      * So      *    'texImage2D': {  *       9: { 0:true, 2:true, 6:true, 7:true },  *       6: { 0:true, 2:true, 3:true, 4:true },  *    },      *      * means if there are 9 arguments then 6 and 7 are enums, if there are 6      * arguments 3 and 4 are enums      *      * @type {!Object.&lt;number, !Object.&lt;number, string&gt;}      */     var glValidEnumContexts = {          'enable': {1: { 0:true }},         'disable': {1: { 0:true }},         'getParameter': {1: { 0:true }},           'drawArrays': {3:{ 0:true }},         'drawElements': {4:{ 0:true, 2:true }},           'createShader': {1: { 0:true }},         'getShaderParameter': {2: { 1:true }},         'getProgramParameter': {2: { 1:true }},         'getShaderPrecisionFormat': {2: { 0: true, 1:true }},           'getVertexAttrib': {2: { 1:true }},         'vertexAttribPointer': {6: { 2:true }},           'bindTexture': {2: { 0:true }},         'activeTexture': {1: { 0:true }},         'getTexParameter': {2: { 0:true, 1:true }},         'texParameterf': {3: { 0:true, 1:true }},         'texParameteri': {3: { 0:true, 1:true, 2:true }},         'texImage2D': {             9: { 0:true, 2:true, 6:true, 7:true },             6: { 0:true, 2:true, 3:true, 4:true }         },         'texSubImage2D': {             9: { 0:true, 6:true, 7:true },             7: { 0:true, 4:true, 5:true }         },         'copyTexImage2D': {8: { 0:true, 2:true }},         'copyTexSubImage2D': {8: { 0:true }},         'generateMipmap': {1: { 0:true }},         'compressedTexImage2D': {7: { 0: true, 2:true }},         'compressedTexSubImage2D': {8: { 0: true, 6:true }},           'bindBuffer': {2: { 0:true }},         'bufferData': {3: { 0:true, 2:true }},         'bufferSubData': {3: { 0:true }},         'getBufferParameter': {2: { 0:true, 1:true }},           'pixelStorei': {2: { 0:true, 1:true }},         'readPixels': {7: { 4:true, 5:true }},         'bindRenderbuffer': {2: { 0:true }},         'bindFramebuffer': {2: { 0:true }},         'checkFramebufferStatus': {1: { 0:true }},         'framebufferRenderbuffer': {4: { 0:true, 1:true, 2:true }},         'framebufferTexture2D': {5: { 0:true, 1:true, 2:true }},         'getFramebufferAttachmentParameter': {3: { 0:true, 1:true, 2:true }},         'getRenderbufferParameter': {2: { 0:true, 1:true }},         'renderbufferStorage': {4: { 0:true, 1:true }},           'clear': {1: { 0: { 'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT'] }}},         'depthFunc': {1: { 0:true }},         'blendFunc': {2: { 0:true, 1:true }},         'blendFuncSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},         'blendEquation': {1: { 0:true }},         'blendEquationSeparate': {2: { 0:true, 1:true }},         'stencilFunc': {3: { 0:true }},         'stencilFuncSeparate': {4: { 0:true, 1:true }},         'stencilMaskSeparate': {2: { 0:true }},         'stencilOp': {3: { 0:true, 1:true, 2:true }},         'stencilOpSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},           'cullFace': {1: { 0:true }},         'frontFace': {1: { 0:true }},           'drawArraysInstancedANGLE': {4: { 0:true }},         'drawElementsInstancedANGLE': {5: { 0:true, 2:true }},           'blendEquationEXT': {1: { 0:true }}     };      /**      * Map of numbers to names.      * @type {Object}      */     var glEnums = null;      /**      * Map of names to numbers.      * @type {Object}      */     var enumStringToValue = null;      /**      * Initializes this module. Safe to call more than once.      * @param {!WebGLRenderingContext} ctx A WebGL context. If      *    you have more than one context it doesn't matter which one      *    you pass in, it is only used to pull out constants.      */     function init(ctx) {         if (glEnums == null) {             glEnums = { };             enumStringToValue = { };             for (var propertyName in ctx) {                 if (typeof ctx[propertyName] == 'number') {                     glEnums[ctx[propertyName]] = propertyName;                     enumStringToValue[propertyName] = ctx[propertyName];                 }             }         }     }      /**      * Checks the utils have been initialized.      */     function checkInit() {         if (glEnums == null) {             throw 'WebGLDebugUtils.init(ctx) not called';         }     }      /**      * Returns true or false if value matches any WebGL enum      * @param {*} value Value to check if it might be an enum.      * @return {boolean} True if value matches one of the WebGL defined enums      */     function mightBeEnum(value) {         checkInit();         return (glEnums[value] !== undefined);     }      /**      * Gets an string version of an WebGL enum.      *      * Example:      *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());      *      * @param {number} value Value to return an enum for      * @return {string} The string version of the enum.      */     function glEnumToString(value) {         checkInit();         var name = glEnums[value];         return (name !== undefined) ? ('gl.' + name) :             ('/*UNKNOWN WebGL ENUM*/ 0x' + value.toString(16) + '');     }      /**      * Returns the string version of a WebGL argument.      * Attempts to convert enum arguments to strings.      * @param {string} functionName the name of the WebGL function.      * @param {number} numArgs the number of arguments passed to the function.      * @param {number} argumentIndx the index of the argument.      * @param {*} value The value of the argument.      * @return {string} The value as a string.      */     function glFunctionArgToString(functionName, numArgs, argumentIndex, value) {         var funcInfo = glValidEnumContexts[functionName];         if (funcInfo !== undefined) {             var funcInfo = funcInfo[numArgs];             if (funcInfo !== undefined) {                 if (funcInfo[argumentIndex]) {                     if (typeof funcInfo[argumentIndex] === 'object' &amp;&amp;                         funcInfo[argumentIndex]['enumBitwiseOr'] !== undefined) {                         var enums = funcInfo[argumentIndex]['enumBitwiseOr'];                         var orResult = 0;                         var orEnums = [];                         for (var i = 0; i &lt; enums.length; ++i) {                             var enumValue = enumStringToValue[enums[i]];                             if ((value &amp; enumValue) !== 0) {                                 orResult |= enumValue;                                 orEnums.push(glEnumToString(enumValue));                             }                         }                         if (orResult === value) {                             return orEnums.join(' | ');                         } else {                             return glEnumToString(value);                         }                     } else {                         return glEnumToString(value);                     }                 }             }         }         if (value === null) {             return 'null';         } else if (value === undefined) {             return 'undefined';         } else {             return value.toString();         }     }      /**      * Converts the arguments of a WebGL function to a string.      * Attempts to convert enum arguments to strings.      *      * @param {string} functionName the name of the WebGL function.      * @param {number} args The arguments.      * @return {string} The arguments as a string.      */     function glFunctionArgsToString(functionName, args) {         var argStr = '';         var numArgs = args.length;         for (var ii = 0; ii &lt; numArgs; ++ii) {             argStr += ((ii == 0) ? '' : ', ') +             glFunctionArgToString(functionName, numArgs, ii, args[ii]);         }         return argStr;     };       function makePropertyWrapper(wrapper, original, propertyName) {         wrapper.__defineGetter__(propertyName, function() {             return original[propertyName];         });         wrapper.__defineSetter__(propertyName, function(value) {             original[propertyName] = value;         });     }      function makeFunctionWrapper(original, functionName) {         var f = original[functionName];         return function() {             var result = f.apply(original, arguments);             return result;         };     }      /**      * Given a WebGL context returns a wrapped context that calls      * gl.getError after every command and calls a function if the      * result is not gl.NO_ERROR.      *      * @param {!WebGLRenderingContext} ctx The webgl context to      *        wrap.      * @param {!function(err, funcName, args): void} opt_onErrorFunc      *        The function to call when gl.getError returns an      *        error. If not specified the default function calls      *        console.log with a message.      * @param {!function(funcName, args): void} opt_onFunc The      *        function to call when each webgl function is called.      *        You can use this to log all calls for example.      * @param {!WebGLRenderingContext} opt_err_ctx The webgl context      *        to call getError on if different than ctx.      */     function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc, opt_err_ctx) {         opt_err_ctx = opt_err_ctx || ctx;         init(ctx);         opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {             var argStr = '';             var numArgs = args.length;             for (var ii = 0; ii &lt; numArgs; ++ii) {                 argStr += ((ii == 0) ? '' : ', ') +                 glFunctionArgToString(functionName, numArgs, ii, args[ii]);             }             error('WebGL error '+ glEnumToString(err) + ' in '+ functionName +             '(' + argStr + ')');         };          var glErrorShadow = { };          function makeErrorWrapper(ctx, functionName) {             return function() {                 if (opt_onFunc) {                     opt_onFunc(functionName, arguments);                 }                 var result = ctx[functionName].apply(ctx, arguments);                 var err = opt_err_ctx.getError();                 if (err != 0) {                     glErrorShadow[err] = true;                     opt_onErrorFunc(err, functionName, arguments);                 }                 return result;             };         }          var wrapper = {};         for (var propertyName in ctx) {             if (typeof ctx[propertyName] == 'function') {                 if (propertyName != 'getExtension') {                     wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);                 } else {                     var wrapped = makeErrorWrapper(ctx, propertyName);                     wrapper[propertyName] = function () {                         var result = wrapped.apply(ctx, arguments);                         return makeDebugContext(result, opt_onErrorFunc, opt_onFunc, opt_err_ctx);                     };                 }             } else {                 makePropertyWrapper(wrapper, ctx, propertyName);             }         }          wrapper.getError = function() {             for (var err in glErrorShadow) {                 if (glErrorShadow.hasOwnProperty(err)) {                     if (glErrorShadow[err]) {                         glErrorShadow[err] = false;                         return err;                     }                 }             }             return ctx.NO_ERROR;         };          return wrapper;     }      function resetToInitialState(ctx) {         var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);         var tmp = ctx.createBuffer();         ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);         for (var ii = 0; ii &lt; numAttribs; ++ii) {             ctx.disableVertexAttribArray(ii);             ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);             ctx.vertexAttrib1f(ii, 0);         }         ctx.deleteBuffer(tmp);          var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);         for (var ii = 0; ii &lt; numTextureUnits; ++ii) {             ctx.activeTexture(ctx.TEXTURE0 + ii);             ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);             ctx.bindTexture(ctx.TEXTURE_2D, null);         }          ctx.activeTexture(ctx.TEXTURE0);         ctx.useProgram(null);         ctx.bindBuffer(ctx.ARRAY_BUFFER, null);         ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);         ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);         ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);         ctx.disable(ctx.BLEND);         ctx.disable(ctx.CULL_FACE);         ctx.disable(ctx.DEPTH_TEST);         ctx.disable(ctx.DITHER);         ctx.disable(ctx.SCISSOR_TEST);         ctx.blendColor(0, 0, 0, 0);         ctx.blendEquation(ctx.FUNC_ADD);         ctx.blendFunc(ctx.ONE, ctx.ZERO);         ctx.clearColor(0, 0, 0, 0);         ctx.clearDepth(1);         ctx.clearStencil(-1);         ctx.colorMask(true, true, true, true);         ctx.cullFace(ctx.BACK);         ctx.depthFunc(ctx.LESS);         ctx.depthMask(true);         ctx.depthRange(0, 1);         ctx.frontFace(ctx.CCW);         ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);         ctx.lineWidth(1);         ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);         ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);         ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);         ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);         if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {             ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);         }         ctx.polygonOffset(0, 0);         ctx.sampleCoverage(1, false);         ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);         ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);         ctx.stencilMask(0xFFFFFFFF);         ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);         ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);         ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);          while(ctx.getError());     }      function makeLostContextSimulatingCanvas(canvas) {         var unwrappedContext_;         var wrappedContext_;         var onLost_ = [];         var onRestored_ = [];         var wrappedContext_ = {};         var contextId_ = 1;         var contextLost_ = false;         var resourceId_ = 0;         var resourceDb_ = [];         var numCallsToLoseContext_ = 0;         var numCalls_ = 0;         var canRestore_ = false;         var restoreTimeout_ = 0;          var glErrorShadow_ = { };          canvas.getContext = function(f) {             return function() {                 var ctx = f.apply(canvas, arguments);                 if (ctx instanceof WebGLRenderingContext) {                     if (ctx != unwrappedContext_) {                         if (unwrappedContext_) {                             throw 'got different context'                         }                         unwrappedContext_ = ctx;                         wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);                     }                     return wrappedContext_;                 }                 return ctx;             }         }(canvas.getContext);          function wrapEvent(listener) {             if (typeof(listener) == 'function') {                 return listener;             } else {                 return function(info) {                     listener.handleEvent(info);                 }             }         }          var addOnContextLostListener = function(listener) {             onLost_.push(wrapEvent(listener));         };          var addOnContextRestoredListener = function(listener) {             onRestored_.push(wrapEvent(listener));         };           function wrapAddEventListener(canvas) {             var f = canvas.addEventListener;             canvas.addEventListener = function(type, listener, bubble) {                 switch (type) {                     case 'webglcontextlost':                         addOnContextLostListener(listener);                         break;                     case 'webglcontextrestored':                         addOnContextRestoredListener(listener);                         break;                     default:                         f.apply(canvas, arguments);                 }             };         }          wrapAddEventListener(canvas);          canvas.loseContext = function() {             if (!contextLost_) {                 contextLost_ = true;                 numCallsToLoseContext_ = 0;                 ++contextId_;                 while (unwrappedContext_.getError());                 clearErrors();                 glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;                 var event = makeWebGLContextEvent('context lost');                 var callbacks = onLost_.slice();                 setTimeout(function() {                     for (var ii = 0; ii &lt; callbacks.length; ++ii) {                         callbacks[ii](event);                     }                     if (restoreTimeout_ &gt;= 0) {                         setTimeout(function() {                             canvas.restoreContext();                         }, restoreTimeout_);                     }                 }, 0);             }         };          canvas.restoreContext = function() {             if (contextLost_) {                 if (onRestored_.length) {                     setTimeout(function() {                         if (!canRestore_) {                             throw 'can not restore. webglcontestlost listener did not call event.preventDefault';                         }                         freeResources();                         resetToInitialState(unwrappedContext_);                         contextLost_ = false;                         numCalls_ = 0;                         canRestore_ = false;                         var callbacks = onRestored_.slice();                         var event = makeWebGLContextEvent('context restored');                         for (var ii = 0; ii &lt; callbacks.length; ++ii) {                             callbacks[ii](event);                         }                     }, 0);                 }             }         };          canvas.loseContextInNCalls = function(numCalls) {             if (contextLost_) {                 throw 'You can not ask a lost contet to be lost';             }             numCallsToLoseContext_ = numCalls_ + numCalls;         };          canvas.getNumCalls = function() {             return numCalls_;         };          canvas.setRestoreTimeout = function(timeout) {             restoreTimeout_ = timeout;         };          function isWebGLObject(obj) {             return (obj instanceof WebGLBuffer ||             obj instanceof WebGLFramebuffer ||             obj instanceof WebGLProgram ||             obj instanceof WebGLRenderbuffer ||             obj instanceof WebGLShader ||             obj instanceof WebGLTexture);         }          function checkResources(args) {             for (var ii = 0; ii &lt; args.length; ++ii) {                 var arg = args[ii];                 if (isWebGLObject(arg)) {                     return arg.__webglDebugContextLostId__ == contextId_;                 }             }             return true;         }          function clearErrors() {             var k = Object.keys(glErrorShadow_);             for (var ii = 0; ii &lt; k.length; ++ii) {                 delete glErrorShadow_[k];             }         }          function loseContextIfTime() {             ++numCalls_;             if (!contextLost_) {                 if (numCallsToLoseContext_ == numCalls_) {                     canvas.loseContext();                 }             }         }          function makeLostContextFunctionWrapper(ctx, functionName) {             var f = ctx[functionName];             return function() {                 loseContextIfTime();                 if (!contextLost_) {                     var result = f.apply(ctx, arguments);                     return result;                 }             };         }          function freeResources() {             for (var ii = 0; ii &lt; resourceDb_.length; ++ii) {                 var resource = resourceDb_[ii];                 if (resource instanceof WebGLBuffer) {                     unwrappedContext_.deleteBuffer(resource);                 } else if (resource instanceof WebGLFramebuffer) {                     unwrappedContext_.deleteFramebuffer(resource);                 } else if (resource instanceof WebGLProgram) {                     unwrappedContext_.deleteProgram(resource);                 } else if (resource instanceof WebGLRenderbuffer) {                     unwrappedContext_.deleteRenderbuffer(resource);                 } else if (resource instanceof WebGLShader) {                     unwrappedContext_.deleteShader(resource);                 } else if (resource instanceof WebGLTexture) {                     unwrappedContext_.deleteTexture(resource);                 }             }         }          function makeWebGLContextEvent(statusMessage) {             return {                 statusMessage: statusMessage,                 preventDefault: function() {                     canRestore_ = true;                 }             };         }          return canvas;          function makeLostContextSimulatingContext(ctx) {             for (var propertyName in ctx) {                 if (typeof ctx[propertyName] == 'function') {                     wrappedContext_[propertyName] = makeLostContextFunctionWrapper(                         ctx, propertyName);                 } else {                     makePropertyWrapper(wrappedContext_, ctx, propertyName);                 }             }              wrappedContext_.getError = function() {                 loseContextIfTime();                 if (!contextLost_) {                     var err;                     while (err = unwrappedContext_.getError()) {                         glErrorShadow_[err] = true;                     }                 }                 for (var err in glErrorShadow_) {                     if (glErrorShadow_[err]) {                         delete glErrorShadow_[err];                         return err;                     }                 }                 return wrappedContext_.NO_ERROR;             };              var creationFunctions = [                 'createBuffer',                 'createFramebuffer',                 'createProgram',                 'createRenderbuffer',                 'createShader',                 'createTexture'             ];             for (var ii = 0; ii &lt; creationFunctions.length; ++ii) {                 var functionName = creationFunctions[ii];                 wrappedContext_[functionName] = function(f) {                     return function() {                         loseContextIfTime();                         if (contextLost_) {                             return null;                         }                         var obj = f.apply(ctx, arguments);                         obj.__webglDebugContextLostId__ = contextId_;                         resourceDb_.push(obj);                         return obj;                     };                 }(ctx[functionName]);             }              var functionsThatShouldReturnNull = [                 'getActiveAttrib',                 'getActiveUniform',                 'getBufferParameter',                 'getContextAttributes',                 'getAttachedShaders',                 'getFramebufferAttachmentParameter',                 'getParameter',                 'getProgramParameter',                 'getProgramInfoLog',                 'getRenderbufferParameter',                 'getShaderParameter',                 'getShaderInfoLog',                 'getShaderSource',                 'getTexParameter',                 'getUniform',                 'getUniformLocation',                 'getVertexAttrib'             ];             for (var ii = 0; ii &lt; functionsThatShouldReturnNull.length; ++ii) {                 var functionName = functionsThatShouldReturnNull[ii];                 wrappedContext_[functionName] = function(f) {                     return function() {                         loseContextIfTime();                         if (contextLost_) {                             return null;                         }                         return f.apply(ctx, arguments);                     }                 }(wrappedContext_[functionName]);             }              var isFunctions = [                 'isBuffer',                 'isEnabled',                 'isFramebuffer',                 'isProgram',                 'isRenderbuffer',                 'isShader',                 'isTexture'             ];             for (var ii = 0; ii &lt; isFunctions.length; ++ii) {                 var functionName = isFunctions[ii];                 wrappedContext_[functionName] = function(f) {                     return function() {                         loseContextIfTime();                         if (contextLost_) {                             return false;                         }                         return f.apply(ctx, arguments);                     }                 }(wrappedContext_[functionName]);             }              wrappedContext_.checkFramebufferStatus = function(f) {                 return function() {                     loseContextIfTime();                     if (contextLost_) {                         return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;                     }                     return f.apply(ctx, arguments);                 };             }(wrappedContext_.checkFramebufferStatus);              wrappedContext_.getAttribLocation = function(f) {                 return function() {                     loseContextIfTime();                     if (contextLost_) {                         return -1;                     }                     return f.apply(ctx, arguments);                 };             }(wrappedContext_.getAttribLocation);              wrappedContext_.getVertexAttribOffset = function(f) {                 return function() {                     loseContextIfTime();                     if (contextLost_) {                         return 0;                     }                     return f.apply(ctx, arguments);                 };             }(wrappedContext_.getVertexAttribOffset);              wrappedContext_.isContextLost = function() {                 return contextLost_;             };              return wrappedContext_;         }     }      return {         /**          * Initializes this module. Safe to call more than once.          * @param {!WebGLRenderingContext} ctx A WebGL context. If          *    you have more than one context it doesn't matter which one          *    you pass in, it is only used to pull out constants.          */         'init': init,          /**          * Returns true or false if value matches any WebGL enum          * @param {*} value Value to check if it might be an enum.          * @return {boolean} True if value matches one of the WebGL defined enums          */         'mightBeEnum': mightBeEnum,          /**          * Gets an string version of an WebGL enum.          *          * Example:          *   WebGLDebugUtil.init(ctx);          *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());          *          * @param {number} value Value to return an enum for          * @return {string} The string version of the enum.          */         'glEnumToString': glEnumToString,          /**          * Converts the argument of a WebGL function to a string.          * Attempts to convert enum arguments to strings.          *          * Example:          *   WebGLDebugUtil.init(ctx);          *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 2, 0, gl.TEXTURE_2D);          *          * would return 'TEXTURE_2D'          *          * @param {string} functionName the name of the WebGL function.          * @param {number} numArgs The number of arguments          * @param {number} argumentIndx the index of the argument.          * @param {*} value The value of the argument.          * @return {string} The value as a string.          */         'glFunctionArgToString': glFunctionArgToString,          /**          * Converts the arguments of a WebGL function to a string.          * Attempts to convert enum arguments to strings.          *          * @param {string} functionName the name of the WebGL function.          * @param {number} args The arguments.          * @return {string} The arguments as a string.          */         'glFunctionArgsToString': glFunctionArgsToString,          /**          * Given a WebGL context returns a wrapped context that calls          * gl.getError after every command and calls a function if the          * result is not NO_ERROR.          *          * You can supply your own function if you want. For example, if you'd like          * an exception thrown on any GL error you could do this          *          *    function throwOnGLError(err, funcName, args) {    *      throw WebGLDebugUtils.glEnumToString(err) +    *            ' was caused by call to ' + funcName;    *    };          *          *    ctx = WebGLDebugUtils.makeDebugContext(          *        canvas.getContext('webgl'), throwOnGLError);          *          * @param {!WebGLRenderingContext} ctx The webgl context to wrap.          * @param {!function(err, funcName, args): void} opt_onErrorFunc The function          *     to call when gl.getError returns an error. If not specified the default          *     function calls console.log with a message.          * @param {!function(funcName, args): void} opt_onFunc The          *     function to call when each webgl function is called. You          *     can use this to log all calls for example.          */         'makeDebugContext': makeDebugContext,          /**          * Given a canvas element returns a wrapped canvas element that will          * simulate lost context. The canvas returned adds the following functions.          *          * loseContext:          *   simulates a lost context event.          *          * restoreContext:          *   simulates the context being restored.          *          * lostContextInNCalls:          *   loses the context after N gl calls.          *          * getNumCalls:          *   tells you how many gl calls there have been so far.          *          * setRestoreTimeout:          *   sets the number of milliseconds until the context is restored          *   after it has been lost. Defaults to 0. Pass -1 to prevent          *   automatic restoring.          *          * @param {!Canvas} canvas The canvas element to wrap.          */         'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,          /**          * Resets a context to the initial state.          * @param {!WebGLRenderingContext} ctx The webgl context to          *     reset.          */         'resetToInitialState': resetToInitialState     };  }(); &quot;;

        var dataUrl = &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gYGDCgiz+xrqQAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAABWUlEQVQ4y42SPUtdURBF50jyQIugImijIEJAiE0gARuxtU1jJVjapEnvT7Czs7CQ1ClCGiGVTUibIuBXl2BnLEQ0sFYK5zwP18eLGy4MM7P37DN3IjpQIyICmAL21b3MP4thAPpkdRm48B5v439Q28mv1RtVQPUrMD2U3MTz6mVDPgRmun3VMdAnTqjvgfO0faxuxFOgzgFnzdRfA/Yzos6oC+ps8sbVbwF8SSI+YB3oqa/UD+pn9XfWrtSP+TwLYEREKSXUKKVUZz8jYrqUMtm4tWRD7uRsJCIOsn6dtdxMLEbEZCVmrkSEtaeUchvAC/UdsKTupk0SNbb71Sd3FzoGnA5Q6KtWYs21V1gyfqPeNU1X6ol6W0mJH8Bm10Fd0ArwJ0W2MvcpBc6BNfX50KsERvP3Hao94HtOXh3U/0gkr3OnsXyhbg8lN9N76pH6F9gEXgJTg8j/AAQlDaQ2bIk8AAAAAElFTkSuQmCC&quot;;

        var css = ' /* ------------------------------------------------------------------------------------------------------------------ */ ' + ' /* DEFAULT PRE STATISTICS VIEWER                                                                                    */ ' + ' /* ------------------------------------------------------------------------------------------------------------------ */ ' + ' .pre-stats-viewer {position: absolute;display: inline-block;margin:  2px;padding: 5px;width: 135px;top: 0;right: 0;opacity: 0.9;background-color: #1133dd;z-index: 1000;font-family: Arial, sans-serif;color: #C8C8C8;font-weight: bold;text-transform: uppercase;cursor: help;} ' + ' .pre-stats-viewer-hidden {visibility: collapse;width: 0px;height: 0px;}' + ' .pre-stats-head {display: block;font-size: 26px;}' + ' .pre-stats-bunnyIcon{background-image: url(' + dataUrl + ');width: 16px;height: 16px;}' + ' .pre-stats-head2 {font-size: 10px;}' + ' .pre-stats-list {float: left;width: 100%;border-top: 1px solid #C8C8C8;list-style: none;font-size: 9px;line-height: 18px;margin:0;padding: 0;padding-top: 2px;}' + ' .pre-stats-item  {width: 100%;float: left;}' + ' .pre-stats-item-title {float: left;margin-left: 2px;}' + ' .pre-stats-item-value {float: right;margin-right: 2px;}';

        document.write('&lt;script&gt;' + glMatrix + '&lt;/script&gt;');
        document.write('&lt;script&gt;' + webgl_debug + '&lt;/script&gt;');
        document.write('&lt;style type=&quot;text/css&quot;&gt;' + css + '&lt;/style&gt;');
    })();
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (ResourceType) {
        ResourceType[ResourceType[&quot;INT_8&quot;] = parseInt(&quot;0x1400&quot;, 16)] = &quot;INT_8&quot;;
        ResourceType[ResourceType[&quot;UINT_8&quot;] = parseInt(&quot;0x1401&quot;, 16)] = &quot;UINT_8&quot;;
        ResourceType[ResourceType[&quot;INT_16&quot;] = parseInt(&quot;0x1402&quot;, 16)] = &quot;INT_16&quot;;
        ResourceType[ResourceType[&quot;UINT_16&quot;] = parseInt(&quot;0x1403&quot;, 16)] = &quot;UINT_16&quot;;
        ResourceType[ResourceType[&quot;INT_32&quot;] = parseInt(&quot;0x1404&quot;, 16)] = &quot;INT_32&quot;;
        ResourceType[ResourceType[&quot;UINT_32&quot;] = parseInt(&quot;0x1405&quot;, 16)] = &quot;UINT_32&quot;;
        ResourceType[ResourceType[&quot;FLOAT_32&quot;] = parseInt(&quot;0x1406&quot;, 16)] = &quot;FLOAT_32&quot;;
        ResourceType[ResourceType[&quot;vec2f&quot;] = parseInt(&quot;0x8B50&quot;, 16)] = &quot;vec2f&quot;;
        ResourceType[ResourceType[&quot;vec3f&quot;] = parseInt(&quot;0x8B51&quot;, 16)] = &quot;vec3f&quot;;
        ResourceType[ResourceType[&quot;vec4f&quot;] = parseInt(&quot;0x8B52&quot;, 16)] = &quot;vec4f&quot;;
        ResourceType[ResourceType[&quot;vec2i&quot;] = parseInt(&quot;0x8B53&quot;, 16)] = &quot;vec2i&quot;;
        ResourceType[ResourceType[&quot;vec3i&quot;] = parseInt(&quot;0x8B54&quot;, 16)] = &quot;vec3i&quot;;
        ResourceType[ResourceType[&quot;vec4i&quot;] = parseInt(&quot;0x8B55&quot;, 16)] = &quot;vec4i&quot;;
        ResourceType[ResourceType[&quot;bool&quot;] = parseInt(&quot;0x8B56&quot;, 16)] = &quot;bool&quot;;
        ResourceType[ResourceType[&quot;vec2bool&quot;] = parseInt(&quot;0x8B57&quot;, 16)] = &quot;vec2bool&quot;;
        ResourceType[ResourceType[&quot;vec3bool&quot;] = parseInt(&quot;0x8B58&quot;, 16)] = &quot;vec3bool&quot;;
        ResourceType[ResourceType[&quot;vec4bool&quot;] = parseInt(&quot;0x8B59&quot;, 16)] = &quot;vec4bool&quot;;
        ResourceType[ResourceType[&quot;mat2f&quot;] = parseInt(&quot;0x8B5A&quot;, 16)] = &quot;mat2f&quot;;
        ResourceType[ResourceType[&quot;mat3f&quot;] = parseInt(&quot;0x8B5B&quot;, 16)] = &quot;mat3f&quot;;
        ResourceType[ResourceType[&quot;mat4f&quot;] = parseInt(&quot;0x8B5C&quot;, 16)] = &quot;mat4f&quot;;
        ResourceType[ResourceType[&quot;sampler2D&quot;] = parseInt(&quot;0x8B5E&quot;, 16)] = &quot;sampler2D&quot;;
        ResourceType[ResourceType[&quot;samplerCube&quot;] = parseInt(&quot;0x8B60&quot;, 16)] = &quot;samplerCube&quot;;
        ResourceType[ResourceType[&quot;OBJECT&quot;] = 0] = &quot;OBJECT&quot;;
    })(pre.ResourceType || (pre.ResourceType = {}));
    var ResourceType = pre.ResourceType;

    var AbstractResource = (function () {
        function AbstractResource(type, fetch) {
            var _this = this;
            this._version = 0;
            this.setContent = function (content) {
                _this._data = content;
                _this._isReady = true;
            };
            this._id = pre.Environment.getInstance().getObjectCatalog().registerResource(this);
            this._type = type;
            this._fetch = fetch;
            this._dirty = true;
        }
        AbstractResource.prototype.getID = function () {
            return this._id;
        };

        AbstractResource.prototype.getType = function () {
            return this._type;
        };

        AbstractResource.prototype.setType = function (type) {
            this._type = type;
        };

        AbstractResource.prototype.setDirty = function (dirty) {
            if (typeof dirty === &quot;undefined&quot;) { dirty = true; }
            this._dirty = dirty;
            if (dirty) {
                this._version++;
            }
        };

        AbstractResource.prototype.isDirty = function () {
            return this._dirty;
        };

        AbstractResource.prototype.getVersion = function () {
            return this._version;
        };

        AbstractResource.prototype.setReady = function (ready) {
            if (typeof ready === &quot;undefined&quot;) { ready = true; }
            this._isReady = ready;
        };

        AbstractResource.prototype.isReady = function () {
            return this._isReady;
        };

        AbstractResource.prototype.getData = function () {
            if (this.isDirty()) {
                this._isReady = false;
                this._data = this._fetch(this.setContent);
                this._dirty = false;
                if (this._data) {
                    this._isReady = true;
                }
            }
            if (this.isReady) {
                return this._data;
            } else {
                return null;
            }
        };

        AbstractResource.prototype.equals = function (other) {
            return false;
        };
        return AbstractResource;
    })();
    pre.AbstractResource = AbstractResource;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var ResourceContainer = (function () {
        function ResourceContainer() {
            this._resources = {};
        }
        ResourceContainer.prototype.requestResource = function (name) {
            return this._resources[name];
        };

        ResourceContainer.prototype.attachResource = function (name, resource) {
            this._resources[name] = resource;
        };

        ResourceContainer.prototype.removeResource = function (name) {
            delete this._resources[name];
        };

        ResourceContainer.prototype.getResources = function () {
            return this._resources;
        };

        ResourceContainer.prototype.copyResources = function (other) {
            var resources = other.getResources();
            var keys = Object.keys(resources);
            for (var i = 0; i &lt; keys.length; i++) {
                this.attachResource(keys[i], resources[keys[i]]);
            }
        };
        return ResourceContainer;
    })();
    pre.ResourceContainer = ResourceContainer;
})(pre || (pre = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var pre;
(function (pre) {
    (function (BufferUsageHint) {
        BufferUsageHint[BufferUsageHint[&quot;STREAM&quot;] = 0x88E0] = &quot;STREAM&quot;;
        BufferUsageHint[BufferUsageHint[&quot;STATIC&quot;] = 0x88E4] = &quot;STATIC&quot;;
        BufferUsageHint[BufferUsageHint[&quot;DYNAMIC&quot;] = 0x88E8] = &quot;DYNAMIC&quot;;
    })(pre.BufferUsageHint || (pre.BufferUsageHint = {}));
    var BufferUsageHint = pre.BufferUsageHint;

    var AbstractBufferResource = (function (_super) {
        __extends(AbstractBufferResource, _super);
        function AbstractBufferResource(type, fetch, componentCount, normalized, stride, offset, bufferSize, decodeOffset, decodeScale, usageHint) {
            if (typeof componentCount === &quot;undefined&quot;) { componentCount = 0; }
            if (typeof normalized === &quot;undefined&quot;) { normalized = false; }
            if (typeof stride === &quot;undefined&quot;) { stride = 0; }
            if (typeof offset === &quot;undefined&quot;) { offset = 0; }
            if (typeof bufferSize === &quot;undefined&quot;) { bufferSize = 0; }
            if (typeof decodeOffset === &quot;undefined&quot;) { decodeOffset = null; }
            if (typeof decodeScale === &quot;undefined&quot;) { decodeScale = null; }
            if (typeof usageHint === &quot;undefined&quot;) { usageHint = 35044 /* STATIC */; }
            _super.call(this, type, fetch);
            this._componentCount = -1;
            this._bufferSize = -1;
            this._normalize = false;
            this._stride = 0;
            this._offset = 0;
            this._decodeOffset = null;
            this._decodeScale = null;
            this._usageHint = 35044 /* STATIC */;

            this._componentCount = componentCount;
            this._normalize = normalized;
            this._stride = stride;
            this._offset = offset;
            this._bufferSize = bufferSize;
            this._decodeOffset = decodeOffset;
            this._decodeScale = decodeScale;
            this._usageHint = usageHint;
        }
        AbstractBufferResource.prototype.getBufferSize = function () {
            return this._bufferSize;
        };

        AbstractBufferResource.prototype.getComponentCount = function () {
            return this._componentCount;
        };

        AbstractBufferResource.prototype.getNormalize = function () {
            return this._normalize;
        };

        AbstractBufferResource.prototype.getStride = function () {
            return this._stride;
        };

        AbstractBufferResource.prototype.getOffset = function () {
            return this._offset;
        };

        AbstractBufferResource.prototype.needsDecoding = function () {
            return (this._decodeOffset != null) || (this._decodeScale != null);
        };

        AbstractBufferResource.prototype.getDecodeOffset = function () {
            return this._decodeOffset;
        };

        AbstractBufferResource.prototype.getDecodeScale = function () {
            if (this._decodeOffset) {
                var s = this._decodeScale;
                return [1 / s[0], 1 / s[1], 1 / s[2]];
            }
            return null;
        };

        AbstractBufferResource.prototype.getUsageHint = function () {
            return this._usageHint;
        };

        AbstractBufferResource.prototype.setUsageHint = function (usageHint) {
            this._usageHint = usageHint;
        };
        return AbstractBufferResource;
    })(pre.AbstractResource);
    pre.AbstractBufferResource = AbstractBufferResource;
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (PrimitiveType) {
        PrimitiveType[PrimitiveType[&quot;POINTS&quot;] = parseInt(&quot;0x0000&quot;, 16)] = &quot;POINTS&quot;;
        PrimitiveType[PrimitiveType[&quot;LINES&quot;] = parseInt(&quot;0x0001&quot;, 16)] = &quot;LINES&quot;;
        PrimitiveType[PrimitiveType[&quot;LINE_LOOP&quot;] = parseInt(&quot;0x0002&quot;, 16)] = &quot;LINE_LOOP&quot;;
        PrimitiveType[PrimitiveType[&quot;LINE_STRIP&quot;] = parseInt(&quot;0x0003&quot;, 16)] = &quot;LINE_STRIP&quot;;
        PrimitiveType[PrimitiveType[&quot;TRIANGLES&quot;] = parseInt(&quot;0x0004&quot;, 16)] = &quot;TRIANGLES&quot;;
        PrimitiveType[PrimitiveType[&quot;TRIANGLE_STRIP&quot;] = parseInt(&quot;0x0005&quot;, 16)] = &quot;TRIANGLE_STRIP&quot;;
        PrimitiveType[PrimitiveType[&quot;TRIANGLE_FAN&quot;] = parseInt(&quot;0x0006&quot;, 16)] = &quot;TRIANGLE_FAN&quot;;
    })(pre.PrimitiveType || (pre.PrimitiveType = {}));
    var PrimitiveType = pre.PrimitiveType;

    var AbstractGeometryDescriptor = (function (_super) {
        __extends(AbstractGeometryDescriptor, _super);
        function AbstractGeometryDescriptor() {
            _super.call(this);
            this._id = -1;
            this._numElements = -1;
            this._normalDecodeMatrix = null;
            this._positionDecodeMatrix = null;
            this._needsDecoding = true;
            this._localMatrix = null;
            this._labels = [];
            this._labelToIDMap = null;
            this._idToLabelMap = null;
            this._idToColorMap = null;
            this._idToVolumeMap = null;
            this._id = pre.Environment.getInstance().getObjectCatalog().requestGeometryDescriptorID(this);
            this._boxVolume = new pre.BoxVolume();
        }
        AbstractGeometryDescriptor.prototype.getID = function () {
            return this._id;
        };

        AbstractGeometryDescriptor.prototype.getVolume = function () {
            return this._boxVolume;
        };

        AbstractGeometryDescriptor.prototype.copyVolume = function (boxVol) {
            this._boxVolume.copy(boxVol);
        };

        AbstractGeometryDescriptor.prototype.getNumElements = function () {
            return this._numElements;
        };

        AbstractGeometryDescriptor.prototype.setNumElements = function (numElements) {
            this._numElements = numElements;
        };

        AbstractGeometryDescriptor.prototype.getPrimitiveType = function () {
            return this._primitiveType;
        };

        AbstractGeometryDescriptor.prototype.setPrimitiveType = function (primitiveType) {
            this._primitiveType = primitiveType;
        };

        AbstractGeometryDescriptor.prototype.needsDecoding = function () {
            return this._needsDecoding;
        };

        AbstractGeometryDescriptor.prototype.getPositionDecodeMatrix = function () {
            return this._positionDecodeMatrix;
        };

        AbstractGeometryDescriptor.prototype.getNormalDecodeMatrix = function () {
            return this._normalDecodeMatrix;
        };

        AbstractGeometryDescriptor.prototype.getLocalMatrix = function () {
            return this._localMatrix;
        };

        AbstractGeometryDescriptor.prototype.setLocalMatrix = function (matrix) {
            this._localMatrix = matrix;
        };

        AbstractGeometryDescriptor.prototype.setLabels = function (labels) {
            this._labels = labels;
        };

        AbstractGeometryDescriptor.prototype.getLabels = function () {
            return this._labels;
        };

        AbstractGeometryDescriptor.prototype.hasMultipleParts = function () {
            return this._labels.length &gt; 1;
        };

        AbstractGeometryDescriptor.prototype.setLabelToIDMap = function (labelToIDMap) {
            this._labelToIDMap = labelToIDMap;
        };

        AbstractGeometryDescriptor.prototype.getLabelToIDMap = function () {
            return this._labelToIDMap;
        };

        AbstractGeometryDescriptor.prototype.setIDToLabelMap = function (idToLabel) {
            this._idToLabelMap = idToLabel;
        };

        AbstractGeometryDescriptor.prototype.getIDToLabelMap = function () {
            return this._idToLabelMap;
        };

        AbstractGeometryDescriptor.prototype.setIDToColorMap = function (idToColorMap) {
            this._idToColorMap = idToColorMap;
        };

        AbstractGeometryDescriptor.prototype.getIDToColorMap = function () {
            return this._idToColorMap;
        };

        AbstractGeometryDescriptor.prototype.setIDToVolumeMap = function (idToVolumeMap) {
            this._idToVolumeMap = idToVolumeMap;
        };

        AbstractGeometryDescriptor.prototype.getIDToVolumeMap = function () {
            return this._idToVolumeMap;
        };

        AbstractGeometryDescriptor.prototype.setupDecoding = function (drawableDescriptor) {
            if (this._needsDecoding) {
                if (!this._positionDecodeMatrix &amp;&amp; !this._normalDecodeMatrix) {
                    this._needsDecoding = false;

                    var bufferResource = this._resources[&quot;position&quot;];

                    if (bufferResource &amp;&amp; bufferResource.needsDecoding() &amp;&amp; !this._positionDecodeMatrix) {
                        var decodeOffset = bufferResource.getDecodeOffset();
                        var decodeScale = bufferResource.getDecodeScale();
                        this._positionDecodeMatrix = mat4.create();
                        mat4.scale(this._positionDecodeMatrix, this._positionDecodeMatrix, new Float32Array(decodeScale));
                        mat4.translate(this._positionDecodeMatrix, this._positionDecodeMatrix, new Float32Array(decodeOffset));
                        this._needsDecoding = true;
                    }

                    bufferResource = this._resources[&quot;normal&quot;];
                    if (bufferResource &amp;&amp; bufferResource.needsDecoding() &amp;&amp; !this._normalDecodeMatrix) {
                        var decodeOffset = bufferResource.getDecodeOffset();
                        var decodeScale = bufferResource.getDecodeScale();
                        this._normalDecodeMatrix = mat4.create();
                        mat4.scale(this._normalDecodeMatrix, this._normalDecodeMatrix, new Float32Array(decodeScale));
                        mat4.translate(this._normalDecodeMatrix, this._normalDecodeMatrix, new Float32Array(decodeOffset));
                        this._needsDecoding = true;
                    }
                }
                drawableDescriptor.setPositionDecodeMatrix(this._positionDecodeMatrix);
                drawableDescriptor.setNormalDecodeMatrix(this._normalDecodeMatrix);
            }
        };

        AbstractGeometryDescriptor.prototype.prepare = function (bindingManager) {
            bindingManager.bindResourceContainer(this, 5 /* GEOMETRY */);
            return true;
        };

        AbstractGeometryDescriptor.prototype.draw = function (renderer) {
            renderer.draw(this);
            return true;
        };

        AbstractGeometryDescriptor.prototype.copy = function (other) {
            this.copyResources(other);
            this.copyVolume(other.getVolume());
            this.setNumElements(other.getNumElements());
            this.setPrimitiveType(other.getPrimitiveType());
        };
        return AbstractGeometryDescriptor;
    })(pre.ResourceContainer);
    pre.AbstractGeometryDescriptor = AbstractGeometryDescriptor;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var TreeNodeBase = (function () {
        function TreeNodeBase() {
            this._children = [];
            this._childrenPos = [];
            this._nodeID = TreeNodeBase.count++;
        }
        TreeNodeBase.prototype.getID = function () {
            return this._nodeID;
        };

        TreeNodeBase.prototype.getChildren = function () {
            return this._children;
        };

        TreeNodeBase.prototype.addChild = function (node) {
            if (this._childrenPos[node.getID()] == null) {
                this._childrenPos[node.getID()] = this._children.push(node) - 1;
                return true;
            }
            return false;
        };

        TreeNodeBase.prototype.removeChild = function (node) {
            var n = this._children.length;

            var idx = this._childrenPos[node.getID()];
            if (idx != null) {
                if (n &lt; 2) {
                    this._children.length = 0;
                } else if (idx == n - 1) {
                    this._children.pop();
                } else {
                    this._childrenPos[this._children[n - 1].getID()] = idx;
                    this._children[idx] = this._children.pop();
                }

                delete this._childrenPos[node.getID()];

                return true;
            }
            return false;
        };
        TreeNodeBase.count = 0;
        return TreeNodeBase;
    })();
    pre.TreeNodeBase = TreeNodeBase;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var GraphNodeBase = (function (_super) {
        __extends(GraphNodeBase, _super);
        function GraphNodeBase() {
            _super.call(this);
            this._parents = [];
        }
        GraphNodeBase.prototype.getParents = function () {
            return this._parents;
        };

        GraphNodeBase.prototype.addParent = function (node) {
            if (this._parents.indexOf(node) == -1) {
                this._parents.push(node);
                return true;
            }
            return false;
        };

        GraphNodeBase.prototype.removeParent = function (node) {
            var idx = this._parents.indexOf(node);
            if (idx &gt; -1) {
                this._parents.splice(idx, 1);
                return true;
            }
            return false;
        };
        return GraphNodeBase;
    })(pre.TreeNodeBase);
    pre.GraphNodeBase = GraphNodeBase;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var CullableNode = (function (_super) {
        __extends(CullableNode, _super);
        function CullableNode() {
            _super.call(this);
            this._intersect = false;
            this._screenSpaceCoverage = 0;
            this._parent = null;
            this._worldVolume = null;
            this._preferredPlane = 0;
            this._planeMask = 0;
            this._worldVolume = new pre.BoxVolume();
        }
        CullableNode.prototype.setParent = function (node) {
            this._parent = node;
        };

        CullableNode.prototype.getParent = function () {
            return this._parent;
        };

        CullableNode.prototype.getPlaneMask = function () {
            return this._planeMask;
        };

        CullableNode.prototype.getIntersect = function () {
            return this._intersect;
        };

        CullableNode.prototype.setIntersect = function (intersect) {
            this._intersect = intersect;
        };

        CullableNode.prototype.setPlaneMask = function (planeMask) {
            this._planeMask = planeMask;
        };

        CullableNode.prototype.getPreferredPlane = function () {
            return this._preferredPlane;
        };

        CullableNode.prototype.setPreferredPlane = function (preferredPlane) {
            this._preferredPlane = preferredPlane;
        };

        CullableNode.prototype.requestWorldVolume = function () {
            return this._worldVolume;
        };

        CullableNode.prototype.setScreenSpaceCoverage = function (value) {
            this._screenSpaceCoverage = value;
        };

        CullableNode.prototype.getScreenSpaceCoverage = function () {
            return this._screenSpaceCoverage;
        };
        return CullableNode;
    })(pre.TreeNodeBase);
    pre.CullableNode = CullableNode;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var ShaderDescriptorBase = (function () {
        function ShaderDescriptorBase() {
            this._name = &quot;&quot;;
            this._vSource = &quot;&quot;;
            this._fSource = &quot;&quot;;
            this._uniforms = [];
            this._attributes = [];
            this._varyings = [];
        }
        ShaderDescriptorBase.prototype.getName = function () {
            return this._name;
        };

        ShaderDescriptorBase.prototype.getVSSource = function () {
            return this._vSource;
        };

        ShaderDescriptorBase.prototype.getPSSource = function () {
            return this._fSource;
        };

        ShaderDescriptorBase.prototype.getUniforms = function (typeMask) {
            if (typeof typeMask === &quot;undefined&quot;) { typeMask = pre.UniformShaderType.ALL; }
            if (typeMask == pre.UniformShaderType.ALL) {
                return this._uniforms;
            }

            var i;
            var result = [];

            for (i = 0; i &lt; this._uniforms.length; ++i) {
                if ((this._uniforms[i].shaderType &amp; typeMask) != 0) {
                    result.push(this._uniforms[i]);
                }
            }

            return result;
        };

        ShaderDescriptorBase.prototype.getAttributes = function () {
            return this._attributes;
        };

        ShaderDescriptorBase.prototype.getVaryings = function () {
            return this._varyings;
        };
        return ShaderDescriptorBase;
    })();
    pre.ShaderDescriptorBase = ShaderDescriptorBase;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var TreeTraverserBase = (function () {
        function TreeTraverserBase() {
        }
        TreeTraverserBase.prototype._traverseChildren = function (node) {
            var children = node.getChildren();
            for (var i = 0, n = children.length; i &lt; n; ++i) {
                this.traverse(children[i]);
            }
        };

        TreeTraverserBase.prototype.traverse = function (node) {
            this._traverseChildren(node);
        };
        return TreeTraverserBase;
    })();
    pre.TreeTraverserBase = TreeTraverserBase;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var CullingTraverser = (function (_super) {
        __extends(CullingTraverser, _super);
        function CullingTraverser() {
            _super.call(this);
            this._context = null;
            this._frustum = null;
            this._camera = null;
            this._viewMatrix = null;
            this._settings = null;
            CullingTraverser._TmpCenter[3] = 1;
            CullingTraverser._TmpRadialVec[3] = 0;
        }
        CullingTraverser.prototype._traverseChildren = function (node) {
            var children = node.getChildren();
            var child = null;

            for (var i = 0, n = children.length; i &lt; n; ++i) {
                child = children[i];

                this.traverse(child);
            }
        };

        CullingTraverser.prototype.traverse = function (node) {
            var ssc = this.calculateScreenSpaceCoverage(node.requestWorldVolume());
            node.setScreenSpaceCoverage(ssc);

             {
                _super.prototype.traverse.call(this, node);
            }
        };

        CullingTraverser.prototype.setContext = function (context) {
            this._context = context;
            this._settings = context.getApplication().getSettings();
            this._camera = context.getCamera();
            this._frustum = this._camera.getFrustum();
            this._viewMatrix = this._camera.getViewMatrixResource().getData();
        };

        CullingTraverser.prototype.calculateScreenSpaceCoverage = function (volume) {
            vec3.copy(CullingTraverser._TmpCenter, volume.getCenter());
            vec3.copy(CullingTraverser._TmpRadialVec, volume.getRadialVec());

            CullingTraverser._TmpCenter[3] = 1;
            CullingTraverser._TmpRadialVec[3] = 0;

            vec4.transformMat4(CullingTraverser._TmpCenter, CullingTraverser._TmpCenter, this._viewMatrix);
            vec4.transformMat4(CullingTraverser._TmpRadialVec, CullingTraverser._TmpRadialVec, this._viewMatrix);

            var r = vec3.length(CullingTraverser._TmpRadialVec);

            var dist = Math.max(-CullingTraverser._TmpCenter[2] - r, this._camera.getZNear());

            var projViewspaceSize = dist * this._camera.getImagePlaneHeightAtDistanceOne();

            return (r * 2.0) / projViewspaceSize;
        };
        CullingTraverser._TmpCenter = vec4.create();
        CullingTraverser._TmpRadialVec = vec4.create();
        return CullingTraverser;
    })(pre.TreeTraverserBase);
    pre.CullingTraverser = CullingTraverser;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var RenderTreeNode = (function (_super) {
        __extends(RenderTreeNode, _super);
        function RenderTreeNode(application) {
            _super.call(this);
            this._application = null;
            this._enabled = true;
            this._pickListener = null;
            this._localMatrix = null;
            this._childrenToWorldMatrix = mat4.create();
            this._dirtyChildrenToWorldMatrix = true;
            this._localVolume = new pre.BoxVolume();
            this._dirtyLocalVolume = true;
            this._dirtyWorldVolume = true;
            this._drawables = [];
            this._application = application;
        }
        RenderTreeNode.prototype.setPickListener = function (pickListener) {
            this._pickListener = pickListener;
        };

        RenderTreeNode.prototype.setLocalMatrix = function (matrix) {
            this._localMatrix = matrix;

            this.setLocalMatrixDirty();
            this.setVolumeDirty();
        };

        RenderTreeNode.prototype.setParent = function (node) {
            this._parent = node;
        };

        RenderTreeNode.prototype.removeChild = function (node) {
            this._application.getPipelineControl().setFlag(6 /* NODES_CHANGED */);

            return _super.prototype.removeChild.call(this, node);
        };

        RenderTreeNode.prototype.requestChildrenToWorldMatrix = function () {
            var localTransform;

            if (this._dirtyChildrenToWorldMatrix) {
                localTransform = this._localMatrix;
                if (localTransform) {
                    if (this._parent) {
                        mat4.multiply(this._childrenToWorldMatrix, this._parent.requestChildrenToWorldMatrix(), localTransform);
                    } else {
                        mat4.copy(this._childrenToWorldMatrix, localTransform);
                    }
                } else if (this._parent) {
                    mat4.copy(this._childrenToWorldMatrix, this._parent.requestChildrenToWorldMatrix());
                }
                this._dirtyChildrenToWorldMatrix = false;
            }

            return this._childrenToWorldMatrix;
        };

        RenderTreeNode.prototype.requestToWorldMatrix = function () {
            if (this._parent) {
                return this._parent.requestChildrenToWorldMatrix();
            } else {
                return null;
            }
        };

        RenderTreeNode.prototype.requestLocalVolume = function () {
            var i, volume;

            if (this._dirtyLocalVolume) {
                this._localVolume.reset();

                for (i = 0; i &lt; this._drawables.length; ++i) {
                    this._localVolume.extendByVolume(this._drawables[i].getForm().getVolume());
                }

                var localTransformation = this._localMatrix;

                for (i = 0; i &lt; this._children.length; ++i) {
                    if (!this._children[i].isEnabled()) {
                        continue;
                    }
                    volume = this._children[i].requestLocalVolume();
                    if (volume.isValid()) {
                        this._localVolume.extendByTransformedVolume(volume, localTransformation);
                    }
                }
                this._dirtyLocalVolume = false;
            }

            return this._localVolume;
        };

        RenderTreeNode.prototype.getDrawables = function () {
            return this._drawables;
        };

        RenderTreeNode.prototype.collectDrawables = function (target, context) {
            for (var i = 0, n = this._drawables.length; i &lt; n; ++i) {
                this._drawables[i].getDrawingInfo().screenSpaceFootPrint = this._screenSpaceCoverage;

                var worldMatrix = this.requestToWorldMatrix();
                if (worldMatrix) {
                    this._drawables[i].getDrawableDescriptor().setModelMatrix(worldMatrix);
                }

                if (this._application.getSettings().codePrioritiesInDiffuseColor) {
                    var diffuse = this._drawables[i].getForm().getAppearanceDescriptor().requestResource(&quot;diffuseColor&quot;);
                    if (diffuse) {
                        util.ColorUtils.ColorBandRGBValue(diffuse.getData(), this._screenSpaceCoverage);
                    }
                }

                target.add(this._drawables[i]);
            }
        };

        RenderTreeNode.prototype.requestWorldVolume = function () {
            if (this._dirtyWorldVolume) {
                this.requestLocalVolume();
                var worldMatrix = this.requestToWorldMatrix();
                if (this._localVolume.isValid()) {
                    if (worldMatrix) {
                        this._worldVolume.transformFrom(worldMatrix, this._localVolume);
                    } else {
                        this._worldVolume.copy(this._localVolume);
                    }
                }
                this._dirtyWorldVolume = false;
            }
            return this._worldVolume;
        };

        RenderTreeNode.prototype.setLocalMatrixDirty = function () {
            if (!this._dirtyChildrenToWorldMatrix) {
                this._dirtyChildrenToWorldMatrix = true;

                var i = 0, n = this._children.length;
                for (; i &lt; n; ++i) {
                    this._children[i].setLocalMatrixDirty();
                }
            }
        };

        RenderTreeNode.prototype.setVolumeDirty = function () {
            this._dirtyLocalVolume = true;
            this._dirtyWorldVolume = true;
            if (this._parent != null) {
                this._parent.setVolumeDirty();
            }

            this._application.getPipelineControl().setFlag(3 /* GEOMETRY_CHANGED */);
        };

        RenderTreeNode.prototype.setEnabled = function (val) {
            if (typeof val === &quot;undefined&quot;) { val = true; }
            this._enabled = val;
        };

        RenderTreeNode.prototype.isEnabled = function () {
            return this._enabled;
        };

        RenderTreeNode.prototype.getPickListener = function () {
            return this._pickListener;
        };

        RenderTreeNode.prototype.replaceDrawables = function (newforms, visible, pickable) {
            if (typeof visible === &quot;undefined&quot;) { visible = true; }
            if (typeof pickable === &quot;undefined&quot;) { pickable = true; }
            this._drawables = new Array(newforms.length);

            var drawableDescriptor, drawable;

            var form;
            var partControl = this._application.getContext().getPartControl();
            for (var i = 0; i &lt; newforms.length; ++i) {
                form = newforms[i];

                drawableDescriptor = new pre.DrawableDescriptor();

                var worldMatrix = this.requestToWorldMatrix();

                drawableDescriptor.setLocalAndModelMatrix(form.getGeometryDescriptor().getLocalMatrix(), worldMatrix ? worldMatrix : mat4.create());

                drawable = new pre.Drawable(drawableDescriptor, form, this);
                this._drawables[i] = drawable;

                drawable.setPickable(pickable);
                drawable.setID(pre.Environment.getInstance().getObjectCatalog().registerDrawable(drawable, this._application));
                partControl.registerDrawableMaps(drawable, visible);
            }

            this._application.getPipelineControl().setFlag(4 /* APPEARANCE_CHANGED */);
            this._application.getPipelineControl().setFlag(3 /* GEOMETRY_CHANGED */);
        };

        RenderTreeNode.prototype.getApplication = function () {
            return this._application;
        };
        return RenderTreeNode;
    })(pre.CullableNode);
    pre.RenderTreeNode = RenderTreeNode;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var SpatialIndexBase = (function (_super) {
        __extends(SpatialIndexBase, _super);
        function SpatialIndexBase(application) {
            _super.call(this, application);
            this._context = null;
            this._compiled = false;
            this._traverser = null;
            this._renderTreeNodes = [];
            this._maxDepth = 5;
            this._traverserType = 1;
            this._drawables = [];
        }
        SpatialIndexBase.prototype.getChildren = function () {
            return [];
        };

        SpatialIndexBase.prototype.collectSubtreeNodes = function () {
            var nodeCollector = new pre.TreeNodeCollector();
            nodeCollector.setTarget(this._renderTreeNodes);
            for (var i = 0, n = this._children.length; i &lt; n; ++i) {
                nodeCollector.traverse(this._children[i]);
            }
        };

        SpatialIndexBase.prototype.collectDrawables = function (target, context) {
            return false;
        };

        SpatialIndexBase.prototype.compile = function () {
            this._compiled = true;
        };

        SpatialIndexBase.prototype.saveAddDrawable = function (target, id, coverage) {
            if (typeof coverage === &quot;undefined&quot;) { coverage = -1; }
            var drawableContainer = new pre.DrawableContainer();

            var drawable = this._drawables[id];
            var renderTreeNode = drawable.getRenderTreeNode();

            if (renderTreeNode.collectDrawables(target, this._context)) {
                if (renderTreeNode.getDrawables().indexOf(drawable) == -1) {
                    drawable = renderTreeNode.getDrawables()[0];
                    this._drawables[id] = drawable;
                }
            }

            if (renderTreeNode.isEnabled() &amp;&amp; drawable) {
                target.add(drawable);
            }
        };

        SpatialIndexBase.prototype.setMaxDepth = function (maxDepth) {
            this._maxDepth = maxDepth;
        };

        SpatialIndexBase.prototype.setTraverserType = function (type) {
            this._traverserType = type;
        };

        SpatialIndexBase.prototype.createNode = function () {
            return new pre.RenderTreeNode(this.getApplication());
        };

        SpatialIndexBase.prototype.getRoot = function () {
            return this._renderTreeNodes[0];
        };

        SpatialIndexBase.prototype.getNode = function (index) {
            return this._renderTreeNodes[index];
        };

        SpatialIndexBase.prototype.rebuild = function () {
        };
        return SpatialIndexBase;
    })(pre.RenderTreeNode);
    pre.SpatialIndexBase = SpatialIndexBase;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var SpatialIndexNodeBase = (function (_super) {
        __extends(SpatialIndexNodeBase, _super);
        function SpatialIndexNodeBase(bvh) {
            _super.call(this);
            this._id = -1;
            this._depth = -1;
            this._boxVolume = null;
            this._leaf = true;
            this._bvh = null;
            this._bvh = bvh;
        }
        SpatialIndexNodeBase.prototype.getChild = function (index) {
            return null;
        };

        SpatialIndexNodeBase.prototype.getChildCount = function () {
            return 0;
        };

        SpatialIndexNodeBase.prototype.setBoxVolume = function (boxVolume) {
            if (this._boxVolume) {
                this._boxVolume.setMin(boxVolume.getMin());
                this._boxVolume.setMax(boxVolume.getMax());
            } else {
                this._boxVolume = new pre.BoxVolume(boxVolume.getMin(), boxVolume.getMax());
            }
        };

        SpatialIndexNodeBase.prototype.getBoxVolume = function () {
            return this._boxVolume;
        };

        SpatialIndexNodeBase.prototype.isLeaf = function () {
            return this._children.length == 0;
        };

        SpatialIndexNodeBase.prototype.getDepth = function () {
            return this._depth;
        };

        SpatialIndexNodeBase.prototype.setDepth = function (depth) {
            this._depth = depth;
        };
        return SpatialIndexNodeBase;
    })(pre.CullableNode);
    pre.SpatialIndexNodeBase = SpatialIndexNodeBase;
})(pre || (pre = {}));
var x3dom;
(function (x3dom) {
    var X3DOMObject = (function (_super) {
        __extends(X3DOMObject, _super);
        function X3DOMObject() {
            _super.call(this);
            this._renderTreeNodes = [];
            this._originalDOMNode = null;
            this._x3dNamespace = null;
            this._originalDOMNode = null;
        }
        X3DOMObject.RegisterX3DOMObjectClass = function (domNodeTypeName, x3domClass) {
            X3DOMObject.X3domObjectClasses[domNodeTypeName] = x3domClass;
        };

        X3DOMObject.prototype.isUSEd = function () {
            return (this.getRenderTreeNodes().length &gt; 1);
        };

        X3DOMObject.prototype.getNamespace = function () {
            return this._x3dNamespace;
        };

        X3DOMObject.prototype.syncWithDOM = function () {
        };

        X3DOMObject.prototype.syncWithRenderTree = function () {
        };

        X3DOMObject.prototype.addChild = function (child) {
            var returnValue = _super.prototype.addChild.call(this, child);
            child.addParent(this);

            child.invalidateRenderTreeNodes();

            child._setNamespace(this._x3dNamespace);

            return returnValue;
        };

        X3DOMObject.prototype.removeChild = function (child) {
            var returnValue = _super.prototype.removeChild.call(this, child);
            child.invalidateRenderTreeNodes();

            child.removeParent(this);

            if (child._parents.length == 0) {
                child._setNamespace(null);
            }

            return returnValue;
        };

        X3DOMObject.prototype.getRenderTreeNodes = function () {
            return this._renderTreeNodes;
        };

        X3DOMObject.prototype.buildRenderTree = function (createEnabled) {
            if (typeof createEnabled === &quot;undefined&quot;) { createEnabled = true; }
            if (this._renderTreeNodes.length == 0) {
                this._createRenderTreeNodes(createEnabled);
            }

            var i;
            for (i = 0; i &lt; this._children.length; ++i) {
                this._children[i].buildRenderTree(createEnabled);
            }

            return this._renderTreeNodes;
        };

        X3DOMObject.prototype.invalidateRenderTreeNodes = function () {
            this._renderTreeNodes = [];

            var i;
            for (i = 0; i &lt; this._children.length; ++i) {
                this._children[i].invalidateRenderTreeNodes();
            }
        };

        X3DOMObject.prototype._setNamespace = function (namespace) {
            if (this._x3dNamespace != namespace) {
                this._namespaceChanged(this._x3dNamespace, namespace);
            }

            this._x3dNamespace = namespace;

            var i;
            for (i = 0; i &lt; this._children.length; ++i) {
                this._children[i]._setNamespace(namespace);
            }
        };

        X3DOMObject.prototype._namespaceChanged = function (oldNamespace, newNamespace) {
        };

        X3DOMObject.prototype.addParent = function (parentNode) {
            if (!_super.prototype.addParent.call(this, parentNode)) {
                util.Log.postError(&quot;addParent: Parent was already found in child node.&quot;);
                return false;
            }
            return true;
        };

        X3DOMObject.prototype.removeParent = function (parentNode) {
            if (!_super.prototype.removeParent.call(this, parentNode)) {
                util.Log.postError(&quot;removeParent: Parent was not found in child node.&quot;);
                return false;
            }
            return true;
        };

        X3DOMObject.prototype.getLocalTransformationMatrix = function () {
            return null;
        };

        X3DOMObject.prototype.getForms = function () {
            return [];
        };

        X3DOMObject.prototype._createNode = function (parent) {
            var node = new pre.RenderTreeNode(this._x3dNamespace.getApplication());
            node.setPickListener(this);
            node.setParent(parent);
            node.setVolumeDirty();

            return node;
        };

        X3DOMObject.prototype._createRenderTreeNodes = function (createEnabled) {
            if (typeof createEnabled === &quot;undefined&quot;) { createEnabled = true; }
            if (this._renderTreeNodes.length == 0) {
                var parentRenderTreeNodes = null;
                var renderTreeNode = null, renderTreeParent = null;

                var i, j;

                for (i = 0; i &lt; this._parents.length; ++i) {
                    this._parents[i]._createRenderTreeNodes(createEnabled);

                    parentRenderTreeNodes = this._parents[i]._renderTreeNodes;

                    for (j = 0; j &lt; parentRenderTreeNodes.length; ++j) {
                        renderTreeParent = parentRenderTreeNodes[j];

                        renderTreeNode = this._createNode(renderTreeParent);
                        renderTreeNode.setEnabled(createEnabled);
                        renderTreeParent.addChild(renderTreeNode);

                        this._renderTreeNodes.push(renderTreeNode);
                    }
                }

                if (this._renderTreeNodes.length == 0) {
                    var renderTreeNode = new pre.RenderTreeNode(this._x3dNamespace.getApplication());
                    renderTreeNode.setPickListener(this);
                    this._renderTreeNodes.push(renderTreeNode);
                }
            }
            this.syncWithRenderTree();
        };

        X3DOMObject.prototype.drawablePicked = function (drawable, pickedPoint, pickedPixel, trigger, label) {
            var event = (new CustomEvent('PickEvent'));
            var detailArgument = { drawable: drawable, point: pickedPoint, pixel: pickedPixel, actionTrigger: trigger, label: label };
            event.initCustomEvent(&quot;picked&quot;, true, false, detailArgument);
            this._originalDOMNode.dispatchEvent(event);
        };

        X3DOMObject.prototype.drawableMouseOver = function (drawable, pickedPoint, pickedPixel, label) {
        };
        X3DOMObject.X3domObjectClasses = {};
        return X3DOMObject;
    })(pre.GraphNodeBase);
    x3dom.X3DOMObject = X3DOMObject;
})(x3dom || (x3dom = {}));
var moduleName;
(function (moduleName) {
    var ExampleClass = (function () {
        function ExampleClass() {
        }
        ExampleClass.Count = function () {
            ExampleClass._Counter++;
        };

        ExampleClass.prototype.func1 = function () {
            return 0;
        };

        ExampleClass.prototype.func2 = function () {
            return 0;
        };
        return ExampleClass;
    })();
    moduleName.ExampleClass = ExampleClass;
})(moduleName || (moduleName = {}));
var navigation;
(function (navigation) {
    var AbstractNavigationController = (function () {
        function AbstractNavigationController() {
            this._active = true;
            this._lastPointerX = -1;
            this._lastPointerY = -1;
            this._lastPointerNormalizedX = -1;
            this._lastPointerNormalizedY = -1;
            this._lastPressNormalizedX = 0;
            this._lastPressNormalizedY = 0;
            this._touchIDToLastLocalX = [];
            this._touchIDToLastLocalY = [];
            this._touchIDToLastNormalizedLocalX = [];
            this._touchIDToLastNormalizedLocalY = [];
            this._navigating = false;
            this._camera = null;
            this._navigationStateListeners = [];
            this._rotMatX = mat4.create();
            this._rotMatY = mat4.create();
            this._rotMatZ = mat4.create();
            this._transMat = mat4.create();
            this._transOffset = vec3.create();
            this._negCenterOfRotation = vec3.create();
        }
        AbstractNavigationController.prototype.setActive = function (flag) {
            if (typeof flag === &quot;undefined&quot;) { flag = true; }
            this._active = flag;
        };

        AbstractNavigationController.prototype.addNavigationStateListener = function (listener) {
            this._navigationStateListeners.push(listener);
        };

        AbstractNavigationController.prototype.removeNavigationStateListener = function (listener) {
            var idx = this._navigationStateListeners.indexOf(listener);

            if (idx != -1) {
                this._navigationStateListeners.splice(idx, 1);
            }
        };

        AbstractNavigationController.prototype.getCamera = function () {
            return this._camera;
        };

        AbstractNavigationController.prototype.setCamera = function (camera) {
            this._camera = camera;
        };

        AbstractNavigationController.prototype.setPicker = function (picker) {
            this._picker = picker;
        };

        AbstractNavigationController.prototype.pointerMotion = function (pointerX, pointerY, normalizedPointerX, normalizedPointerY, pressedButton, timestamp) {
            if (this._lastPointerX == -1) {
                this._lastPointerX = pointerX;
            }
            if (this._lastPointerY == -1) {
                this._lastPointerY = pointerY;
            }

            if (this._camera) {
                var deltaX = pointerX - this._lastPointerX;
                var deltaY = pointerY - this._lastPointerY;
                var normalizedDeltaX = normalizedPointerX - this._lastPointerNormalizedX;
                var normalizedDeltaY = normalizedPointerY - this._lastPointerNormalizedY;

                if (this._active &amp;&amp; (deltaX || deltaY)) {
                    this._processPointerMotion(deltaX, deltaY, normalizedDeltaX, normalizedDeltaY, pressedButton);
                }
            }

            this._lastPointerX = pointerX;
            this._lastPointerY = pointerY;
            this._lastPointerNormalizedX = normalizedPointerX;
            this._lastPointerNormalizedY = normalizedPointerY;
        };

        AbstractNavigationController.prototype.wheelMotion = function (delta) {
        };

        AbstractNavigationController.prototype.pointerActionTriggered = function (pointerX, pointerY, normalizedPointerX, normalizedPointerY, pressedButton, type, timestamp) {
            if (type == 2 /* RELEASED */) {
                if (this._active) {
                    this._buttonReleased(pointerX, pointerY, pressedButton);
                }
            }
            if (type == 3 /* DOUBLECLICKED */) {
                if (this._active) {
                    this._buttonDoubleClicked(pointerX, pointerY, normalizedPointerX, normalizedPointerY, pressedButton, timestamp);
                }
            }
            if (type == 1 /* PRESSED */) {
                this._lastPressNormalizedX = -2.0 * normalizedPointerX + 1.0;
                this._lastPressNormalizedY = 2.0 * normalizedPointerY - 1.0;
            }
            this._lastPointerX = pointerX;
            this._lastPointerY = pointerY;
            this._lastPointerNormalizedX = normalizedPointerX;
            this._lastPointerNormalizedY = normalizedPointerY;
        };

        AbstractNavigationController.prototype.wheelScrolled = function (pointerX, pointerY, normalizedPointerX, normalizedPointerY, delta, timestamp) {
            this._lastPressNormalizedX = -2.0 * normalizedPointerX + 1.0;
            this._lastPressNormalizedY = 2.0 * normalizedPointerY - 1.0;
            if (this._active) {
                this._processWheelScrolled(pointerX, pointerY, normalizedPointerX, normalizedPointerY, delta, timestamp);
            }
        };

        AbstractNavigationController.prototype.touchStarted = function (globalTouches, localTouches, changedTouches) {
            if (this._active) {
                this._processTouchStart(globalTouches, localTouches, changedTouches);
            }

            var touch;
            var i;
            for (i = 0; i &lt; changedTouches.length; ++i) {
                touch = changedTouches[i];

                this._touchIDToLastLocalX[touch.id] = touch.localX;
                this._touchIDToLastLocalY[touch.id] = touch.localY;
                this._touchIDToLastNormalizedLocalX[touch.id] = touch.normalizedLocalX;
                this._touchIDToLastNormalizedLocalY[touch.id] = touch.normalizedLocalY;
            }
        };

        AbstractNavigationController.prototype.touchMotion = function (globalTouches, localTouches, changedTouches) {
            if (this._active) {
                this._processTouchMotion(globalTouches, localTouches, changedTouches);
            }

            var touch;
            var i;
            for (i = 0; i &lt; changedTouches.length; ++i) {
                touch = changedTouches[i];

                this._touchIDToLastLocalX[touch.id] = touch.localX;
                this._touchIDToLastLocalY[touch.id] = touch.localY;
                this._touchIDToLastNormalizedLocalX[touch.id] = touch.normalizedLocalX;
                this._touchIDToLastNormalizedLocalY[touch.id] = touch.normalizedLocalY;
            }
        };

        AbstractNavigationController.prototype.touchEnded = function (globalTouches, localTouches, changedTouches) {
            if (this._active) {
                this._processTouchEnd(globalTouches, localTouches, changedTouches);
            }
        };

        AbstractNavigationController.prototype._processPointerMotion = function (deltaX, deltaY, normalizedDeltaX, normalizedDeltaY, pressedButton) {
        };

        AbstractNavigationController.prototype._buttonReleased = function (pointerX, pointerY, pressedButton) {
        };

        AbstractNavigationController.prototype._buttonDoubleClicked = function (pointerX, pointerY, normalizedPointerX, normalizedPointerY, pressedButton, timestamp) {
        };

        AbstractNavigationController.prototype._processWheelScrolled = function (pointerX, pointerY, normalizedPointerX, normalizedPointerY, delta, timestamp) {
        };

        AbstractNavigationController.prototype._processTouchStart = function (globalTouches, localTouches, changedTouches) {
        };

        AbstractNavigationController.prototype._processTouchMotion = function (globalTouches, localTouches, changedTouches) {
        };

        AbstractNavigationController.prototype._processTouchEnd = function (globalTouches, localTouches, changedTouches) {
        };

        AbstractNavigationController.prototype._emitNavigationStarted = function () {
            var i;
            for (i = 0; i &lt; this._navigationStateListeners.length; ++i) {
                this._navigationStateListeners[i].navigationStarted();
            }
        };

        AbstractNavigationController.prototype._emitNavigationEnded = function () {
            var i;
            for (i = 0; i &lt; this._navigationStateListeners.length; ++i) {
                this._navigationStateListeners[i].navigationEnded();
            }
        };

        AbstractNavigationController.prototype._translateAlongCameraXYZ = function (dX, dY, dZ) {
            var viewMatrix = this._camera.getMutableViewMatrix();

            vec3.set(this._transOffset, dX, dY, dZ);

            mat4.identity(this._transMat);

            mat4.translate(this._transMat, this._transMat, this._transOffset);

            mat4.mul(viewMatrix, this._transMat, viewMatrix);

            this._camera.dirtyMutableViewMatrix();
            this._camera.dirtyMutableCenterOfRotation();

            this._navigating = true;
            this._emitNavigationStarted();
        };

        AbstractNavigationController.prototype._rotateAroundCameraXY = function (angleDX, angleDY) {
            if (angleDX == 0 &amp;&amp; angleDY == 0)
                return;

            var viewMatrix = this._camera.getMutableViewMatrix();
            var centerOfRotation = vec3.clone(this._camera.getMutableCenterOfRotation());

            vec3.transformMat4(centerOfRotation, centerOfRotation, viewMatrix);

            vec3.negate(this._negCenterOfRotation, centerOfRotation);

            mat4.identity(this._transMat);
            mat4.identity(this._rotMatX);
            mat4.identity(this._rotMatY);

            mat4.translate(this._transMat, this._transMat, this._negCenterOfRotation);

            mat4.rotateX(this._rotMatX, this._rotMatX, angleDX);
            mat4.rotateY(this._rotMatY, this._rotMatY, angleDY);

            mat4.mul(this._rotMatX, this._rotMatX, this._transMat);
            mat4.mul(this._rotMatY, this._rotMatY, this._transMat);

            mat4.identity(this._transMat);
            mat4.translate(this._transMat, this._transMat, centerOfRotation);

            mat4.mul(this._rotMatX, this._transMat, this._rotMatX);
            mat4.mul(this._rotMatY, this._transMat, this._rotMatY);

            mat4.mul(viewMatrix, this._rotMatX, viewMatrix);
            mat4.mul(viewMatrix, this._rotMatY, viewMatrix);

            this._camera.dirtyMutableViewMatrix();

            this._navigating = true;
            this._emitNavigationStarted();
        };

        AbstractNavigationController.prototype._rotateAroundCameraZ = function (angleDZ) {
            if (angleDZ == 0)
                return;

            var viewMatrix = this._camera.getMutableViewMatrix();
            var centerOfRotation = vec3.clone(this._camera.getMutableCenterOfRotation());

            vec3.transformMat4(centerOfRotation, centerOfRotation, viewMatrix);

            vec3.negate(this._negCenterOfRotation, centerOfRotation);

            mat4.identity(this._transMat);
            mat4.identity(this._rotMatZ);

            mat4.translate(this._transMat, this._transMat, this._negCenterOfRotation);

            mat4.rotateZ(this._rotMatZ, this._rotMatZ, angleDZ);

            mat4.mul(this._rotMatZ, this._rotMatZ, this._transMat);

            mat4.identity(this._transMat);
            mat4.translate(this._transMat, this._transMat, centerOfRotation);

            mat4.mul(this._rotMatZ, this._transMat, this._rotMatZ);

            mat4.mul(viewMatrix, this._rotMatZ, viewMatrix);

            this._camera.dirtyMutableViewMatrix();

            this._navigating = true;
            this._emitNavigationStarted();
        };

        AbstractNavigationController.prototype._rotateCameraAroundAxis = function (angle, axis) {
            if (angle == 0)
                return;

            var viewMatrix = this._camera.getMutableViewMatrix();

            mat4.identity(this._rotMatZ);
            mat4.rotate(this._rotMatZ, this._rotMatZ, angle, axis);

            mat4.mul(viewMatrix, this._rotMatZ, viewMatrix);

            this._camera.dirtyMutableViewMatrix();

            this._navigating = true;
            this._emitNavigationStarted();
        };
        return AbstractNavigationController;
    })();
    navigation.AbstractNavigationController = AbstractNavigationController;
})(navigation || (navigation = {}));
var navigation;
(function (navigation) {
    var ExamineNavigationController = (function (_super) {
        __extends(ExamineNavigationController, _super);
        function ExamineNavigationController() {
            _super.call(this);
            this._currentButton = 0 /* NONE */;
        }
        ExamineNavigationController.prototype._processPointerMotion = function (deltaX, deltaY, normalizedDeltaX, normalizedDeltaY, pressedButton) {
            var perspectiveCamera;
            var zMiddle = (this._camera._zFar + this._camera._zNear) * 0.5;
            var zOffset;
            var normalizedViewportW;
            var normalizedViewportH;

            if (pressedButton == 1 /* FIRST */) {
                this._rotateAroundCameraXY(normalizedDeltaY * 2 * Math.PI / this._camera.getAspectRatio(), normalizedDeltaX * 2 * Math.PI);
            } else if (pressedButton == 2 /* SECOND */ || pressedButton == 3 /* THIRD */) {
                if (pressedButton == 2 /* SECOND */) {
                    zOffset = normalizedDeltaY * zMiddle;
                    if (this._camera instanceof pre.PerspectiveCamera) {
                        perspectiveCamera = this._camera;
                        normalizedViewportH = Math.tan(perspectiveCamera.getFieldOfView() * 0.5);
                        normalizedViewportW = perspectiveCamera.getAspectRatio() * normalizedViewportH;

                        this._translateAlongCameraXYZ(normalizedViewportW * this._lastPressNormalizedX * zOffset, normalizedViewportH * this._lastPressNormalizedY * zOffset, zOffset);
                    } else {
                        this._translateAlongCameraXYZ(0, 0, zOffset);
                    }
                } else {
                    this._translateAlongCameraXYZ(zMiddle * normalizedDeltaX, -zMiddle * normalizedDeltaY, 0);
                }
            }
        };

        ExamineNavigationController.prototype._buttonReleased = function (pointerX, pointerY, pressedButton) {
            if (this._navigating) {
                this._navigating = false;
                this._emitNavigationEnded();
            }
        };

        ExamineNavigationController.prototype._buttonDoubleClicked = function (pointerX, pointerY, normalizedPointerX, normalizedPointerY, pressedButton, timestamp) {
            if (pressedButton == 1 /* FIRST */ &amp;&amp; this._picker) {
                var point = this._picker.getPickedPoint(normalizedPointerX, normalizedPointerY, timestamp);

                if (point &amp;&amp; point.length &gt;= 3) {
                    var centerOfRotation = this._camera.getMutableCenterOfRotation();
                    vec3.copy(centerOfRotation, new Float32Array(point));
                    this._camera.dirtyMutableCenterOfRotation();
                }
            }
        };

        ExamineNavigationController.prototype._processWheelScrolled = function (pointerX, pointerY, normalizedPointerX, normalizedPointerY, delta, timestamp) {
            this._processPointerMotion(0, 20 * delta, 0, delta * 0.05, 2 /* SECOND */);
            this._navigating = false;
            this._emitNavigationEnded();
        };

        ExamineNavigationController.prototype._processTouchMotion = function (globalTouches, localTouches, changedTouches) {
            var perspectiveCamera;
            var zMiddle = (this._camera._zFar + this._camera._zNear) * 0.5;

            var deltaAngle;

            var firstTouch, secondTouch;
            var i;

            var firstTouchPosOld;
            var secondTouchPosOld;
            var firstTouchPosNew;
            var secondTouchPosNew;
            var connectionVecOld;
            var connectionVecNew;
            var newCenter;
            var oldCenter;
            var onesVector = vec2.fromValues(1, 1);
            var zoomOffsetX = 0.0;
            var zoomOffsetY = 0.0;
            var zoomOffsetZ = 0.0;

            var connectionVecLengthDelta;

            firstTouch = changedTouches[0];

            if (globalTouches.length == 1) {
                newCenter = vec2.fromValues(firstTouch.normalizedLocalX - this._touchIDToLastNormalizedLocalX[firstTouch.id], firstTouch.normalizedLocalY - this._touchIDToLastNormalizedLocalY[firstTouch.id]);
                vec2.scale(newCenter, newCenter, 0.5 * Math.PI);
                this._rotateAroundCameraXY(newCenter[1] / this._camera.getAspectRatio(), newCenter[0]);
            } else if (localTouches.length &gt; 1) {
                for (i = 0; i &lt; globalTouches.length; ++i) {
                    if (globalTouches[i].id != changedTouches[0].id) {
                        secondTouch = globalTouches[i];
                        break;
                    }
                }

                firstTouchPosOld = vec2.fromValues(this._touchIDToLastNormalizedLocalX[firstTouch.id], this._touchIDToLastNormalizedLocalY[firstTouch.id]);
                secondTouchPosOld = vec2.fromValues(this._touchIDToLastNormalizedLocalX[secondTouch.id], this._touchIDToLastNormalizedLocalY[secondTouch.id]);

                firstTouchPosNew = vec2.fromValues(firstTouch.normalizedLocalX, firstTouch.normalizedLocalY);
                secondTouchPosNew = vec2.fromValues(secondTouch.normalizedLocalX, secondTouch.normalizedLocalY);

                connectionVecOld = vec2.create();
                vec2.subtract(connectionVecOld, secondTouchPosOld, firstTouchPosOld);

                connectionVecNew = vec2.create();
                vec2.subtract(connectionVecNew, secondTouchPosNew, firstTouchPosNew);

                deltaAngle = Math.atan2(connectionVecNew[0], connectionVecNew[1]) - Math.atan2(connectionVecOld[0], connectionVecOld[1]);

                connectionVecLengthDelta = vec2.length(connectionVecNew) - vec2.length(connectionVecOld);
                zoomOffsetZ = zMiddle * connectionVecLengthDelta;

                if (this._camera instanceof pre.PerspectiveCamera) {
                    perspectiveCamera = this._camera;

                    newCenter = vec2.create();
                    oldCenter = vec2.create();

                    vec2.add(newCenter, firstTouchPosNew, secondTouchPosNew);
                    vec2.sub(newCenter, newCenter, onesVector);
                    vec2.add(oldCenter, firstTouchPosOld, secondTouchPosOld);
                    vec2.sub(oldCenter, oldCenter, onesVector);

                    zoomOffsetY = Math.tan(perspectiveCamera.getFieldOfView() * 0.5);
                    zoomOffsetX = perspectiveCamera.getAspectRatio() * zoomOffsetY;

                    zoomOffsetX *= -newCenter[0];
                    zoomOffsetY *= newCenter[1];

                    var axis = vec3.fromValues(zoomOffsetX, zoomOffsetY, 1.0);

                    zoomOffsetX *= zoomOffsetZ;
                    zoomOffsetY *= zoomOffsetZ;

                    vec2.sub(newCenter, newCenter, oldCenter);
                    vec2.scale(newCenter, newCenter, 0.5 * zMiddle);

                    this._translateAlongCameraXYZ(zoomOffsetX + newCenter[0], zoomOffsetY - newCenter[1], zoomOffsetZ);

                    this._rotateCameraAroundAxis(deltaAngle, axis);
                } else {
                }
            }
        };

        ExamineNavigationController.prototype._processTouchEnd = function (globalTouches, localTouches, changedTouches) {
            if (globalTouches.length == 0 &amp;&amp; this._navigating) {
                this._navigating = false;
                this._emitNavigationEnded();
            }
        };
        return ExamineNavigationController;
    })(navigation.AbstractNavigationController);
    navigation.ExamineNavigationController = ExamineNavigationController;
})(navigation || (navigation = {}));
var pre;
(function (pre) {
    var TransformMatrixAnimation = (function () {
        function TransformMatrixAnimation(startMat, endMat, resultMatResource, transitionDuration, transitionType) {
            if (typeof transitionType === &quot;undefined&quot;) { transitionType = 1 /* SINE */; }
            this._transformMatrixTransition = new util.TransformMatrixTransition();
            this._startTime = -1;
            this._resultMatResource = null;
            if (resultMatResource.getType() != pre.ResourceType.mat4f) {
                util.Log.postWarning(&quot;Cannot initialize matrix animation: given resource does not contain a matrix.&quot;);
                return;
            }

            this._transformMatrixTransition.setMatrices(startMat, endMat);

            this._resultMatResource = resultMatResource;
            this._transitionDuration = transitionDuration;
            this._transitionType = transitionType;
        }
        TransformMatrixAnimation.prototype.start = function () {
            this._startTime = Date.now();
        };

        TransformMatrixAnimation.prototype.process = function () {
            if (this._startTime == -1 || !this._resultMatResource) {
                return;
            }

            var t = Math.min(Date.now() - this._startTime, this._transitionDuration) / this._transitionDuration;
            var a = util.ScalarTransition.getValue(this._transitionType, t);

            this._transformMatrixTransition.getValue(this._resultMatResource.getData(), a);

            this._resultMatResource.setDirty();
        };

        TransformMatrixAnimation.prototype.isRunning = function () {
            return (this._startTime != -1 &amp;&amp; this._resultMatResource &amp;&amp; !this.isFinished());
        };

        TransformMatrixAnimation.prototype.isFinished = function () {
            return (Date.now() - this._startTime &gt;= this._transitionDuration);
        };
        return TransformMatrixAnimation;
    })();
    pre.TransformMatrixAnimation = TransformMatrixAnimation;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var AppearanceDescriptor = (function (_super) {
        __extends(AppearanceDescriptor, _super);
        function AppearanceDescriptor() {
            _super.call(this);
            this._id = pre.Environment.getInstance().getObjectCatalog().requestAppearanceDescriptorID(this);
            this._resources[&quot;diffuseTexture&quot;] = null;
            this._resources[&quot;specularTexture&quot;] = null;
            this._resources[&quot;normalTexture&quot;] = null;
            this._resources[&quot;diffuseColor&quot;] = null;
            this._resources[&quot;specularColor&quot;] = null;
            this._resources[&quot;ambientColor&quot;] = null;
            this._resources[&quot;emissiveColor&quot;] = null;

            this._resources[&quot;lightingEnabled&quot;] = pre.Resource.Create(pre.ResourceType.bool, new Int32Array([1]));
        }
        AppearanceDescriptor.prototype.getID = function () {
            return this._id;
        };

        AppearanceDescriptor.prototype.getClassID = function () {
            if (this._appearanceClass == null) {
                this._appearanceClass = pre.Environment.getInstance().getObjectCatalog().requestAppearanceClassID(this);
            }
            return this._appearanceClass;
        };

        AppearanceDescriptor.prototype.equals = function (otherAppDesc) {
            var resources = this.getResources();
            var otherResources = otherAppDesc.getResources();
            var resKeys = Object.keys(resources);
            var otherResKeys = Object.keys(otherResources);
            if (resKeys.length != otherResKeys.length) {
                return false;
            }
            for (var r = 0; r &lt; resKeys.length; r++) {
                var res = resources[resKeys[r]];
                var otherRes = otherResources[resKeys[r]];
                if (otherRes == null || !res.equals(otherRes)) {
                    return false;
                }
            }
            return true;
        };
        return AppearanceDescriptor;
    })(pre.ResourceContainer);
    pre.AppearanceDescriptor = AppearanceDescriptor;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var ChunkedGeometryDescriptor = (function (_super) {
        __extends(ChunkedGeometryDescriptor, _super);
        function ChunkedGeometryDescriptor(srcUrl) {
            if (typeof srcUrl === &quot;undefined&quot;) { srcUrl = &quot;&quot;; }
            _super.call(this);
            this.srcUrl = srcUrl;
        }
        ChunkedGeometryDescriptor.prototype.prepare = function (bindingManager) {
            if (this._resources[&quot;indices&quot;]) {
                var indexDesc = this._resources[&quot;indices&quot;];
                bindingManager.bindIndexBuffer(indexDesc, true);
            }

            bindingManager.bindAttributeBuffers(this._resources, true);
            return _super.prototype.prepare.call(this, bindingManager);
        };
        return ChunkedGeometryDescriptor;
    })(pre.AbstractGeometryDescriptor);
    pre.ChunkedGeometryDescriptor = ChunkedGeometryDescriptor;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var DrawingInfo = (function () {
        function DrawingInfo() {
            this.userSortKeyIdx = 0;
            this.programIDIdx = -1;
            this.appearanceClass = -1;
            this.appearanceIDIdx = -1;
            this.priority = 0;
            this.userSortKey = -1;
            this.programID = -1;
            this.screenSpaceFootPrint = 0;
        }
        return DrawingInfo;
    })();
    pre.DrawingInfo = DrawingInfo;

    var Drawable = (function () {
        function Drawable(drawableDescriptor, form, renderTreeNode) {
            if (typeof renderTreeNode === &quot;undefined&quot;) { renderTreeNode = null; }
            this._id = -1;
            this._form = null;
            this._drawingInfo = null;
            this._pickable = true;
            this._prev = null;
            this._renderTreeNode = null;
            this._renderTreeNode = renderTreeNode;

            this._drawableDescriptor = drawableDescriptor;
            this._form = form;
            this._drawingInfo = new DrawingInfo();
        }
        Drawable.prototype.getID = function () {
            return this._id;
        };

        Drawable.prototype.setID = function (id) {
            this._id = id;
        };

        Drawable.prototype.getDrawableDescriptor = function () {
            return this._drawableDescriptor;
        };

        Drawable.prototype.getForm = function () {
            return this._form;
        };

        Drawable.prototype.setForm = function (form) {
            this._form = form;
        };

        Drawable.prototype.getRenderTreeNode = function () {
            return this._renderTreeNode;
        };

        Drawable.prototype.getWorldVolume = function () {
            return this._renderTreeNode.requestWorldVolume();
        };

        Drawable.prototype.getDrawingInfo = function () {
            return this._drawingInfo;
        };

        Drawable.prototype.setPickable = function (val) {
            if (typeof val === &quot;undefined&quot;) { val = true; }
            this._pickable = val;
        };

        Drawable.prototype.isPickable = function () {
            return this._pickable;
        };

        Drawable.prototype.draw = function (renderer) {
            var bindingManager = renderer.getBindingManager();

            var geoDesc = this._form.getGeometryDescriptor();
            if (!geoDesc.prepare(bindingManager)) {
                return;
            }
            geoDesc.setupDecoding(this._drawableDescriptor);

            bindingManager.bindResourceContainer(this.getDrawableDescriptor(), 4 /* DRAWABLE */);

            geoDesc.draw(renderer);
        };
        return Drawable;
    })();
    pre.Drawable = Drawable;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var DrawableDescriptor = (function (_super) {
        __extends(DrawableDescriptor, _super);
        function DrawableDescriptor() {
            _super.call(this);
            this._tmpCombinedModelMatrix = mat4.create();
            this._tmp3x3Matrix = mat3.create();
            this._mMatrix = mat4.create();
            this._nMatrix = mat4.create();
            this._modelMatrix = mat4.create();
            this._localModelMatrix = null;
            this._positionDecodeMatrix = null;
            this._normalDecodeMatrix = null;
            var that = this;

            this._resources[&quot;mMatrix&quot;] = pre.Resource.Create(pre.ResourceType.mat4f, that._mMatrix);

            this._resources[&quot;nMatrix&quot;] = pre.Resource.Create(pre.ResourceType.mat4f, that._nMatrix);

            this._subMeshIDOffset = new Int32Array(1);
            this._subMeshIDOffset[0] = -1;
            this._resources[&quot;subMeshIDOffset&quot;] = pre.Resource.Create(pre.ResourceType.INT_32, this._subMeshIDOffset);
        }
        DrawableDescriptor.prototype._copyTo4x4 = function (mat4x4, mat3x3) {
            mat4x4[0] = mat3x3[0];
            mat4x4[1] = mat3x3[1];
            mat4x4[2] = mat3x3[2];
            mat4x4[4] = mat3x3[3];
            mat4x4[5] = mat3x3[4];
            mat4x4[6] = mat3x3[5];
            mat4x4[8] = mat3x3[6];
            mat4x4[9] = mat3x3[7];
            mat4x4[10] = mat3x3[8];

            mat4x4[3] = 0;
            mat4x4[7] = 0;
            mat4x4[11] = 0;

            mat4x4[12] = 0;
            mat4x4[13] = 0;
            mat4x4[14] = 0;
            mat4x4[15] = 1;
        };

        DrawableDescriptor.prototype.updateMatrices = function () {
            if (this._localModelMatrix) {
                mat4.multiply(this._tmpCombinedModelMatrix, this._modelMatrix, this._localModelMatrix);
            } else {
                mat4.copy(this._tmpCombinedModelMatrix, this._modelMatrix);
            }

            mat3.normalFromMat4(this._tmp3x3Matrix, this._tmpCombinedModelMatrix);

            this._copyTo4x4(this._nMatrix, this._tmp3x3Matrix);

            if (this._normalDecodeMatrix) {
                mat4.multiply(this._nMatrix, this._nMatrix, this._normalDecodeMatrix);
            }

            this._resources[&quot;nMatrix&quot;].setDirty(true);

            if (this._positionDecodeMatrix) {
                mat4.multiply(this._mMatrix, this._tmpCombinedModelMatrix, this._positionDecodeMatrix);
            } else {
                mat4.copy(this._mMatrix, this._tmpCombinedModelMatrix);
            }

            this._resources[&quot;mMatrix&quot;].setDirty(true);
        };

        DrawableDescriptor.prototype.setModelMatrix = function (matrix) {
            this._modelMatrix = matrix;
            this.updateMatrices();
        };

        DrawableDescriptor.prototype.setLocalAndModelMatrix = function (localMatrix, modelMatrix) {
            this._localModelMatrix = localMatrix;
            this._modelMatrix = modelMatrix;
            this.updateMatrices();
        };

        DrawableDescriptor.prototype.getModelMatrix = function () {
            return this._modelMatrix;
        };

        DrawableDescriptor.prototype.setLocalMatrix = function (matrix) {
            this._localModelMatrix = matrix;
            this.updateMatrices();
        };

        DrawableDescriptor.prototype.setPositionDecodeMatrix = function (matrix) {
            this._positionDecodeMatrix = matrix;
            this.updateMatrices();
        };

        DrawableDescriptor.prototype.setNormalDecodeMatrix = function (matrix) {
            this._normalDecodeMatrix = matrix;
            this.updateMatrices();
        };

        DrawableDescriptor.prototype.getSubMeshIDOffset = function () {
            return this._subMeshIDOffset[0];
        };

        DrawableDescriptor.prototype.setIDMapOffset = function (offset) {
            this._subMeshIDOffset[0] = offset;
            this._resources[&quot;subMeshIDOffset&quot;].setDirty();
        };
        return DrawableDescriptor;
    })(pre.ResourceContainer);
    pre.DrawableDescriptor = DrawableDescriptor;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var Form = (function () {
        function Form(geoDesc, appDesc) {
            this._geoDesc = geoDesc;
            this._appDesc = appDesc;
        }
        Form.prototype.getVolume = function () {
            if (this._geoDesc) {
                return this._geoDesc.getVolume();
            } else {
                console.log(&quot;Cannot obtain PRE Form volume: no geometry descriptor set.&quot;);

                return null;
            }
        };

        Form.prototype.getGeometryDescriptor = function () {
            return this._geoDesc;
        };

        Form.prototype.getAppearanceDescriptor = function () {
            return this._appDesc;
        };

        Form.prototype.setAppearanceDescriptor = function (appearanceDescriptor) {
            this._appDesc = appearanceDescriptor;
        };

        Form.prototype.setGeometryDescriptor = function (geometryDescriptor) {
            this._geoDesc = geometryDescriptor;
        };
        return Form;
    })();
    pre.Form = Form;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var GeometryDescriptor = (function (_super) {
        __extends(GeometryDescriptor, _super);
        function GeometryDescriptor() {
            _super.call(this);
        }
        GeometryDescriptor.prototype.prepare = function (bindingManager) {
            if (this._resources[&quot;indices&quot;]) {
                var indexDesc = this._resources[&quot;indices&quot;];
                bindingManager.bindIndexBuffer(indexDesc);
            }

            bindingManager.bindAttributeBuffers(this._resources);
            return _super.prototype.prepare.call(this, bindingManager);
        };
        return GeometryDescriptor;
    })(pre.AbstractGeometryDescriptor);
    pre.GeometryDescriptor = GeometryDescriptor;
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (SRCState) {
        SRCState[SRCState[&quot;INIT&quot;] = 0] = &quot;INIT&quot;;
        SRCState[SRCState[&quot;REGISTERED&quot;] = 1] = &quot;REGISTERED&quot;;
        SRCState[SRCState[&quot;LOADED&quot;] = 2] = &quot;LOADED&quot;;
        SRCState[SRCState[&quot;READY&quot;] = 3] = &quot;READY&quot;;
        SRCState[SRCState[&quot;FAILED&quot;] = 4] = &quot;FAILED&quot;;
    })(pre.SRCState || (pre.SRCState = {}));
    var SRCState = pre.SRCState;

    var SRCGeometryDescriptor = (function (_super) {
        __extends(SRCGeometryDescriptor, _super);
        function SRCGeometryDescriptor(srcLoader, url, onReady, hasGeometry) {
            if (typeof url === &quot;undefined&quot;) { url = &quot;&quot;; }
            if (typeof onReady === &quot;undefined&quot;) { onReady = function () {
            }; }
            if (typeof hasGeometry === &quot;undefined&quot;) { hasGeometry = false; }
            _super.call(this);
            this._state = 0 /* INIT */;
            this._src = null;
            this._srcLoader = srcLoader;
            this._url = url;
            this._onReady = onReady;
            this._hasGeometry = hasGeometry;
        }
        SRCGeometryDescriptor.prototype._processSRC = function () {
            if (this._state != 3 /* READY */) {
                this._onReady(this._src);
                this._srcLoader.notifyGeoChanged(this._src);
                this._state = 3 /* READY */;
            }
        };

        SRCGeometryDescriptor.prototype.setupDecoding = function (drawableDescriptor) {
            if (this._hasGeometry) {
                _super.prototype.setupDecoding.call(this, drawableDescriptor);
            }
        };

        SRCGeometryDescriptor.prototype.setForm = function (form) {
            this._form = form;
        };

        SRCGeometryDescriptor.prototype.prepare = function (bindingManager) {
            if (this._state == 0 /* INIT */) {
                this._state = 1 /* REGISTERED */;
                this._srcLoader.loadSRC(this._url, this);
            }
            if (this._state == 2 /* LOADED */) {
                if (this._srcLoader.uploadAllowed(this._src)) {
                    this._processSRC();
                }
            }
            if (this._hasGeometry) {
                return _super.prototype.prepare.call(this, bindingManager);
            }
            return false;
        };

        SRCGeometryDescriptor.prototype.notify = function (src) {
            if (src == null) {
                this._state = 4 /* FAILED */;

                if (this._form) {
                    this._form.setAppearanceDescriptor(util.ProxyShapes.getFailedAppearance());
                    util.BasicShapes.AddBoxLinesToDescriptor(this._form.getGeometryDescriptor(), false);
                }
                this._srcLoader.notifyAppChanged();
                return;
            }
            this._src = src;
            if (this._state == 1 /* REGISTERED */) {
                this._state = 2 /* LOADED */;
                if (this._srcLoader.uploadAllowed(src)) {
                    this._processSRC();
                } else if (this._form != null) {
                    this._form.setAppearanceDescriptor(util.ProxyShapes.getLoadedAppearance());
                    this._srcLoader.notifyAppChanged();
                }
            }
        };
        return SRCGeometryDescriptor;
    })(pre.GeometryDescriptor);
    pre.SRCGeometryDescriptor = SRCGeometryDescriptor;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var Application = (function () {
        function Application(canvasView, debug) {
            if (typeof debug === &quot;undefined&quot;) { debug = false; }
            this._context = null;
            this._canvasViews = [];
            this._stages = [];
            this._renderer = null;
            this._defaultRenderTarget = null;
            this._renderTreeRoot = null;
            this._picker = null;
            this._frameObservers = [];
            this._onEnterFrame = null;
            this._onExitFrame = null;
            this._animations = [];
            this._statsViewerEnabled = false;
            this._stats = null;
            this._screenShotUtility = new util.ScreenShotUtility();
            this._context = new pre.Context(this);
            this._settings = new pre.Settings();

            var canvasRenderTarget = canvasView.getHTMLCanvasRenderTarget();
            this._defaultRenderTarget = canvasRenderTarget;

            var context = this._createContext(canvasRenderTarget, debug);

            this._renderer = new renderer.WebGLRendererBase(this, context);

            this._canvasViews.push(canvasView);

            this._pipelineControl = new pre.PipelineControl();
            this._picker = new util.Picker(this);

            this._stats = util.Statistics.getInstance();
        }
        Application.prototype.fitView = function (volume, transitionTime, camera) {
            if (typeof transitionTime === &quot;undefined&quot;) { transitionTime = 1000; }
            if (typeof camera === &quot;undefined&quot;) { camera = this._context.getCamera(); }
            var startMat = camera.getViewMatrixResource().getData();

            var endMat = mat4.create();
            camera.computeFitMatrixForVolume(endMat, volume, camera.getViewDir(), camera.getUpVec());

            this.animateViewMatrix(startMat, endMat, transitionTime, camera);
        };

        Application.prototype.fitViewAligned = function (volume, viewDir, upVec, transitionTime, camera) {
            if (typeof transitionTime === &quot;undefined&quot;) { transitionTime = 1000; }
            if (typeof camera === &quot;undefined&quot;) { camera = this._context.getCamera(); }
            var startMat = camera.getViewMatrixResource().getData();

            var endMat = mat4.create();
            camera.computeFitMatrixForVolume(endMat, volume, viewDir, upVec);

            this.animateViewMatrix(startMat, endMat, transitionTime, camera);
        };

        Application.prototype.switchToViewpoint = function (eye, viewDir, upVec, transitionTime, camera) {
            if (typeof transitionTime === &quot;undefined&quot;) { transitionTime = 1000; }
            if (typeof camera === &quot;undefined&quot;) { camera = this._context.getCamera(); }
            var startMat = camera.getViewMatrixResource().getData();

            var center = vec3.clone(eye);
            vec3.add(center, center, viewDir);

            var endMat = mat4.create();
            mat4.lookAt(endMat, eye, center, upVec);

            this.animateViewMatrix(startMat, endMat, transitionTime, camera);
        };

        Application.prototype.animateViewMatrix = function (startViewMat, endViewMat, transitionTime, camera) {
            if (typeof transitionTime === &quot;undefined&quot;) { transitionTime = 1000; }
            if (typeof camera === &quot;undefined&quot;) { camera = this._context.getCamera(); }
            if (transitionTime == 0 || util.mat4Ext.isEqual(startViewMat, endViewMat)) {
                mat4.copy(camera.getViewMatrixResource().getData(), endViewMat);
                camera.getViewMatrixResource().setDirty();

                this._pipelineControl.setFlag(5 /* VIEW_CHANGED */);

                return;
            }

            var animation = new pre.TransformMatrixAnimation(startViewMat, endViewMat, camera.getViewMatrixResource(), transitionTime);

            this._animations.push(animation);
            animation.start();
        };

        Application.prototype.setIdentifier = function (identifier) {
            this._identifier = identifier;
        };

        Application.prototype.getIdentifier = function () {
            return this._identifier;
        };

        Application.prototype.getContext = function () {
            return this._context;
        };

        Application.prototype.getCanvasViews = function () {
            return this._canvasViews;
        };

        Application.prototype.getPipelineControl = function () {
            return this._pipelineControl;
        };

        Application.prototype.getPicker = function () {
            return this._picker;
        };

        Application.prototype.getSettings = function () {
            return this._settings;
        };

        Application.prototype.setDefaultRenderTarget = function (defaultRenderTarget) {
            this._defaultRenderTarget = defaultRenderTarget;
        };

        Application.prototype.getDebugRenderPass = function () {
            return this._debugRenderPass;
        };

        Application.prototype.setRenderTreeRoot = function (root) {
            this._renderTreeRoot = root;
        };

        Application.prototype.getRenderTreeRoot = function () {
            return this._renderTreeRoot;
        };

        Application.prototype.addStage = function (stage) {
            this._stages.push(stage);
        };

        Application.prototype.registerFrameObserver = function (frameObs) {
            this._frameObservers.push(frameObs);
        };

        Application.prototype.setNavigationController = function (navigationController) {
            this.addPointerObserver(navigationController);
            this.addTouchObserver(navigationController);

            navigationController.setPicker(this._picker);
            navigationController.addNavigationStateListener(this._pipelineControl);
            navigationController.setCamera(this._context.getCamera());
        };

        Application.prototype.addKeyObserver = function (keyObserver) {
            for (var i = 0, n = this._canvasViews.length; i &lt; n; ++i) {
                this._canvasViews[i].addKeyObserver(keyObserver);
            }
        };

        Application.prototype.addPointerObserver = function (pointerObserver) {
            for (var i = 0, n = this._canvasViews.length; i &lt; n; ++i) {
                this._canvasViews[i].addPointerObserver(pointerObserver);
            }
        };

        Application.prototype.addTouchObserver = function (touchObserver) {
            for (var i = 0, n = this._canvasViews.length; i &lt; n; ++i) {
                this._canvasViews[i].addTouchObserver(touchObserver);
            }
        };

        Application.prototype.runPipeline = function () {
            this._stats.reset(this._settings.frameId);
            this._stats.startMeasurement(&quot;FRAMETIME&quot;);

            this._pipelineControl.newFrame(++this._settings.frameId);

            util.SRCLoader.downloadBytesThisFrame = 0;

            if (this._debugRenderPass == null) {
                this._createDebugRenderPass();
            }

            this._refreshCanvasView();

            this._processAnimations();

            var worldVolume = this._renderTreeRoot ? this._renderTreeRoot.requestWorldVolume() : null;
            if (worldVolume &amp;&amp; worldVolume.isValid()) {
                this._context.getCamera().updateSceneVolume(worldVolume);
            }

            this._context.setRenderTarget(this._screenShotUtility.isTakingScreenshot() ? this._screenShotUtility.getScreenshotRenderTarget(this._defaultRenderTarget.getWidth(), this._defaultRenderTarget.getHeight()) : this._defaultRenderTarget);

            if (this._screenShotUtility.isTakingScreenshot()) {
                this._pipelineControl.setFlag(7 /* SCREENSHOT */);
            }

            if (this._onEnterFrame) {
                this._onEnterFrame();
            }

            var i = 0, n = this._stages.length;

            var runNextStage = true;
            while (i &lt; n &amp;&amp; runNextStage) {
                runNextStage = this._runNextStage(i++);
            }

            if (this._onExitFrame) {
                this._onExitFrame();
            }

            for (var i = 0, n = this._frameObservers.length; i &lt; n; i++) {
                this._frameObservers[i].onFrame(this._settings.frameId);
            }

            if (this._screenShotUtility.isTakingScreenshot()) {
                this._screenShotUtility.finishScreenshot(this._renderer);
                this._context.setRenderTarget(this._defaultRenderTarget);
            }

            this._stats.stopMeasurement(&quot;FRAMETIME&quot;);
            this._stats.addValue(&quot;GPUMEM(MB)&quot;, Math.round(100 * this._debugRenderPass.getRenderer().getMemoryManager().getAllocatedGPUMemorySize() / 1024 / 1024) / 100, &quot;MEMORY&quot;);
            this._stats.addValue(&quot;pipelineHint&quot;, this._pipelineControl.isNavigating() ? 1 : 0, &quot;Pipeline&quot;);
            this._stats.addValue(&quot;Act. downloads&quot;, util.DownloadService.getInstance().getActiveDownloadCount(), &quot;Connection&quot;);
            this._stats.addValue(&quot;Tot. downloads&quot;, util.DownloadService.getInstance().getTotalRequestCount(), &quot;Connection&quot;);

            if (!this._statsViewer) {
                this._statsViewer = new pre.StatsViewer();
                this._statsViewer.attachTo(this._canvasViews[0].getCanvasElement().parentElement);
            }

            if (this._statsViewerEnabled) {
                this._statsViewer.update(this._stats);
            }
        };

        Application.prototype.getScreenShotUtility = function () {
            return this._screenShotUtility;
        };

        Application.prototype.startMainLoop = function (func) {
            var that = this;

            if (func) {
                func();
            }

            that.runPipeline();

            window[&quot;requestAnimFrame&quot;](function () {
                that.startMainLoop(func);
            });
        };

        Application.prototype.toggleStatsViewer = function () {
            this._statsViewerEnabled = !this._statsViewerEnabled;
            this._statsViewer.setVisible(this._statsViewerEnabled);
        };

        Application.prototype.getDefaultRenderer = function () {
            return this._renderer;
        };

        Application.prototype.getStages = function (type) {
            var stageArray = [];

            var i = 0, n = this._stages.length;
            for (; i &lt; n; ++i) {
                if ((this._stages[i]) instanceof type) {
                    stageArray.push(this._stages[i]);
                }
            }

            return stageArray;
        };

        Application.prototype._refreshCanvasView = function () {
            if (this._canvasViews[0].refreshCanvasSize()) {
                this._pipelineControl.setFlag(0 /* FULL */);
                this._context.getCamera().setAspectRatio(this._canvasViews[0].getAspectRatio());
            }
        };

        Application.prototype._createDebugRenderPass = function () {
            this._debugRenderPass = new pre.BoxVolumeRenderPass(this);
            this._debugRenderPass.setDebugPass(true);
            this._debugRenderPass.setRenderer(this._renderer);

            var collectorStages = this.getStages(pre.DrawableCollector);
            var i = 0, n = collectorStages.length;

            for (; i &lt; n; i++) {
                pre.PipelineStage.connect(collectorStages[i], &quot;drawables&quot;, this._debugRenderPass, &quot;drawables&quot;);
            }
        };

        Application.prototype._processAnimations = function () {
            var i;
            for (i = 0; i &lt; this._animations.length; ++i) {
                this._animations[i].process();

                this._pipelineControl.setFlag(5 /* VIEW_CHANGED */);

                if (this._animations[i].isFinished()) {
                    this._animations.splice(i, 1);
                    --i;
                }
            }
        };

        Application.prototype._runNextStage = function (i) {
            this._stages[i].execute(this._context);

            return true;
        };

        Application.prototype._createContext = function (canvasRenderTarget, debug) {
            var webglRenderingContext = canvasRenderTarget.getRenderingContext([&quot;webgl2&quot;, &quot;experimental-webgl2&quot;, &quot;webgl&quot;, &quot;experimental-webgl&quot;]);

            if (debug) {
                var throwOnGLError = function (err, funcName, args) {
                    throw WebGLDebugUtils.glEnumToString(err) + &quot; was caused by call to: &quot; + funcName;
                };

                var logGLCalls = function (functionName, args) {
                     {
                        console.log(&quot;gl.&quot; + functionName + &quot;(&quot; + WebGLDebugUtils.glFunctionArgsToString(functionName, args) + &quot;)&quot;);
                    }
                };

                var validateNoneOfTheArgsAreUndefined = function (functionName, args) {
                    for (var ii = 0; ii &lt; args.length; ++ii) {
                        if (args[ii] === undefined) {
                            console.error(&quot;undefined passed to gl.&quot; + functionName + &quot;(&quot; + WebGLDebugUtils.glFunctionArgsToString(functionName, args) + &quot;)&quot;);
                        }
                    }
                };

                var logAndValidate = function (functionName, args) {
                    logGLCalls(functionName, args);
                    validateNoneOfTheArgsAreUndefined(functionName, args);
                };

                webglRenderingContext = WebGLDebugUtils.makeDebugContext(webglRenderingContext, throwOnGLError, logAndValidate);
            }
            return webglRenderingContext;
        };
        return Application;
    })();
    pre.Application = Application;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var CanvasView = (function () {
        function CanvasView(canvasElement) {
            if (typeof canvasElement === &quot;undefined&quot;) { canvasElement = document.createElement(&quot;canvas&quot;); }
            this._canvasElement = null;
            this._renderTarget = null;
            this._oldWidth = 0;
            this._oldHeight = 0;
            this._pointerObservers = [];
            this._keyObservers = [];
            this._touchObservers = [];
            this._pressedButton = 0 /* NONE */;
            this._pointerDownX = -1;
            this._pointerDownY = -1;
            this._lastClickX = -1;
            this._lastClickY = -1;
            this._doubleClickDelta = 10;
            this._doubleClickWindow = 500;
            this._lastClickTime = -1;
            var that = this;

            this._canvasElement = canvasElement;

            this._renderTarget = new pre.HTMLCanvasRenderTarget(this._canvasElement);

            this._canvasElement.addEventListener(&quot;pointerdown&quot;, function () {
            });

            this._canvasElement.addEventListener(&quot;mousemove&quot;, function (event) {
                that._mouseMoved(event);
                event.preventDefault();
            });

            this._canvasElement.addEventListener(&quot;mousedown&quot;, function (event) {
                if (document.activeElement) {
                    document.activeElement.blur();
                }
                that._canvasElement.focus();
                that._pointerDownX = event.clientX;
                that._pointerDownY = event.clientY;
                that._mousePressed(event);
                event.preventDefault();
            });

            document.addEventListener(&quot;mouseup&quot;, function (event) {
                if (that._pressedButton != 0 /* NONE */) {
                    that._mouseReleased(event);
                    if (event.clientX == that._pointerDownX &amp;&amp; event.clientY == that._pointerDownY) {
                        that._mouseClicked(event);
                        var time = new Date().getTime();
                        if (Math.abs(event.clientX - that._lastClickX) &lt; that._doubleClickDelta &amp;&amp; Math.abs(event.clientY - that._lastClickY) &lt; that._doubleClickDelta &amp;&amp; (time - that._lastClickTime) &lt; that._doubleClickWindow) {
                            that._mouseDoubleClicked(event);
                        }
                        that._lastClickX = event.clientX;
                        that._lastClickY = event.clientY;
                        that._lastClickTime = time;
                    }
                    event.preventDefault();
                }
            });

            this._canvasElement.addEventListener(&quot;mousewheel&quot;, function (event) {
                var overflowState = document.body.style.overflow;
                document.body.style.overflow = &quot;hidden&quot;;
                that._mouseScrolled(event);
                event.preventDefault();
                document.body.style.overflow = overflowState;
            });

            this._canvasElement.addEventListener(&quot;DOMMouseScroll&quot;, function (event) {
                var overflowState = document.body.style.overflow;
                document.body.style.overflow = &quot;hidden&quot;;
                that._mouseScrolled(event);
                event.preventDefault();
                document.body.style.overflow = overflowState;
            });

            this._canvasElement.addEventListener(&quot;mouseover&quot;, function (event) {
                that._mouseEntered(event);
                event.preventDefault();
            });

            this._canvasElement.addEventListener(&quot;mouseout&quot;, function (event) {
                that._mouseOut(event);
                event.preventDefault();
            });

            this._canvasElement.addEventListener(&quot;touchstart&quot;, function (event) {
                if (document.activeElement) {
                    document.activeElement.blur();
                }
                that._canvasElement.focus();

                that._pointerDownX = event.changedTouches[0].clientX;
                that._pointerDownY = event.changedTouches[0].clientY;

                that._touchStarted(event);
                event.preventDefault();
            });

            this._canvasElement.addEventListener(&quot;touchend&quot;, function (event) {
                var tolerance = 4;

                var tX = event.changedTouches[0].clientX;
                var tY = event.changedTouches[0].clientY;

                if (Math.abs(tX - that._pointerDownX) &lt; tolerance &amp;&amp; Math.abs(tY - that._pointerDownY) &lt; tolerance) {
                    that._touchPicked(event);

                    var time = new Date().getTime();
                    if (Math.abs(tX - that._lastClickX) &lt; that._doubleClickDelta &amp;&amp; Math.abs(tY - that._lastClickY) &lt; that._doubleClickDelta &amp;&amp; (time - that._lastClickTime) &lt; that._doubleClickWindow) {
                        that._touchDoublePicked(event);
                    }

                    that._lastClickX = tX;
                    that._lastClickY = tY;
                    that._lastClickTime = time;
                }

                event.preventDefault();
                that._touchEnded(event);
                event.preventDefault();
            });

            this._canvasElement.addEventListener(&quot;touchmove&quot;, function (event) {
                that._touchMoved(event);
                event.preventDefault();
            });

            document.addEventListener(&quot;keyup&quot;, function (event) {
                that._keyDown(event);
            });

            var preventDefaultFunc = function (event) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            };

            this._canvasElement.addEventListener(&quot;contextmenu&quot;, preventDefaultFunc);
        }
        CanvasView.prototype.getCanvasElement = function () {
            return this._canvasElement;
        };

        CanvasView.prototype.addPointerObserver = function (observer) {
            this._pointerObservers.push(observer);
        };

        CanvasView.prototype.addKeyObserver = function (observer) {
            this._keyObservers.push(observer);
        };

        CanvasView.prototype.addTouchObserver = function (observer) {
            this._touchObservers.push(observer);
        };

        CanvasView.prototype.removeKeyObserver = function (observer) {
            var idx = this._keyObservers.indexOf(observer);

            if (idx != -1) {
                this._keyObservers.splice(idx, 1);
            } else {
                util.Log.postWarning(&quot;Unable to remove key observer from canvas: given key observer not found.&quot;);
            }
        };

        CanvasView.prototype.removePointerObserver = function (observer) {
            var idx = this._pointerObservers.indexOf(observer);

            if (idx != -1) {
                this._pointerObservers.splice(idx, 1);
            } else {
                util.Log.postWarning(&quot;Unable to remove pointer observer from canvas: given pointer observer not found.&quot;);
            }
        };

        CanvasView.prototype.removeTouchObserver = function (observer) {
            var idx = this._touchObservers.indexOf(observer);

            if (idx != -1) {
                this._touchObservers.splice(idx, 1);
            } else {
                util.Log.postWarning(&quot;Unable to remove touch observer from canvas: given touch observer not found.&quot;);
            }
        };

        CanvasView.prototype.updateCanvasElement = function (parentElement) {
            if (!this._canvasElement.parentNode) {
                parentElement.appendChild(this._canvasElement);
            }

            this._canvasElement.width = parentElement.clientWidth;
            this._canvasElement.height = parentElement.clientHeight;
        };

        CanvasView.prototype.getAspectRatio = function () {
            var ratio = this._canvasElement.width / this._canvasElement.height;

            if (!isFinite(ratio)) {
                util.Log.postWarning(&quot;Cannot determine canvas aspect ratio - using default ratio of 1:1.&quot;);
                ratio = 1.0;
            }

            return ratio;
        };

        CanvasView._ButtonIndexToEnum = function (buttonIdx) {
            switch (buttonIdx) {
                default:
                case 0:
                    return 0 /* NONE */;
                    break;
                case 1:
                    return 1 /* FIRST */;
                    break;
                case 2:
                    return 2 /* SECOND */;
                    break;
                case 3:
                    return 3 /* THIRD */;
                    break;
            }
        };

        CanvasView.prototype._mouseClicked = function (event) {
            this._canvasElement.focus();

            this._pressedButton = CanvasView._ButtonIndexToEnum(whichButton(event));
            var i;
            for (i = 0; i &lt; this._pointerObservers.length; ++i) {
                if (this._pointerObservers[i].pointerActionTriggered) {
                    this._pointerObservers[i].pointerActionTriggered((event.offsetX || event.layerX), (event.offsetY || event.layerY), (event.offsetX || event.layerX) / (this._canvasElement.width - 1), (event.offsetY || event.layerY) / (this._canvasElement.height - 1), this._pressedButton, 0 /* CLICKED */, event.timeStamp);
                }
            }
            this._pressedButton = 0 /* NONE */;
        };

        CanvasView.prototype._touchPicked = function (event) {
            this._canvasElement.focus();

            this._pressedButton = 4 /* TOUCH */;
            var i;
            var tX = event.changedTouches[0].clientX;
            var tY = event.changedTouches[0].clientY;

            var pX = event.changedTouches[0].target.getBoundingClientRect().left;
            var pY = event.changedTouches[0].target.getBoundingClientRect().top;

            tX -= pX;
            tY -= pY;

            for (i = 0; i &lt; this._pointerObservers.length; ++i) {
                if (this._pointerObservers[i].pointerActionTriggered) {
                    this._pointerObservers[i].pointerActionTriggered(tX, tY, tX / (this._canvasElement.width - 1), tY / (this._canvasElement.height - 1), this._pressedButton, 4 /* TOUCH_PICKED */, event.timeStamp);
                }
            }
            this._pressedButton = 0 /* NONE */;
        };

        CanvasView.prototype._mouseDoubleClicked = function (event) {
            this._canvasElement.focus();

            this._pressedButton = CanvasView._ButtonIndexToEnum(whichButton(event));
            var i;
            for (i = 0; i &lt; this._pointerObservers.length; ++i) {
                if (this._pointerObservers[i].pointerActionTriggered) {
                    this._pointerObservers[i].pointerActionTriggered((event.offsetX || event.layerX), (event.offsetY || event.layerY), (event.offsetX || event.layerX) / (this._canvasElement.width - 1), (event.offsetY || event.layerY) / (this._canvasElement.height - 1), this._pressedButton, 3 /* DOUBLECLICKED */, event.timeStamp);
                }
            }
            this._pressedButton = 0 /* NONE */;
        };

        CanvasView.prototype._touchDoublePicked = function (event) {
            this._canvasElement.focus();

            this._pressedButton = 4 /* TOUCH */;
            var i;

            var tX = event.changedTouches[0].clientX;
            var tY = event.changedTouches[0].clientY;

            var pX = event.changedTouches[0].target.getBoundingClientRect().left;
            var pY = event.changedTouches[0].target.getBoundingClientRect().top;

            tX -= pX;
            tY -= pY;

            for (i = 0; i &lt; this._pointerObservers.length; ++i) {
                if (this._pointerObservers[i].pointerActionTriggered) {
                    this._pointerObservers[i].pointerActionTriggered(tX, tY, tX / (this._canvasElement.width - 1), tY / (this._canvasElement.height - 1), this._pressedButton, 5 /* TOUCH_DOUBLE_PICKED */, event.timeStamp);
                }
            }
            this._pressedButton = 0 /* NONE */;
        };

        CanvasView.prototype._mousePressed = function (event) {
            this._canvasElement.focus();

            this._pressedButton = CanvasView._ButtonIndexToEnum(whichButton(event));
            var i;
            for (i = 0; i &lt; this._pointerObservers.length; ++i) {
                if (this._pointerObservers[i].pointerActionTriggered) {
                    this._pointerObservers[i].pointerActionTriggered((event.offsetX || event.layerX), (event.offsetY || event.layerY), (event.offsetX || event.layerX) / (this._canvasElement.width - 1), (event.offsetY || event.layerY) / (this._canvasElement.height - 1), this._pressedButton, 1 /* PRESSED */, event.timeStamp);
                }
            }
        };

        CanvasView.prototype._mouseReleased = function (event) {
            var i;
            for (i = 0; i &lt; this._pointerObservers.length; ++i) {
                if (this._pointerObservers[i].pointerActionTriggered) {
                    this._pointerObservers[i].pointerActionTriggered((event.offsetX || event.layerX), (event.offsetY || event.layerY), (event.offsetX || event.layerX) / (this._canvasElement.width - 1), (event.offsetY || event.layerY) / (this._canvasElement.height - 1), this._pressedButton, 2 /* RELEASED */, event.timeStamp);
                }
            }

            this._pressedButton = 0 /* NONE */;
        };

        CanvasView.prototype._mouseScrolled = function (event) {
            var i;
            for (i = 0; i &lt; this._pointerObservers.length; ++i) {
                if (this._pointerObservers[i].wheelScrolled) {
                    this._pointerObservers[i].wheelScrolled((event.offsetX || event.layerX), (event.offsetY || event.layerY), (event.offsetX || event.layerX) / (this._canvasElement.width - 1), (event.offsetY || event.layerY) / (this._canvasElement.height - 1), Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail))), event.timeStamp);
                }
            }
        };

        CanvasView.prototype._mouseEntered = function (event) {
        };

        CanvasView.prototype._mouseOut = function (event) {
        };

        CanvasView.prototype._mouseMoved = function (event) {
            var i;
            for (i = 0; i &lt; this._pointerObservers.length; ++i) {
                if (this._pointerObservers[i].pointerMotion) {
                    this._pointerObservers[i].pointerMotion((event.offsetX || event.layerX), (event.offsetY || event.layerY), (event.offsetX || event.layerX) / (this._canvasElement.width - 1), (event.offsetY || event.layerY) / (this._canvasElement.height - 1), this._pressedButton, event.timeStamp);
                }
            }
        };

        CanvasView.prototype._wrapTouches = function (event, globalTouches, localTouches, changedTouches) {
            var that = this;

            function wrap(htmlTouch) {
                var tX = htmlTouch.clientX;
                var tY = htmlTouch.clientY;

                var pX = htmlTouch.target.getBoundingClientRect().left;
                var pY = htmlTouch.target.getBoundingClientRect().top;

                tX -= pX;
                tY -= pY;

                var tInfo = new util.TouchInfo(htmlTouch.identifier);
                tInfo.domTarget = htmlTouch.target;
                tInfo.localX = tX;
                tInfo.localY = tY;

                tInfo.normalizedLocalX = tX / (that._canvasElement.width - 1);
                tInfo.normalizedLocalY = tY / (that._canvasElement.height - 1);
                tInfo.globalX = htmlTouch.screenX;
                tInfo.globalY = htmlTouch.screenY;
                return tInfo;
            }

            var i;

            for (i = 0; i &lt; event.touches.length; ++i) {
                globalTouches.push(wrap(event.touches[i]));
            }
            for (i = 0; i &lt; event.targetTouches.length; ++i) {
                localTouches.push(wrap(event.targetTouches[i]));
            }
            for (i = 0; i &lt; event.changedTouches.length; ++i) {
                changedTouches.push(wrap(event.changedTouches[i]));
            }
        };

        CanvasView.prototype._touchStarted = function (event) {
            var globalTouches = [];
            var localTouches = [];
            var changedTouches = [];

            this._wrapTouches(event, globalTouches, localTouches, changedTouches);

            var i;
            for (i = 0; i &lt; this._touchObservers.length; ++i) {
                this._touchObservers[i].touchStarted(globalTouches, localTouches, changedTouches);
            }

            this._pressedButton = 4 /* TOUCH */;
        };

        CanvasView.prototype._touchEnded = function (event) {
            var globalTouches = [];
            var localTouches = [];
            var changedTouches = [];

            this._wrapTouches(event, globalTouches, localTouches, changedTouches);

            var i;
            for (i = 0; i &lt; this._touchObservers.length; ++i) {
                this._touchObservers[i].touchEnded(globalTouches, localTouches, changedTouches);
            }
        };

        CanvasView.prototype._touchMoved = function (event) {
            var globalTouches = [];
            var localTouches = [];
            var changedTouches = [];

            this._wrapTouches(event, globalTouches, localTouches, changedTouches);

            var i;
            for (i = 0; i &lt; this._touchObservers.length; ++i) {
                this._touchObservers[i].touchMotion(globalTouches, localTouches, changedTouches);
            }
        };

        CanvasView.prototype._keyDown = function (event) {
            var i;
            for (i = 0; i &lt; this._keyObservers.length; ++i) {
                if (this._keyObservers[i].keyPress) {
                    this._keyObservers[i].keyPress(event.keyCode, event.timeStamp);
                }
            }
        };

        CanvasView.prototype.getHTMLCanvasRenderTarget = function () {
            return this._renderTarget;
        };

        CanvasView.prototype.refreshCanvasSize = function () {
            this._canvasElement.width = this._canvasElement.clientWidth;
            this._canvasElement.height = this._canvasElement.clientHeight;

            if (this._oldWidth != this._canvasElement.width || this._oldHeight != this._canvasElement.height) {
                this._oldWidth = this._canvasElement.width;
                this._oldHeight = this._canvasElement.height;
                return true;
            }
            return false;
        };
        return CanvasView;
    })();
    pre.CanvasView = CanvasView;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var Context = (function () {
        function Context(application) {
            this._lights = [];
            this._lightsBufferCount = 8;
            this._lightsStride = 2;
            this._clipPlanes = [];
            this._camera = null;
            this._renderState = new pre.RenderState();
            this._application = null;
            this._partControl = null;
            this._renderTarget = null;
            var _NUM_CLIPPLANES = 8;

            this._application = application;
            this._partControl = new pre.PartControl(application);
            this._viewMatrixInv = mat4.create();
            this._viewMatrixInvRes = pre.Resource.Create(pre.ResourceType.mat4f, this._viewMatrixInv);

            this._lightsBuffer = pre.Resource.Create(pre.ResourceType.FLOAT_32, new Float32Array(this._lightsBufferCount * this._lightsStride * 4));
            this._lightsCount = pre.Resource.Create(pre.ResourceType.INT_32, new Int32Array([0]));

            this._clipPlaneDefinitions = pre.Resource.Create(pre.ResourceType.FLOAT_32, new Float32Array(4 * _NUM_CLIPPLANES));
            this._clipPlaneEnabledStates = pre.Resource.Create(pre.ResourceType.FLOAT_32, new Float32Array(_NUM_CLIPPLANES));
            this._clipPlaneCount = pre.Resource.Create(pre.ResourceType.INT_32, new Int32Array([0]));
        }
        Context.prototype.getApplication = function () {
            return this._application;
        };

        Context.prototype.getRenderState = function () {
            return this._renderState;
        };

        Context.prototype.setRenderState = function (renderState) {
            this._renderState = renderState;
        };

        Context.prototype.setCamera = function (camera) {
            camera.addViewChangedListener(this._application.getPipelineControl());
            this._camera = camera;
        };

        Context.prototype.getCamera = function () {
            return this._camera;
        };

        Context.prototype.getLightsCount = function () {
            return this._lightsCount.getData()[0];
        };

        Context.prototype.addLight = function (light) {
            this._lights.push(light);
            var countData = this._lightsCount.getData();
            var count = countData[0];
            var pos = count * this._lightsStride * 4;
            if (count &gt;= this._lightsBufferCount) {
                util.Log.postError(&quot;allocate more buffer space for lights: NOT YET IMPLEMENTED!&quot;);
                return -1;
            }

            this.setLight(pos, light);
            this._lightsBuffer.setDirty();

            countData[0] = count + 1;
            this._lightsCount.setDirty();
            return count;
        };

        Context.prototype.setLight = function (pos, light) {
            var lightVec = light.getVector().getData();
            var lightCol = light.getColor().getData();
            var bufferData = this._lightsBuffer.getData();

            bufferData[pos + 0] = lightVec[0];
            bufferData[pos + 1] = lightVec[1];
            bufferData[pos + 2] = lightVec[2];

            bufferData[pos + 4] = lightCol[0];
            bufferData[pos + 5] = lightCol[1];
            bufferData[pos + 6] = lightCol[2];
            bufferData[pos + 7] = lightCol[3];

            bufferData[pos + 3] = light.getTypeFlag();
        };

        Context.prototype.enableLight = function (lightID, enable) {
            if (typeof enable === &quot;undefined&quot;) { enable = true; }
            if (enable) {
                var bufferData = this._lightsBuffer.getData();

                if (bufferData[lightID * this._lightsStride * 4 + 3] &lt; 0) {
                    bufferData[lightID * this._lightsStride * 4 + 3] = -bufferData[lightID * this._lightsStride + 3];
                }
            } else {
                this.disableLight(lightID);
            }
        };

        Context.prototype.disableLight = function (lightID) {
            var bufferData = this._lightsBuffer.getData();

            if (bufferData[lightID * this._lightsStride * 4 + 3] &gt; 0) {
                bufferData[lightID * this._lightsStride * 4 + 3] = -bufferData[lightID * this._lightsStride + 3];
            }
        };

        Context.prototype.updateLightsBuffer = function () {
            var updated = false;
            for (var i = 0; i &lt; this._lightsCount.getData()[0]; i++) {
                var light = this._lights[i];
                if (light.getVector().isDirty() || light.getVector().isDirty()) {
                    this.setLight(i * this._lightsStride * 4, light);
                    updated = true;
                }
            }
            if (updated) {
                this._lightsBuffer.setDirty();
            }
            return updated;
        };

        Context.prototype.createClipPlane = function (normal, position) {
            var clipPlane;

            var clipPlanePos, n;
            for (clipPlanePos = 0, n = this._clipPlanes.length; clipPlanePos &lt; n &amp;&amp; this._clipPlanes[clipPlanePos].isEnabled(); clipPlanePos++) {
            }

            if (clipPlanePos == n) {
                clipPlanePos = this._clipPlaneCount.getData()[0]++;

                var bufferOffset = clipPlanePos * 4;

                var definitionView = this._clipPlaneDefinitions.getData().subarray(bufferOffset, bufferOffset + 4);
                var enabledView = this._clipPlaneEnabledStates.getData().subarray(clipPlanePos, clipPlanePos + 1);

                clipPlane = new pre.Plane(definitionView, enabledView);

                this._clipPlanes.push(clipPlane);
            } else {
                clipPlane = this._clipPlanes[clipPlanePos];
            }

            clipPlane.setValues(new Float32Array(normal), new Float32Array(position));
            clipPlane.setEnabled(true);

            this._clipPlaneDefinitions.setDirty();
            this._clipPlaneEnabledStates.setDirty();

            this._camera.getFrustum().addPlane(clipPlane);
            this._application.getPipelineControl().setFlag(3 /* GEOMETRY_CHANGED */);
            return clipPlanePos;
        };

        Context.prototype.removeClipPlane = function (index) {
            this._clipPlanes[index].setEnabled(false);

            this._clipPlaneEnabledStates.setDirty();
            this._application.getPipelineControl().setFlag(3 /* GEOMETRY_CHANGED */);
        };

        Context.prototype.modifyClipPlane = function (index, normal, point) {
            if (normal &amp;&amp; point) {
                this._clipPlanes[index].setValues(new Float32Array(normal), new Float32Array(point));
            } else {
                if (normal) {
                    this._clipPlanes[index].setNormal(new Float32Array(normal));
                }
                if (point) {
                    this._clipPlanes[index].setPoint(new Float32Array(point));
                }
            }
            this._clipPlaneDefinitions.setDirty();
            this._application.getPipelineControl().setFlag(3 /* GEOMETRY_CHANGED */);
        };

        Context.prototype.setupStates = function (renderState, stateManager) {
            var constants = stateManager.getConstants();

            stateManager.caps(constants.BLEND, renderState.blendEnabled);

            stateManager.caps(constants.CULL_FACE, renderState.cullFaceEnabled);

            stateManager.caps(constants.DEPTH_TEST, renderState.depthTestEnabled);

            stateManager.colorMask(renderState.colorMask);
            stateManager.depthMask(renderState.depthMask);

            stateManager.depthFunc(constants.LEQUAL);

            stateManager.clearColor(renderState.clearColor);
            stateManager.clearDepth(renderState.clearDepth);

            this.updateLightsBuffer();
        };

        Context.prototype.setupBindings = function (bindingManger) {
            var camera = this.getCamera();
            bindingManger.setGlobalShaderParam(&quot;vMatrix&quot;, camera.getViewMatrixResource());

            mat4.invert(this._viewMatrixInv, camera.getViewMatrixResource().getData());
            this._viewMatrixInvRes.setDirty();
            bindingManger.setGlobalShaderParam(&quot;vMatrixInv&quot;, this._viewMatrixInvRes);
            bindingManger.setGlobalShaderParam(&quot;pMatrix&quot;, camera.requestProjectionMatrix());

            bindingManger.setGlobalShaderParam(&quot;lights&quot;, this._lightsBuffer);

            bindingManger.setGlobalShaderParam(&quot;clipPlaneDefinitions&quot;, this._clipPlaneDefinitions);
            bindingManger.setGlobalShaderParam(&quot;clipPlaneEnabledStates&quot;, this._clipPlaneEnabledStates);

            bindingManger.setGlobalShaderParam(&quot;partsEnabledTexture&quot;, this._partControl.getPartsEnabledTexture());
            bindingManger.setGlobalShaderParam(&quot;partsColorTexture&quot;, this._partControl.getPartsColorTexture());
        };

        Context.prototype.clear = function (stateManager, renderTarget) {
            var frameId = this._application.getSettings().frameId;
            if (renderTarget.getLastClearFrameId() &lt; frameId) {
                var constants = stateManager.getConstants();
                stateManager.clear(constants.COLOR_BUFFER_BIT | constants.DEPTH_BUFFER_BIT);

                renderTarget.setClearFrameId(frameId);
                return true;
            }
            return false;
        };

        Context.prototype.getPartControl = function () {
            return this._partControl;
        };

        Context.prototype.finish = function (stateManager) {
            stateManager.finish();
        };

        Context.prototype.flush = function (stateManager) {
            stateManager.flush();
        };

        Context.prototype.setRenderTarget = function (renderTarget) {
            this._renderTarget = renderTarget;
        };

        Context.prototype.getRenderTarget = function () {
            return this._renderTarget;
        };
        return Context;
    })();
    pre.Context = Context;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var Environment = (function () {
        function Environment() {
            this._applications = {};
            this._renderer = {};
            this._targets = {};
            if (Environment._instance) {
                throw new Error(&quot;Instantiation failed: use Environment.getInstance() instead. &quot;);
            }
            this._objectCatalog = new pre.ObjectCatalog();
            this._shaderService = new pre.ShaderService();

            Environment._instance = this;
        }
        Environment.prototype._createGuid = function () {
            function _p8(s) {
                var p = (Math.random().toString(16) + &quot;000000000&quot;).substr(2, 8);
                return s ? &quot;-&quot; + p.substr(0, 4) + &quot;-&quot; + p.substr(4, 4) : p;
            }
            return _p8(false) + _p8(true) + _p8(true) + _p8(false);
        };

        Environment.getInstance = function () {
            if (Environment._instance === null) {
                Environment._instance = new Environment();
            }
            return Environment._instance;
        };

        Environment.prototype.requestNewApplication = function (canvas, camera, debug) {
            if (typeof camera === &quot;undefined&quot;) { camera = new pre.PerspectiveCamera(); }
            if (typeof debug === &quot;undefined&quot;) { debug = false; }
            var id = this._createGuid();
            while (this._applications[id] != null) {
                id = this._createGuid();
            }

            var canvasView = new pre.CanvasView(canvas);
            var application = new pre.Application(canvasView, debug);
            application.setIdentifier(id);
            this._applications[id] = application;

            if (!camera) {
                camera = new pre.PerspectiveCamera();
            }

            camera.setAspectRatio(canvasView.getAspectRatio());
            application.getContext().setCamera(camera);

            return application;
        };

        Environment.prototype.addRenderer = function (id, renderer) {
            this._renderer[id] = renderer;
        };

        Environment.prototype.addRenderTarget = function (identifier, renderTarget) {
            this._targets[identifier] = renderTarget;
        };

        Environment.prototype.getObjectCatalog = function () {
            return this._objectCatalog;
        };

        Environment.prototype.getShaderService = function () {
            return this._shaderService;
        };

        Environment.prototype.getApplication = function (id) {
            if (this._applications[id] !== undefined) {
                return this._applications[id];
            }
            return null;
        };

        Environment.prototype.getRenderer = function (id) {
            if (this._renderer[id] !== undefined) {
                return this._renderer[id];
            }
            return null;
        };

        Environment.prototype.getRenderTarget = function (identifier) {
            if (this._targets[identifier] !== undefined) {
                return this._targets[identifier];
            }
            return null;
        };
        Environment._instance = null;
        return Environment;
    })();
    pre.Environment = Environment;
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (RenderTargetUsage) {
        RenderTargetUsage[RenderTargetUsage[&quot;COLOR_TARGET0&quot;] = 0] = &quot;COLOR_TARGET0&quot;;
        RenderTargetUsage[RenderTargetUsage[&quot;DEPTH_TARGET&quot;] = 1] = &quot;DEPTH_TARGET&quot;;
    })(pre.RenderTargetUsage || (pre.RenderTargetUsage = {}));
    var RenderTargetUsage = pre.RenderTargetUsage;

    
})(pre || (pre = {}));
var pre;
(function (pre) {
    var ObjectCatalog = (function () {
        function ObjectCatalog() {
            this._resources = [];
            this._appearanceDescriptors = [];
            this._appearanceClasses = [];
            this._appearanceClassesMap = [];
            this._geometryDescriptors = [];
            this._drawables = {};
            this._labelToDrawables = {};
        }
        ObjectCatalog.prototype._getLabelToDrawables = function (identifier) {
            if (!this._labelToDrawables[identifier]) {
                this._labelToDrawables[identifier] = {};
            }
            return this._labelToDrawables[identifier];
        };

        ObjectCatalog.prototype._getDrawableArray = function (identifier) {
            if (!this._drawables[identifier]) {
                this._drawables[identifier] = [];
            }
            return this._drawables[identifier];
        };

        ObjectCatalog.prototype.registerDrawable = function (drawable, application) {
            var labels = drawable.getForm().getGeometryDescriptor().getLabels();
            var labelToDrawables = this._getLabelToDrawables(application.getIdentifier());

            var i, n;
            for (i = 0, n = labels.length; i &lt; n; i++) {
                var label = labels[i];
                if (labelToDrawables[label] == null) {
                    labelToDrawables[label] = [drawable];
                } else {
                    labelToDrawables[label].push(drawable);
                }
            }
            return this._getDrawableArray(application.getIdentifier()).push(drawable) - 1;
        };

        ObjectCatalog.prototype.getDrawable = function (drawableId, application) {
            return this._getDrawableArray(application.getIdentifier())[drawableId];
        };

        ObjectCatalog.prototype.getDrawables = function (application) {
            return this._getDrawableArray(application.getIdentifier());
        };

        ObjectCatalog.prototype.getDrawablesForLabel = function (label, application) {
            return this._getLabelToDrawables(application.getIdentifier())[label] || [];
        };

        ObjectCatalog.prototype.registerResource = function (resource) {
            this._resources.push(resource);
            return this._resources.length - 1;
        };

        ObjectCatalog.prototype.getResource = function (resourceId) {
            return this._resources[resourceId];
        };

        ObjectCatalog.prototype.removeResource = function (resourceId) {
            if (this._resources.length &lt;= resourceId)
                return false;

            delete this._resources[resourceId];
            this._resources[resourceId] = undefined;
            return true;
        };

        ObjectCatalog.prototype._checkForDuplicateAppearance = function (appDesc) {
            return -1;
            for (var i = 0; i &lt; this._appearanceClasses.length; i++) {
                var otherAppDesc = this._appearanceClasses[i];
                if (appDesc.equals(otherAppDesc)) {
                    return i;
                }
            }
            return -1;
        };

        ObjectCatalog.prototype.appearanceDescriptorChanged = function (appDesc) {
            var id = appDesc.getClassID();
            if (this._appearanceClassesMap[id].length &gt; 1) {
                if (this._appearanceClasses[id] === appDesc) {
                    this._appearanceClasses[id] == this._appearanceClassesMap[id][1];
                }

                var pos = this._appearanceClassesMap[id].indexOf(appDesc);
                this._appearanceClassesMap[id].splice(pos, 1);
                id = this.requestAppearanceDescriptorID(appDesc);
            }
            return id;
        };

        ObjectCatalog.prototype.requestAppearanceDescriptorID = function (appearanceDescriptor) {
            var id = this._appearanceDescriptors.indexOf(appearanceDescriptor);
            if (id &lt; 0) {
                id = this._appearanceDescriptors.push(appearanceDescriptor) - 1;
            }
            return id;
        };

        ObjectCatalog.prototype.requestAppearanceClassID = function (appearanceDescriptor) {
            var id = this._appearanceClasses.indexOf(appearanceDescriptor);
            if (id &lt; 0) {
                id = this._checkForDuplicateAppearance(appearanceDescriptor);

                if (id &gt;= 0) {
                    if (this._appearanceClassesMap[id].indexOf(appearanceDescriptor) &lt;= 0) {
                        this._appearanceClassesMap[id].push(appearanceDescriptor);
                    }
                } else {
                    id = this._appearanceClasses.length;
                    this._appearanceClasses.push(appearanceDescriptor);
                    this._appearanceClassesMap.push([appearanceDescriptor]);
                }
            }
            return id;
        };

        ObjectCatalog.prototype.getAppearanceDescriptor = function (appearanceDescriptorID) {
            if (!this._appearanceClasses[appearanceDescriptorID]) {
                util.Log.postError(&quot;Appearance for DescriptorID not found : &quot; + appearanceDescriptorID);
                return null;
            }
            return this._appearanceClasses[appearanceDescriptorID];
        };

        ObjectCatalog.prototype.requestGeometryDescriptorID = function (geometrydescriptor) {
            var id = this._geometryDescriptors.indexOf(geometrydescriptor);
            if (id &lt; 0) {
                id = this._geometryDescriptors.length;
                this._geometryDescriptors.push(geometrydescriptor);
            }
            return id;
        };

        ObjectCatalog.prototype.getGeometryDescriptor = function (geometryDescriptorID) {
            return this._geometryDescriptors[geometryDescriptorID];
        };
        return ObjectCatalog;
    })();
    pre.ObjectCatalog = ObjectCatalog;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var PartControl = (function () {
        function PartControl(application) {
            this._partsEnabledTexture = null;
            this._partsEnabledBuffer = null;
            this._partsColorTexture = null;
            this._partsColorBuffer = null;
            this._partsVolumes = {};
            this._currentBufferLength = 0;
            this._application = null;
            this._objectCatalog = null;
            this._labelEnabled = {};
            this._application = application;
            this._objectCatalog = pre.Environment.getInstance().getObjectCatalog();

            this._partsEnabledBuffer = new Uint8Array(1024 * 1024);
            this._partsEnabledTexture = pre.TextureResource.Create(pre.ResourceType.sampler2D, this._partsEnabledBuffer);
            this._partsEnabledTexture.setHeight(1024);
            this._partsEnabledTexture.setWidth(1024);
            this._partsEnabledTexture.setWrapS(pre.WrapType.CLAMP_TO_EDGE);
            this._partsEnabledTexture.setWrapT(pre.WrapType.CLAMP_TO_EDGE);
            this._partsEnabledTexture.setMinFilter(pre.FilterType.NEAREST);
            this._partsEnabledTexture.setMagFilter(pre.FilterType.NEAREST);
            this._partsEnabledTexture.setInternalFormat(pre.FormatType.LUMINANCE);
            this._partsEnabledTexture.setFormat(pre.FormatType.LUMINANCE);

            this._partsColorBuffer = new Uint8Array(4 * 1024 * 1024);
            this._partsColorTexture = pre.TextureResource.Create(pre.ResourceType.sampler2D, this._partsColorBuffer);
            this._partsColorTexture.setHeight(1024);
            this._partsColorTexture.setWidth(1024);
            this._partsColorTexture.setWrapS(pre.WrapType.CLAMP_TO_EDGE);
            this._partsColorTexture.setWrapT(pre.WrapType.CLAMP_TO_EDGE);
            this._partsColorTexture.setMinFilter(pre.FilterType.NEAREST);
            this._partsColorTexture.setMagFilter(pre.FilterType.NEAREST);
            this._partsColorTexture.setInternalFormat(pre.FormatType.RGBA);
            this._partsColorTexture.setFormat(pre.FormatType.RGBA);
        }
        PartControl.prototype.setDrawablePartEnabledState = function (drawable, partID, enabled) {
            if (typeof enabled === &quot;undefined&quot;) { enabled = true; }
            var offset = drawable.getDrawableDescriptor().getSubMeshIDOffset();
            if (offset &lt; 0) {
                util.Log.postError(&quot;trying to enable/disable an unregistered drawable&quot;);
            }
            var pos = partID + offset;
            if (enabled) {
                if (this._partsEnabledBuffer[pos] != 255) {
                    this._partsEnabledBuffer[pos] = 255;
                    this._partsEnabledTexture.setDirty();
                    this._application.getPipelineControl().setFlag(3 /* GEOMETRY_CHANGED */);
                }
            } else {
                if (this._partsEnabledBuffer[pos] != 0) {
                    this._partsEnabledBuffer[pos] = 0;
                    this._partsEnabledTexture.setDirty();
                    this._application.getPipelineControl().setFlag(3 /* GEOMETRY_CHANGED */);
                }
            }
        };

        PartControl.prototype.setDrawablePartColor = function (drawable, partID, color) {
            var offset = drawable.getDrawableDescriptor().getSubMeshIDOffset();
            var pos = (offset + partID) * 4;
            this._partsColorBuffer[pos] = color[0] * 255;
            this._partsColorBuffer[pos + 1] = color[1] * 255;
            this._partsColorBuffer[pos + 2] = color[2] * 255;
            this._partsColorBuffer[pos + 3] = color[3] * 255;
            this._partsColorTexture.setDirty();
        };

        PartControl.prototype.getDrawablePartColor = function (drawable, partID) {
            var offset = drawable.getDrawableDescriptor().getSubMeshIDOffset();
            if (offset &lt; 0) {
                util.Log.postError(&quot;trying to get the color of an unregistered drawable&quot;);
            }
            var pos = (offset + partID) * 4;
            return [this._partsColorBuffer[pos] / 255, this._partsColorBuffer[pos + 1] / 255, this._partsColorBuffer[pos + 2] / 255, this._partsColorBuffer[pos + 3] / 255];
        };

        PartControl.prototype.getPartsEnabledTexture = function () {
            return this._partsEnabledTexture;
        };

        PartControl.prototype.getPartsColorTexture = function () {
            return this._partsColorTexture;
        };

        PartControl.prototype.registerDrawableMaps = function (drawable, visible) {
            var geoDesc = drawable.getForm().getGeometryDescriptor();
            var offset = this._currentBufferLength;
            drawable.getDrawableDescriptor().setIDMapOffset(offset);

            var labels = geoDesc.getLabels();
            var i, n;
            var labelToIDMap = geoDesc.getLabelToIDMap();
            var idToColorMap = geoDesc.getIDToColorMap();
            var idToVolumeMap = geoDesc.getIDToVolumeMap();
            if (geoDesc.hasMultipleParts()) {
                this._currentBufferLength += geoDesc.getIDToLabelMap().length;

                for (i = 0, n = labels.length; i &lt; n; i++) {
                    var label = labels[i];
                    var id = labelToIDMap[label];
                    if (idToColorMap) {
                        var color = idToColorMap[id];
                        this.setDrawablePartColor(drawable, id, color);
                    }
                    if (idToVolumeMap) {
                        this._partsVolumes[label] = idToVolumeMap[id];
                    }

                    var isEnabled = this._labelEnabled[label];
                    this.setDrawablePartEnabledState(drawable, id, isEnabled != null ? isEnabled : visible);
                }
            } else {
                this._currentBufferLength += 1;
                if (labelToIDMap &amp;&amp; idToColorMap) {
                    this.setDrawablePartColor(drawable, 0, idToColorMap[labelToIDMap[labels[0]]]);
                }

                var isEnabled = labels.length ? this._labelEnabled[labels[0]] : visible;
                this.setDrawablePartEnabledState(drawable, 0, isEnabled != null ? isEnabled : visible);
            }
        };

        PartControl.prototype.enablePart = function (label, enable) {
            if (typeof enable === &quot;undefined&quot;) { enable = true; }
            this._labelEnabled[label] = enable;

            this._application.getPipelineControl().setFlag(3 /* GEOMETRY_CHANGED */);
            var drawables = this._objectCatalog.getDrawablesForLabel(label, this._application);
            if (drawables.length &lt;= 0) {
                return;
            }

            var i, n;
            for (i = 0, n = drawables.length; i &lt; n; i++) {
                var drawable = drawables[i];
                var geoDesc = drawable.getForm().getGeometryDescriptor();
                var globalID = geoDesc.hasMultipleParts() ? geoDesc.getLabelToIDMap()[label] : 0;
                this.setDrawablePartEnabledState(drawable, globalID, enable);
            }
        };

        PartControl.prototype.disablePart = function (label) {
            this.enablePart(label, false);
        };

        PartControl.prototype.setPartColor = function (label, color) {
            var drawables = this._objectCatalog.getDrawablesForLabel(label, this._application);
            if (drawables.length &lt;= 0) {
                return;
            }

            var i, n;
            for (i = 0, n = drawables.length; i &lt; n; i++) {
                var drawable = drawables[i];
                var geoDesc = drawable.getForm().getGeometryDescriptor();
                var globalID = geoDesc.hasMultipleParts() ? geoDesc.getLabelToIDMap()[label] : 0;
                this.setDrawablePartColor(drawable, globalID, color);
            }

            this._application.getPipelineControl().setFlag(4 /* APPEARANCE_CHANGED */);
        };

        PartControl.prototype.getPartColor = function (label) {
            var drawables = this._objectCatalog.getDrawablesForLabel(label, this._application);
            if (drawables.length &lt;= 0) {
                return;
            }
            var geoDesc = drawables[0].getForm().getGeometryDescriptor();
            var globalID = geoDesc.hasMultipleParts() ? geoDesc.getLabelToIDMap()[label] : 0;
            return this.getDrawablePartColor(drawables[0], globalID);
        };

        PartControl.prototype.getPartVolume = function (label) {
            return this._partsVolumes[label];
        };
        return PartControl;
    })();
    pre.PartControl = PartControl;
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (PipelineControlFlags) {
        PipelineControlFlags[PipelineControlFlags[&quot;FULL&quot;] = 0] = &quot;FULL&quot;;

        PipelineControlFlags[PipelineControlFlags[&quot;NAVIGATION_STARTED&quot;] = 1] = &quot;NAVIGATION_STARTED&quot;;
        PipelineControlFlags[PipelineControlFlags[&quot;NAVIGATION_ENDED&quot;] = 2] = &quot;NAVIGATION_ENDED&quot;;

        PipelineControlFlags[PipelineControlFlags[&quot;GEOMETRY_CHANGED&quot;] = 3] = &quot;GEOMETRY_CHANGED&quot;;
        PipelineControlFlags[PipelineControlFlags[&quot;APPEARANCE_CHANGED&quot;] = 4] = &quot;APPEARANCE_CHANGED&quot;;
        PipelineControlFlags[PipelineControlFlags[&quot;VIEW_CHANGED&quot;] = 5] = &quot;VIEW_CHANGED&quot;;

        PipelineControlFlags[PipelineControlFlags[&quot;NODES_CHANGED&quot;] = 6] = &quot;NODES_CHANGED&quot;;

        PipelineControlFlags[PipelineControlFlags[&quot;SCREENSHOT&quot;] = 7] = &quot;SCREENSHOT&quot;;
    })(pre.PipelineControlFlags || (pre.PipelineControlFlags = {}));
    var PipelineControlFlags = pre.PipelineControlFlags;

    var PipelineControl = (function () {
        function PipelineControl() {
            this._state = [];
            this._currentFrame = -1;
            this._navigating = false;
            for (var flag in PipelineControlFlags) {
                this._state.push(0);
            }
        }
        PipelineControl.prototype.navigationStarted = function () {
            this._navigating = true;
            this.setFlag(1 /* NAVIGATION_STARTED */);
        };

        PipelineControl.prototype.navigationEnded = function () {
            this._navigating = false;
            this.setFlag(2 /* NAVIGATION_ENDED */);
        };

        PipelineControl.prototype.viewChanged = function (viewMatrix) {
            this.setFlag(5 /* VIEW_CHANGED */);
        };

        PipelineControl.prototype.setFlag = function (flag) {
            this._state[flag] = this._currentFrame + 1;
        };

        PipelineControl.prototype.getFlags = function () {
            return this._state;
        };

        PipelineControl.prototype.isNavigating = function () {
            return this._navigating;
        };

        PipelineControl.prototype.getCurrentFrame = function () {
            return this._currentFrame;
        };

        PipelineControl.prototype.newFrame = function (frame) {
            this._currentFrame = frame ? frame : this._currentFrame + 1;
        };
        return PipelineControl;
    })();
    pre.PipelineControl = PipelineControl;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var PipelineFactory = (function () {
        function PipelineFactory() {
        }
        PipelineFactory.createDefaultPipeline = function (application) {
            var drawableCollector = new pre.DrawableCollector(application);

            var renderPass = new pre.SimpleRenderPass(application);
            pre.PipelineStage.connect(drawableCollector, &quot;drawables&quot;, renderPass, &quot;drawables&quot;);

            var pickingPassID = new pre.PickingRenderPass(application, 0 /* ID */);
            pre.PipelineStage.connect(renderPass, &quot;drawables&quot;, pickingPassID, &quot;drawables&quot;);

            var pickingPassPoint = new pre.PickingRenderPass(application, 1 /* POINT */);
            pre.PipelineStage.connect(renderPass, &quot;drawables&quot;, pickingPassPoint, &quot;drawables&quot;);
        };

        PipelineFactory.createWebVISPipeline = function (application) {
            var drawableCollector = new pre.DrawableCollector(application);

            var renderPass = new pre.DrawMapRenderPass(application);
            pre.PipelineStage.connect(drawableCollector, &quot;drawables&quot;, renderPass, &quot;drawables&quot;);

            var pickingPassID = new pre.PickingRenderPass(application, 0 /* ID */);
            pre.PipelineStage.connect(renderPass, &quot;drawables&quot;, pickingPassID, &quot;drawables&quot;);

            var pickingPassPoint = new pre.PickingRenderPass(application, 1 /* POINT */);
            pre.PipelineStage.connect(renderPass, &quot;drawables&quot;, pickingPassPoint, &quot;drawables&quot;);
        };
        return PipelineFactory;
    })();
    pre.PipelineFactory = PipelineFactory;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var PipelineStage = (function (_super) {
        __extends(PipelineStage, _super);
        function PipelineStage(application) {
            _super.call(this);
            this._application = null;
            this._context = null;
            this._pipelineControl = null;
            this._triggers = [];
            this._lastClearFrame = -1;
            this._inputSlots = {};
            this._outputSlots = {};
            this._drawables = [];
            this._application = application;
            this._application.addStage(this);
        }
        PipelineStage.connect = function (outputStage, outputSlotName, inputStage, inputSlotName) {
            var output = outputStage.getOutputSlot(outputSlotName), input = inputStage.getInputSlot(inputSlotName);

            if (!output) {
                util.Log.postError(&quot;Unable to create connection: Output slot \&quot;&quot; + outputSlotName + &quot;\&quot;: not found.&quot;);
                return;
            }

            if (!input) {
                util.Log.postError(&quot;Unable to create connection: Input slot \&quot;&quot; + inputSlotName + &quot;\&quot;: not found.&quot;);
                return;
            }

            input.connectOutput(output);

            if (inputStage.getParents().indexOf(outputStage) == -1) {
                inputStage.addParent(outputStage);
                outputStage.addChild(inputStage);
            }
        };

        PipelineStage.prototype.getInputSlot = function (name) {
            return this._inputSlots[name];
        };

        PipelineStage.prototype.getOutputSlot = function (name) {
            return this._outputSlots[name];
        };

        PipelineStage.prototype.execute = function (context) {
            this._context = context;
            this._pipelineControl = context.getApplication().getPipelineControl();
            var clearFrame = this.checkInputSlots() || this.checkEventFlags();
            if (clearFrame) {
                this._lastClearFrame = this._pipelineControl.getCurrentFrame();
            }
            this._execute(clearFrame);
        };

        PipelineStage.prototype._execute = function (newFrame) {
        };

        PipelineStage.prototype.checkEventFlags = function () {
            var flags = this._pipelineControl.getFlags();
            for (var i = 0; i &lt; this._triggers.length; i++) {
                if (flags[this._triggers[i]] &gt; this._lastClearFrame) {
                    return true;
                }
            }
            return false;
        };

        PipelineStage.prototype.checkInputSlots = function () {
            for (var i in this._inputSlots) {
                if (this._inputSlots[i].hasNewInput()) {
                    return true;
                }
            }
            return false;
        };
        return PipelineStage;
    })(pre.GraphNodeBase);
    pre.PipelineStage = PipelineStage;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var Settings = (function () {
        function Settings() {
            this.frameId = -1;
            this.maxDrawablesPerFrame = 2500;
            this.maxDrawablesPerNavigationFrame = 200;
            this.frustumCulling = true;
            this.smallFeatureCulling = true;
            this.smallFeatureTreshold = 0.003;
            this.memoryBatching = false;
            this.showDebugVolumes = false;
            this.codePrioritiesInDiffuseColor = false;
        }
        Settings.prototype.getLimit = function (navigating) {
            return navigating ? this.maxDrawablesPerNavigationFrame : this.maxDrawablesPerFrame;
        };
        return Settings;
    })();
    pre.Settings = Settings;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var Slot = (function () {
        function Slot(name, resource) {
            this._resource = null;
            this._processedVersion = -1;
            this._processedCount = 0;
            this._name = name;
            this._resource = resource;
        }
        Slot.prototype.getName = function () {
            return this._name;
        };

        Slot.prototype.connectOutput = function (output) {
            this._resource = output.getResource();
        };

        Slot.prototype.hasNewInput = function () {
            return this._processedVersion != this._resource.getVersion() &amp;&amp; !(this._processedCount = 0);
        };

        Slot.prototype.getResource = function () {
            return this._resource;
        };

        Slot.prototype.getProcessedCount = function () {
            return this._processedCount;
        };

        Slot.prototype.processed = function (count) {
            this._processedCount = count;
            this._processedVersion = this._resource.getVersion();
        };
        return Slot;
    })();
    pre.Slot = Slot;

    var MultiSlot = (function () {
        function MultiSlot(name) {
            this._slots = [];
            this._resources = null;
            this._data = null;
            this._name = name;
        }
        MultiSlot.prototype.getName = function () {
            return this._name;
        };

        MultiSlot.prototype.connectOutput = function (output) {
            this._slots.push(new Slot(output.getName(), output.getResource()));
        };

        MultiSlot.prototype.hasNewInput = function () {
            var i;
            for (i in this._slots) {
                if (this._slots[i].hasNewInput()) {
                    return true;
                }
            }
            return false;
        };

        MultiSlot.prototype.getResource = function () {
            if (this._resources == null || this._data == null) {
                this._data = this._slots.map(function (slot) {
                    return slot.getResource().getData();
                });

                this._resources = pre.ObjectResource.Create(this._data);
            }
            return this._resources;
        };

        MultiSlot.prototype.getSlots = function () {
            return this._slots;
        };
        return MultiSlot;
    })();
    pre.MultiSlot = MultiSlot;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var AttributeLocation = (function () {
        function AttributeLocation(name, location) {
            if (typeof location === &quot;undefined&quot;) { location = -1; }
            this.location = -1;
            this.name = name;
            this.location = location;
        }
        return AttributeLocation;
    })();
    pre.AttributeLocation = AttributeLocation;
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (BindStage) {
        BindStage[BindStage[&quot;UNCLASSIFIED&quot;] = 0] = &quot;UNCLASSIFIED&quot;;
        BindStage[BindStage[&quot;GLOBAL&quot;] = 1] = &quot;GLOBAL&quot;;
        BindStage[BindStage[&quot;PASS&quot;] = 2] = &quot;PASS&quot;;
        BindStage[BindStage[&quot;APPEARANCE&quot;] = 3] = &quot;APPEARANCE&quot;;
        BindStage[BindStage[&quot;DRAWABLE&quot;] = 4] = &quot;DRAWABLE&quot;;
        BindStage[BindStage[&quot;GEOMETRY&quot;] = 5] = &quot;GEOMETRY&quot;;
    })(pre.BindStage || (pre.BindStage = {}));
    var BindStage = pre.BindStage;

    var AttribPointerData = (function () {
        function AttribPointerData() {
            this.offset = 0;
        }
        return AttribPointerData;
    })();
    pre.AttribPointerData = AttribPointerData;

    
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (FrameBufferTextureUsage) {
        FrameBufferTextureUsage[FrameBufferTextureUsage[&quot;COLOR_TARGET0&quot;] = 0] = &quot;COLOR_TARGET0&quot;;
        FrameBufferTextureUsage[FrameBufferTextureUsage[&quot;DEPTH_TARGET&quot;] = 1] = &quot;DEPTH_TARGET&quot;;
    })(pre.FrameBufferTextureUsage || (pre.FrameBufferTextureUsage = {}));
    var FrameBufferTextureUsage = pre.FrameBufferTextureUsage;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var Constants = (function () {
        function Constants() {
            this.COLOR_BUFFER_BIT = 0;
            this.DEPTH_BUFFER_BIT = 0;
            this.STENCIL_BUFFER_BIT = 0;
            this.DEPTH_MASK = 0;
            this.NEVER = 0;
            this.ALWAYS = 0;
            this.LESS = 0;
            this.EQUAL = 0;
            this.LEQUAL = 0;
            this.GREATER = 0;
            this.GEQUAL = 0;
            this.NOTEQUAL = 0;
            this.ZERO = 0;
            this.ONE = 0;
            this.SRC_COLOR = 0;
            this.ONE_MINUS_SRC_COLOR = 0;
            this.SRC_ALPHA = 0;
            this.ONE_MINUS_SRC_ALPHA = 0;
            this.DST_ALPHA = 0;
            this.ONE_MINUS_DST_ALPHA = 0;
            this.DST_COLOR = 0;
            this.ONE_MINUS_DST_COLOR = 0;
            this.SRC_ALPHA_SATURATE = 0;
            this.FUNC_ADD = 0;
            this.BLEND_EQUATION = 0;
            this.BLEND_EQUATION_RGB = 0;
            this.BLEND_EQUATION_ALPHA = 0;
            this.FUNC_SUBTRACT = 0;
            this.FUNC_REVERSE_SUBTRACT = 0;
            this.FRONT = 0;
            this.BACK = 0;
            this.FRONT_AND_BACK = 0;
            this.CULL_FACE = 0;
            this.BLEND = 0;
            this.DITHER = 0;
            this.STENCIL_TEST = 0;
            this.DEPTH_TEST = 0;
            this.SCISSOR_TEST = 0;
            this.POLYGON_OFFSET_FILL = 0;
            this.SAMPLE_ALPHA_TO_COVERAGE = 0;
            this.SAMPLE_COVERAGE = 0;
        }
        return Constants;
    })();
    pre.Constants = Constants;

    
})(pre || (pre = {}));
var renderer;
(function (renderer) {
    var MemoryManager = (function () {
        function MemoryManager(app, gl) {
            this._idToBatchID = [];
            this._batches = [];
            this._batchInitialized = [];
            this._batchSize = [];
            this._batchFreeSize = [];
            this._glBuffers = [];
            this._bufferComplete = [];
            this._bufferProgress = [];
            this._bufferOffset = [];
            this._bufferVersion = [];
            this._attribPointerDatas = [];
            this._allocatedGPUMemory = 0;
            this._application = app;
            this._batching = app.getSettings().memoryBatching;
            app.registerFrameObserver(this);

            this._gl = gl;
        }
        MemoryManager.prototype._createBatch = function (minSize) {
            var size = minSize * 10;
            var id = this._batches.push(this._gl.createBuffer()) - 1;
            this._batchSize.push(size);
            this._batchFreeSize.push(size);
            this._batchInitialized.push(false);
            return id;
        };

        MemoryManager.prototype._searchFreeBatch = function (size) {
            for (var i = 0, n = this._batches.length; i &lt; n; i++) {
                if (this._batchFreeSize[i] &gt;= size) {
                    return i;
                }
            }
            return -1;
        };

        MemoryManager.prototype._createBuffer = function (bufferID, bufferDesc) {
            if (this._batching) {
                var size = bufferDesc.getBufferSize();
                var batchID = this._searchFreeBatch(size);
                if (batchID &lt; 0) {
                    batchID = this._createBatch(size);
                }
                this._idToBatchID[bufferID] = batchID;
                this._glBuffers[bufferID] = this._batches[batchID];
            } else {
                this._attribPointerDatas[bufferID] = { offset: bufferDesc.getOffset() };
                this._bufferComplete[bufferID] = false;
                this._glBuffers[bufferID] = this._gl.createBuffer();
            }

            return this._glBuffers[bufferID];
        };

        MemoryManager.prototype._updateBuffer = function (id, batchID, bufferDesc, bufferData, target) {
            var fullBufferLength = bufferDesc.getBufferSize();
            var bufferProgress = this._bufferProgress[id];

            if (bufferProgress == null) {
                this._bufferOffset[id] = this._batching ? (this._batchSize[batchID] - this._batchFreeSize[batchID]) : 0;
                this._gl.bufferData(target, fullBufferLength, bufferDesc.getUsageHint());
                this._allocatedGPUMemory += fullBufferLength;
                bufferProgress = this._bufferProgress[id] = 0;
            }

            if (this._bufferComplete[id] &amp;&amp; this._bufferVersion[id] != bufferDesc.getVersion()) {
                bufferProgress = 0;
                this._bufferComplete[id] = false;
            }

            var current = 0, next = 0;
            var offset = this._bufferOffset[id];
            for (var i = 0, n = bufferData.length; i &lt; n; i++) {
                next = current + bufferData[i].byteLength;
                if (next &gt; bufferProgress) {
                    var stats = util.Statistics.getInstance();
                    stats.startMeasurement(&quot;UPLOAD&quot;);
                    this._gl.bufferSubData(target, offset + current, bufferData[i]);
                    stats.stopMeasurement(&quot;UPLOAD&quot;);
                }
                current = next;
            }

            this._bufferProgress[id] = current;

            if (current &gt;= fullBufferLength) {
                this._bufferComplete[id] = true;
                this._bufferVersion[id] = bufferDesc.getVersion();
            }
        };

        MemoryManager.prototype.onFrame = function (frameID) {
        };

        MemoryManager.prototype.syncData = function (bufferDesc, target, progressive) {
            if (typeof progressive === &quot;undefined&quot;) { progressive = false; }
            var id = bufferDesc.getID();
            var batchID = -1;
            if (!this._bufferComplete[id] || this._bufferVersion[id] != bufferDesc.getVersion()) {
                var bufferData = bufferDesc.getData();
                if (bufferData) {
                    if (this._batching) {
                        batchID = this._idToBatchID[id];
                        if (!this._batchInitialized[batchID]) {
                            var batchSize = this._batchSize[batchID];

                            this._gl.bufferData(target, batchSize, bufferDesc.getUsageHint());
                            this._allocatedGPUMemory += batchSize;
                        }
                    }
                    if (progressive) {
                        this._updateBuffer(id, batchID, bufferDesc, bufferData, target);
                    } else {
                        if (this._batching) {
                            var offset = this._batchSize[batchID] - this._batchFreeSize[batchID];
                            this._gl.bufferSubData(target, offset, bufferData);
                        } else {
                            this._gl.bufferData(target, bufferData, bufferDesc.getUsageHint());
                            this._allocatedGPUMemory += bufferDesc.getBufferSize();
                        }
                        this._bufferComplete[id] = true;
                        this._bufferVersion[id] = bufferDesc.getVersion();
                    }
                } else {
                    return null;
                }
            }
            return this._attribPointerDatas[id];
        };

        MemoryManager.prototype.requestGPUBuffer = function (bufferDesc) {
            var id = bufferDesc.getID();
            return this._glBuffers[id] || this._createBuffer(id, bufferDesc);
        };

        MemoryManager.prototype.getAllocatedGPUMemorySize = function () {
            return this._allocatedGPUMemory;
        };
        return MemoryManager;
    })();
    renderer.MemoryManager = MemoryManager;
})(renderer || (renderer = {}));
var pre;
(function (pre) {
    var RenderState = (function () {
        function RenderState() {
            this.cullFaceMode = 0;
            this.cullFaceEnabled = false;
            this.depthMask = true;
            this.depthTestEnabled = true;
            this.blendEnabled = false;
            this.colorMask = [true, true, true, true];
            this.clearColor = vec4.fromValues(0.0, 0.0, 0.0, 0.0);
            this.clearDepth = 1.0;
        }
        return RenderState;
    })();
    pre.RenderState = RenderState;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var ShaderService = (function () {
        function ShaderService() {
            this._shaderPrograms = [];
            this._shaderDescriptorMap = {};
            this._fallbackShaderDescriptor = new pre.FallbackShader();
            this._simpleShaderDescriptor = new pre.UberShader();
        }
        ShaderService.prototype.requestShaderProgram = function (shaderDescriptor, application) {
            var identifier = application.getIdentifier() + shaderDescriptor.getName();
            var shaderId = this._shaderDescriptorMap[identifier];

            var shaderProgram;
            var fallbackShaderProgram;

            if (shaderId == null) {
                shaderProgram = application.getDefaultRenderer().buildShaderProgram(shaderDescriptor, this._shaderPrograms.length);

                if (!shaderProgram) {
                    shaderId = this._shaderDescriptorMap[&quot;__preFallbackShader&quot;];

                    if (typeof shaderId == 'undefined') {
                        util.Log.postError(&quot;At least one shader could not be obtained. Using default fallback shader instead.\n&quot;);

                        fallbackShaderProgram = application.getDefaultRenderer().buildShaderProgram(this._fallbackShaderDescriptor, this._shaderPrograms.length);

                        shaderId = this._shaderPrograms.push(fallbackShaderProgram) - 1;
                        this._shaderDescriptorMap[&quot;__preFallbackShader&quot;] = shaderId;
                    }
                } else {
                    shaderId = this._shaderPrograms.push(shaderProgram) - 1;
                }

                this._shaderDescriptorMap[identifier] = shaderId;
            }

            return shaderId;
        };

        ShaderService.prototype.requestShaderForDrawable = function (drawable) {
            var shaderId = this.requestShaderProgram(this._simpleShaderDescriptor, drawable.getRenderTreeNode().getApplication());

            return shaderId;
        };

        ShaderService.prototype.isFallbackShader = function (programID) {
            return (programID == this._shaderDescriptorMap[&quot;__preFallbackShader&quot;]);
        };

        ShaderService.prototype.getShaderProgram = function (programID) {
            return this._shaderPrograms[programID];
        };
        return ShaderService;
    })();
    pre.ShaderService = ShaderService;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var Resource = (function (_super) {
        __extends(Resource, _super);
        function Resource(type, fetch) {
            _super.call(this, type, fetch);
        }
        Resource.Create = function (type, data) {
            return new Resource(type, function (callback) {
                return data;
            });
        };

        Resource.CreateLazy = function (type, fetch) {
            return new Resource(type, fetch);
        };

        Resource.prototype.equals = function (other) {
            if (this.getType() == other.getType() &amp;&amp; this.constructor == other.constructor) {
                var data = this.getData();
                var otherData = other.getData();
                if (data.length == otherData.length) {
                    for (var i = 0; i &lt; data.length; i++) {
                        if (data[i] != otherData[i]) {
                            return false;
                        }
                    }
                    return true;
                }
            }
            return false;
        };
        return Resource;
    })(pre.AbstractResource);
    pre.Resource = Resource;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var ShaderVariableBase = (function () {
        function ShaderVariableBase(name, type, numElements) {
            if (typeof numElements === &quot;undefined&quot;) { numElements = 1; }
            this.name = name;
            this.type = type;
            this.numElements = numElements;
        }
        return ShaderVariableBase;
    })();
    pre.ShaderVariableBase = ShaderVariableBase;
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (UniformShaderType) {
        UniformShaderType[UniformShaderType[&quot;VERTEX&quot;] = 1] = &quot;VERTEX&quot;;
        UniformShaderType[UniformShaderType[&quot;FRAGMENT&quot;] = 2] = &quot;FRAGMENT&quot;;
        UniformShaderType[UniformShaderType[&quot;ALL&quot;] = 1 | 2] = &quot;ALL&quot;;
    })(pre.UniformShaderType || (pre.UniformShaderType = {}));
    var UniformShaderType = pre.UniformShaderType;

    var UniformShaderVariable = (function (_super) {
        __extends(UniformShaderVariable, _super);
        function UniformShaderVariable(name, type, shaderType, location, id, numElements) {
            if (typeof location === &quot;undefined&quot;) { location = null; }
            if (typeof id === &quot;undefined&quot;) { id = -1; }
            if (typeof numElements === &quot;undefined&quot;) { numElements = 1; }
            _super.call(this, name, type, numElements);
            this.location = null;

            this.shaderType = shaderType;
            this.location = location;
            this.id = id;
        }
        return UniformShaderVariable;
    })(pre.ShaderVariableBase);
    pre.UniformShaderVariable = UniformShaderVariable;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var VaryingShaderVariable = (function (_super) {
        __extends(VaryingShaderVariable, _super);
        function VaryingShaderVariable(name, type, numElements) {
            if (typeof numElements === &quot;undefined&quot;) { numElements = 1; }
            _super.call(this, name, type, numElements);
        }
        return VaryingShaderVariable;
    })(pre.ShaderVariableBase);
    pre.VaryingShaderVariable = VaryingShaderVariable;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var BoxVolumeShader = (function (_super) {
        __extends(BoxVolumeShader, _super);
        function BoxVolumeShader() {
            _super.call(this);

            this._name = &quot;BoxVolumeShader&quot;;

            this._vSource = &quot;\n&quot; + &quot;attribute vec3 position;\n&quot; + &quot;\n&quot; + &quot;uniform mat4 mMatrix;\n&quot; + &quot;uniform mat4 vMatrix;\n&quot; + &quot;uniform mat4 pMatrix;\n&quot; + &quot;\n&quot; + &quot;void main(void)\n&quot; + &quot;{\n&quot; + &quot;&quot; + &quot;   gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n&quot; + &quot;}&quot;;

            this._fSource = &quot;\n&quot; + &quot;precision lowp float;&quot; + &quot;uniform vec4 color;\n&quot; + &quot;\n&quot; + &quot;void main(void)\n&quot; + &quot;{\n&quot; + &quot;   gl_FragColor = color;\n&quot; + &quot;}&quot;;

            this._uniforms = [
                new pre.UniformShaderVariable(&quot;mMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;vMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;pMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;color&quot;, pre.ResourceType.vec4f, 2 /* FRAGMENT */)
            ];

            this._attributes = [
                new pre.AttributeLocation(&quot;position&quot;)
            ];

            this._varyings = [];
        }
        return BoxVolumeShader;
    })(pre.ShaderDescriptorBase);
    pre.BoxVolumeShader = BoxVolumeShader;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var ContourDepthCompositingShader = (function (_super) {
        __extends(ContourDepthCompositingShader, _super);
        function ContourDepthCompositingShader() {
            _super.call(this);

            this._name = &quot;ContourDepthCompositingShader&quot;;

            this._vSource = &quot;attribute vec2 position;\n &quot; + &quot;void main() {\n &quot; + &quot;    gl_Position = vec4(position, 1.0, 1.0);\n&quot; + &quot;}&quot;;

            this._fSource = &quot;precision highp float;\n &quot; + &quot;uniform sampler2D contourImage;\n &quot; + &quot;uniform sampler2D contourObjectsDepth;\n &quot; + &quot;void main(void)\n &quot; + &quot;{\n &quot; + &quot;   gl_FragColor = texture2D(contourImage, gl_FragCoord.xy);\n &quot; + &quot;}&quot;;

            this._uniforms = [
                new pre.UniformShaderVariable(&quot;contourImage&quot;, pre.ResourceType.sampler2D, 2 /* FRAGMENT */)
            ];

            this._attributes = [
                new pre.AttributeLocation(&quot;position&quot;),
                new pre.AttributeLocation(&quot;texcoord&quot;)
            ];

            this._varyings = [
                new pre.VaryingShaderVariable(&quot;fragTexCoord&quot;, pre.ResourceType.vec2f)
            ];
        }
        return ContourDepthCompositingShader;
    })(pre.ShaderDescriptorBase);
    pre.ContourDepthCompositingShader = ContourDepthCompositingShader;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var FallbackShader = (function (_super) {
        __extends(FallbackShader, _super);
        function FallbackShader() {
            _super.call(this);

            this._name = &quot;FallbackShader&quot;;

            this._vSource = &quot;\n&quot; + &quot;attribute vec3 position;\n&quot; + &quot;\n&quot; + &quot;uniform mat4 mMatrix;\n&quot; + &quot;uniform mat4 vMatrix;\n&quot; + &quot;uniform mat4 pMatrix;\n&quot; + &quot;\n&quot; + &quot;void main(void)\n&quot; + &quot;{\n&quot; + &quot;   gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);\n&quot; + &quot;}&quot;;

            this._fSource = &quot;\n&quot; + &quot;void main(void)\n&quot; + &quot;{\n&quot; + &quot;   gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n&quot; + &quot;}&quot;;

            this._uniforms = [
                new pre.UniformShaderVariable(&quot;mMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;vMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;pMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */)
            ];

            this._attributes = [
                new pre.AttributeLocation(&quot;position&quot;)
            ];

            this._varyings = [];
        }
        return FallbackShader;
    })(pre.ShaderDescriptorBase);
    pre.FallbackShader = FallbackShader;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var LaplacePostProShader = (function (_super) {
        __extends(LaplacePostProShader, _super);
        function LaplacePostProShader(stepSize) {
            if (typeof stepSize === &quot;undefined&quot;) { stepSize = 0.001; }
            _super.call(this);
            this._stepSize = 0;
            this._stepSize = stepSize;

            this._name = &quot;LaplacePostProShader&quot;;

            this._vSource = &quot;attribute vec2 position;\n &quot; + &quot;void main() {\n &quot; + &quot;    gl_Position = vec4(position, 1.0, 1.0);\n&quot; + &quot;}&quot;;

            this._fSource = &quot;precision highp float;\n &quot; + &quot;uniform sampler2D inputImage;\n &quot; + &quot;uniform vec2 inverseViewportSize;\n&quot; + &quot;float stepsize = &quot; + this._stepSize + &quot;;\n &quot; + &quot;vec3 color = vec3(0.0, 1.0, 0.0);\n &quot; + &quot;float sample(vec2 pos)\n &quot; + &quot;{\n &quot; + &quot;return dot(texture2D(inputImage, pos), vec4(1.0, 0.0, 0.0, 0.0));\n &quot; + &quot;}\n &quot; + &quot;void main(void)\n &quot; + &quot;{\n &quot; + &quot;    float c = 0.0;\n &quot; + &quot;    vec2 fragTexCoord = gl_FragCoord.xy * inverseViewportSize;\n&quot; + &quot;    for(int x=-1; x&lt;2; x++){\n &quot; + &quot;    for(int y = -1; y&lt;2; y++){\n &quot; + &quot;        c += sample( fragTexCoord + vec2(x,y) * stepsize);\n &quot; + &quot;        }\n &quot; + &quot;    }\n &quot; + &quot;    c -= 9.0 * sample(fragTexCoord);\n &quot; + &quot;    gl_FragColor.rgb = color;\n &quot; + &quot;    if(c &gt; 0.1){\n &quot; + &quot;        gl_FragColor.a = 1.0;\n &quot; + &quot;    }else{\n &quot; + &quot;        gl_FragColor.a = 0.0;\n &quot; + &quot;    }&quot; + &quot;}&quot;;

            this._uniforms = [
                new pre.UniformShaderVariable(&quot;inputImage&quot;, pre.ResourceType.sampler2D, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;inverseViewportSize&quot;, pre.ResourceType.vec2f, 2 /* FRAGMENT */)
            ];

            this._attributes = [
                new pre.AttributeLocation(&quot;position&quot;)
            ];

            this._varyings = [];
        }
        return LaplacePostProShader;
    })(pre.ShaderDescriptorBase);
    pre.LaplacePostProShader = LaplacePostProShader;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var PickingShader = (function (_super) {
        __extends(PickingShader, _super);
        function PickingShader() {
            var _NUM_CLIPPLANES = 8;
            var _CLIPPLANES_STRIDE = 5;

            _super.call(this);

            this._name = &quot;PickingShader&quot;;

            this._vSource = &quot;\n&quot; + &quot;attribute vec3 position;\n&quot; + &quot;attribute float id;\n&quot; + &quot;\n&quot; + &quot;uniform mat4 mMatrix;\n&quot; + &quot;uniform mat4 vMatrix;\n&quot; + &quot;uniform mat4 pMatrix;\n&quot; + &quot;uniform int subMeshIDOffset;\n&quot; + &quot;uniform sampler2D partsEnabledTexture;\n&quot; + &quot;varying vec3 varPosition;\n&quot; + &quot;varying float varID;\n&quot; + &quot;\n&quot; + &quot;void main(void)\n&quot; + &quot;{\n&quot; + &quot;&quot; + &quot;   int idPosition = int( id + 0.5 ) + subMeshIDOffset;\n&quot; + &quot;   vec2 idTexPos = vec2( mod( float( idPosition ), 1024.0 ), float(idPosition / 1024 ) ) / 1024.0;\n&quot; + &quot;   vec4 enabled = texture2D( partsEnabledTexture, idTexPos );\n&quot; + &quot;   if( enabled.x &gt;= 1.0 )\n&quot; + &quot;   {\n&quot; + &quot;       varPosition = (mMatrix * vec4(position, 1.0)).xyz;\n&quot; + &quot;       gl_Position = pMatrix * vMatrix * vec4(varPosition, 1.0);\n&quot; + &quot;       varID = float( idPosition );\n&quot; + &quot;   }\n&quot; + &quot;   else\n&quot; + &quot;   {\n&quot; + &quot;       gl_Position = vec4(-2, -2, -2, 1);\n&quot; + &quot;   }\n&quot; + &quot;}&quot;;

            this._fSource = &quot;\n&quot; + &quot;precision mediump float;&quot; + &quot;uniform float clipPlaneEnabledStates[&quot; + _NUM_CLIPPLANES + &quot;];\n&quot; + &quot;uniform vec4 clipPlaneDefinitions[&quot; + _NUM_CLIPPLANES + &quot;];\n&quot; + &quot;const int clipPlanesCount = &quot; + _NUM_CLIPPLANES + &quot;;\n&quot; + &quot;uniform vec4 pickingColor;\n&quot; + &quot;uniform int pickMode;\n&quot; + &quot;uniform vec3 bbMin;\n&quot; + &quot;uniform vec3 bbMax;\n&quot; + &quot;varying vec3 varPosition;\n&quot; + &quot;varying float varID;\n&quot; + &quot;\n&quot; + &quot;void main(void)\n&quot; + &quot;{\n&quot; + &quot;   for( int pos = 0; pos &lt; clipPlanesCount; pos++ )\n&quot; + &quot;   {\n&quot; + &quot;       if( clipPlaneEnabledStates[ pos ] &lt;= 0.0)\n&quot; + &quot;           continue;&quot; + &quot;       if( (dot( varPosition,  clipPlaneDefinitions[pos].xyz) - clipPlaneDefinitions[pos].w) &lt; 0.0  )\n&quot; + &quot;           discard;\n&quot; + &quot;   }\n&quot; + &quot;   if(pickMode == 0) // pickMode is ID\n&quot; + &quot;   {\n&quot; + &quot;       float drawColor = varID + 0.5 + 1.0;\n&quot; + &quot;       vec4 packedColor   = vec4(drawColor / 16777216.0, drawColor / 65536.0, drawColor / 256.0, drawColor);\n&quot; + &quot;       ivec4 packedColorI = ivec4(packedColor.x, packedColor.y, packedColor.z, drawColor);\n&quot; + &quot;       vec4 color = vec4(packedColorI.x, packedColorI.y - packedColorI.x * 256, packedColorI.z - packedColorI.y * 256, packedColorI.w - packedColorI.z * 256);\n&quot; + &quot;       gl_FragColor = color / 255.0;\n&quot; + &quot;   }\n&quot; + &quot;   else if(pickMode == 1) // pickMode is POINT\n&quot; + &quot;   {\n&quot; + &quot;       vec3 range = bbMax - bbMin;\n&quot; + &quot;       vec3 quantPos = (varPosition.xyz - bbMin) / range;\n&quot; + &quot;       gl_FragColor = vec4(quantPos, 1.0);\n&quot; + &quot;   }\n&quot; + &quot;}&quot;;

            this._uniforms = [
                new pre.UniformShaderVariable(&quot;mMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;vMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;pMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;partsEnabledTexture&quot;, pre.ResourceType.sampler2D, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;subMeshIDOffset&quot;, pre.ResourceType.INT_32, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;clipPlaneEnabledStates&quot;, pre.ResourceType.FLOAT_32, 2 /* FRAGMENT */, null, -1, _NUM_CLIPPLANES),
                new pre.UniformShaderVariable(&quot;clipPlaneDefinitions&quot;, pre.ResourceType.vec4f, 2 /* FRAGMENT */, null, -1, _NUM_CLIPPLANES),
                new pre.UniformShaderVariable(&quot;pickingColor&quot;, pre.ResourceType.vec4f, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;pickMode&quot;, pre.ResourceType.INT_32, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;bbMin&quot;, pre.ResourceType.vec3f, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;bbMax&quot;, pre.ResourceType.vec3f, 2 /* FRAGMENT */)
            ];

            this._attributes = [
                new pre.AttributeLocation(&quot;position&quot;),
                new pre.AttributeLocation(&quot;id&quot;)
            ];

            this._varyings = [
                new pre.VaryingShaderVariable(&quot;varPosition&quot;, pre.ResourceType.vec3f),
                new pre.VaryingShaderVariable(&quot;varID&quot;, pre.ResourceType.FLOAT_32)
            ];
        }
        return PickingShader;
    })(pre.ShaderDescriptorBase);
    pre.PickingShader = PickingShader;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var UberShader = (function (_super) {
        __extends(UberShader, _super);
        function UberShader() {
            var _NUM_LIGHTS = 8;
            var _LIGHTS_STRIDE = 2;
            var _NUM_CLIPPLANES = 8;

            _super.call(this);

            this._name = &quot;UberShader&quot;;

            this._vSource = &quot;\n&quot; + &quot;attribute vec3 position;\n&quot; + &quot;attribute vec3 normal;\n&quot; + &quot;attribute vec2 texcoord;\n&quot; + &quot;attribute float id;\n&quot; + &quot;\n&quot; + &quot;uniform mat4 mMatrix;\n&quot; + &quot;uniform mat4 nMatrix;\n&quot; + &quot;uniform mat4 vMatrix;\n&quot; + &quot;uniform mat4 pMatrix;\n&quot; + &quot;\n&quot; + &quot;varying vec3 varNormal;\n&quot; + &quot;varying vec3 varPosition;\n&quot; + &quot;varying vec2 varTexCoord;\n&quot; + &quot;varying float varID;\n&quot; + &quot;\n&quot; + &quot;\n&quot; + &quot;void main( void )\n&quot; + &quot;{\n&quot; + &quot;\n&quot; + &quot;   varPosition = ( mMatrix * vec4( position, 1.0 ) ).xyz;\n&quot; + &quot;   gl_Position = pMatrix * vMatrix * vec4( varPosition, 1.0 );\n&quot; + &quot;   varNormal = (( nMatrix * vec4(normal, 1.0) ).xyz);\n&quot; + &quot;   varTexCoord = texcoord;\n&quot; + &quot;   varID = id;\n&quot; + &quot;}&quot;;

            this._fSource = &quot;\n&quot; + &quot;precision mediump float;\n&quot; + &quot;uniform sampler2D partsEnabledTexture;\n&quot; + &quot;uniform sampler2D partsColorTexture;\n&quot; + &quot;uniform int subMeshIDOffset;\n&quot; + &quot;uniform vec4 lights[&quot; + (_NUM_LIGHTS * _LIGHTS_STRIDE) + &quot;];\n&quot; + &quot;const int lightsCount  = &quot; + _NUM_LIGHTS + &quot;;\n&quot; + &quot;const int lightsStride = &quot; + _LIGHTS_STRIDE + &quot;;\n&quot; + &quot;uniform float clipPlaneEnabledStates[&quot; + _NUM_CLIPPLANES + &quot;];\n&quot; + &quot;uniform vec4 clipPlaneDefinitions[&quot; + _NUM_CLIPPLANES + &quot;];\n&quot; + &quot;const int clipPlanesCount = &quot; + _NUM_CLIPPLANES + &quot;;\n&quot; + &quot;uniform sampler2D diffuseTexture;\n&quot; + &quot;uniform vec3 diffuseColor;\n&quot; + &quot;uniform vec3 emissiveColor;\n&quot; + &quot;uniform bool hasDiffuseTexture;\n&quot; + &quot;uniform bool lightingEnabled;\n&quot; + &quot;uniform mat4 vMatrixInv;\n&quot; + &quot;\n&quot; + &quot;varying vec3 varNormal;\n&quot; + &quot;varying highp vec3 varPosition;\n&quot; + &quot;varying vec2 varTexCoord;\n&quot; + &quot;varying float varID;\n&quot; + &quot;\n&quot; + &quot;\n&quot; + &quot;const float Epsilon = 0.0001;\n&quot; + &quot;void main( void )\n&quot; + &quot;{\n&quot; + &quot;   int idPosition = int(varID + 0.5) + subMeshIDOffset;\n&quot; + &quot;   vec2 idTexPos = vec2( mod(float(idPosition), 1024.0) + 0.5, float(idPosition / 1024) + 0.5 ) / 1024.0;\n&quot; + &quot;   vec4 color   = texture2D( partsColorTexture,   idTexPos );\n&quot; + &quot;   vec4 enabled = texture2D( partsEnabledTexture, idTexPos );\n&quot; + &quot;   if (enabled.x &lt;= 0.0)\n&quot; + &quot;   {\n&quot; + &quot;       discard;\n&quot; + &quot;   }\n&quot; + &quot; \n&quot; + &quot;   for( int pos = 0; pos &lt; clipPlanesCount; pos++ )\n&quot; + &quot;   {\n&quot; + &quot;       if( clipPlaneEnabledStates[ pos ] &lt;= 0.0)\n&quot; + &quot;           continue;&quot; + &quot;       if( (dot( varPosition,  clipPlaneDefinitions[pos].xyz) - clipPlaneDefinitions[pos].w) &lt; 0.0  )\n&quot; + &quot;           discard;\n&quot; + &quot;   }\n&quot; + &quot;   if (lightingEnabled) {\n&quot; + &quot;     float diffuse = 0.0;\n&quot; + &quot;     float specular = 0.0;\n&quot; + &quot;     vec3 fnormal = normalize( varNormal );\n&quot; + &quot;     vec3 viewDirection = normalize( (vMatrixInv * vec4(0.0, 0.0, 0.0, 1.0)).xyz - varPosition );\n&quot; + &quot;     if( dot( viewDirection, fnormal ) &lt; 0.0)\n&quot; + &quot;         fnormal = -fnormal;\n&quot; + &quot;     for( int pos = 0; pos &lt; lightsCount * lightsStride; pos += lightsStride )\n&quot; + &quot;     {\n&quot; + &quot;         if( lights[pos].w &lt;= Epsilon)\n&quot; + &quot;             continue;\n&quot; + &quot;         vec4 lightColor = lights[pos + 1];\n&quot; + &quot;         vec3 lightVector;\n&quot; + &quot;         if( abs(lights[pos].w - 1.0) &lt; Epsilon )\n&quot; + &quot;         {\n&quot; + &quot;             vec3 lightPosition = lights[pos].xyz;\n&quot; + &quot;             lightVector = normalize( lightPosition - varPosition );\n&quot; + &quot;         }\n&quot; + &quot;         else if( abs(lights[pos].w - 2.0) &lt; Epsilon )\n&quot; + &quot;         {\n&quot; + &quot;             lightVector = -normalize(lights[pos].xyz);\n&quot; + &quot;         }\n&quot; + &quot;         float dotValue = max(dot( fnormal, lightVector ), 0.0);\n&quot; + &quot;         diffuse  = clamp(diffuse + dotValue, 0.0, 1.0);\n&quot; + &quot;         dotValue = max(dot( fnormal, normalize(lightVector + viewDirection) ), 0.0);\n&quot; + &quot;         specular = clamp(specular + pow( dotValue, 27.0 ), 0.0, 1.0);\n&quot; + &quot;     }\n&quot; + &quot;     float ambient = 0.1;\n&quot; + &quot;     vec3 surfaceColor;\n&quot; + &quot;     if(hasDiffuseTexture)\n&quot; + &quot;     {\n&quot; + &quot;         surfaceColor = texture2D( diffuseTexture, varTexCoord ).xyz;\n&quot; + &quot;     }\n&quot; + &quot;     else if(color.w != 0.0)\n&quot; + &quot;     {\n&quot; + &quot;         surfaceColor = color.xyz;\n&quot; + &quot;     }\n&quot; + &quot;     else\n&quot; + &quot;     {\n&quot; + &quot;         surfaceColor = diffuseColor;\n&quot; + &quot;     }\n&quot; + &quot;     gl_FragColor = clamp(vec4( emissiveColor + ( diffuse + ambient ) * surfaceColor + 0.4 * vec3( specular ), 1.0 ), 0.0, 1.0);\n&quot; + &quot;   }\n&quot; + &quot;   else {\n&quot; + &quot;     gl_FragColor = vec4( emissiveColor, 1.0 );\n&quot; + &quot;   }\n&quot; + &quot;}&quot;;

            this._uniforms = [
                new pre.UniformShaderVariable(&quot;mMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;nMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;vMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;pMatrix&quot;, pre.ResourceType.mat4f, 1 /* VERTEX */),
                new pre.UniformShaderVariable(&quot;vMatrixInv&quot;, pre.ResourceType.mat4f, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;lights&quot;, pre.ResourceType.vec4f, 2 /* FRAGMENT */, null, -1, _NUM_LIGHTS * _LIGHTS_STRIDE),
                new pre.UniformShaderVariable(&quot;clipPlaneEnabledStates&quot;, pre.ResourceType.FLOAT_32, 2 /* FRAGMENT */, null, -1, _NUM_CLIPPLANES),
                new pre.UniformShaderVariable(&quot;clipPlaneDefinitions&quot;, pre.ResourceType.vec4f, 2 /* FRAGMENT */, null, -1, _NUM_CLIPPLANES),
                new pre.UniformShaderVariable(&quot;diffuseTexture&quot;, pre.ResourceType.sampler2D, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;diffuseColor&quot;, pre.ResourceType.vec3f, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;emissiveColor&quot;, pre.ResourceType.vec3f, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;hasDiffuseTexture&quot;, pre.ResourceType.bool, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;lightingEnabled&quot;, pre.ResourceType.bool, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;subMeshIDOffset&quot;, pre.ResourceType.INT_32, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;partsEnabledTexture&quot;, pre.ResourceType.sampler2D, 2 /* FRAGMENT */),
                new pre.UniformShaderVariable(&quot;partsColorTexture&quot;, pre.ResourceType.sampler2D, 2 /* FRAGMENT */)
            ];

            this._attributes = [
                new pre.AttributeLocation(&quot;position&quot;),
                new pre.AttributeLocation(&quot;normal&quot;),
                new pre.AttributeLocation(&quot;id&quot;),
                new pre.AttributeLocation(&quot;texcoord&quot;)
            ];

            this._varyings = [
                new pre.VaryingShaderVariable(&quot;color&quot;, pre.ResourceType.vec4f),
                new pre.VaryingShaderVariable(&quot;varNormal&quot;, pre.ResourceType.vec3f),
                new pre.VaryingShaderVariable(&quot;varPosition&quot;, pre.ResourceType.vec3f),
                new pre.VaryingShaderVariable(&quot;varTexCoord&quot;, pre.ResourceType.vec2f)
            ];
        }
        return UberShader;
    })(pre.ShaderDescriptorBase);
    pre.UberShader = UberShader;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var AbstractRenderPass = (function (_super) {
        __extends(AbstractRenderPass, _super);
        function AbstractRenderPass(application) {
            _super.call(this, application);
            this._renderer = null;
            this._renderState = null;
            this._bindingManager = null;
            this._renderTarget = null;
            this._shaderService = null;
            this._objectCatalog = null;
            this._stats = null;
            this._resources = null;
            this._nextDrawableIdx = 0;
            var env = pre.Environment.getInstance();

            this._shaderService = env.getShaderService();
            this._objectCatalog = env.getObjectCatalog();
            this._stats = util.Statistics.getInstance();
            this._resources = new pre.ResourceContainer();

            this._renderer = this._application.getDefaultRenderer();
            this._bindingManager = this._renderer.getBindingManager();

            var that = this;

            this._inputSlots[&quot;drawables&quot;] = new pre.MultiSlot(&quot;drawables&quot;);

            this._outputSlots[&quot;drawables&quot;] = new pre.Slot(&quot;drawables&quot;, pre.ObjectResource.Create(that._drawables));

            this._outputSlots[&quot;renderTarget&quot;] = new pre.Slot(&quot;renderTarget&quot;, null);
        }
        AbstractRenderPass.prototype._render = function () {
            for (; this._nextDrawableIdx &lt; this._drawables.length; ++this._nextDrawableIdx) {
                this._renderDrawable(this._drawables[this._nextDrawableIdx]);
            }
        };

        AbstractRenderPass.prototype._renderDrawable = function (drawable) {
        };

        AbstractRenderPass.prototype.getRenderer = function () {
            return this._renderer;
        };

        AbstractRenderPass.prototype.setRenderer = function (renderer) {
            this._renderer = renderer;
        };

        AbstractRenderPass.prototype.getRenderTarget = function () {
            return this._renderTarget ? this._renderTarget : this._context.getRenderTarget();
        };

        AbstractRenderPass.prototype.setRenderTarget = function (renderTarget) {
            this._renderTarget = renderTarget;
            this._outputSlots[&quot;renderTarget&quot;] = new pre.Slot(&quot;renderTarget&quot;, pre.ObjectResource.Create(this._renderTarget));
        };

        AbstractRenderPass.prototype._execute = function (clearFrame) {
            if (!clearFrame &amp;&amp; this._nextDrawableIdx &gt;= this._drawables.length) {
                return;
            }
            this._setupStatesAndBindings();
            this._bindRenderTarget();
            if (clearFrame) {
                this._clearRenderTarget();
                this._nextDrawableIdx = 0;
                this._outputSlots[&quot;drawables&quot;].getResource().setDirty();
            }

            this._render();

            this._unbindRenderTarget();

            this.getRenderTarget().setDirty();
        };

        AbstractRenderPass.prototype._setupStatesAndBindings = function () {
            this._context.setupStates(this._getRenderState(), this._renderer.getStateManager());
            this._context.setupBindings(this._bindingManager);
        };

        AbstractRenderPass.prototype._bindRenderTarget = function () {
            this.getRenderTarget().bind(this._renderer);
        };

        AbstractRenderPass.prototype._unbindRenderTarget = function () {
            if (this._renderTarget != null) {
                this._renderTarget.unbind(this._renderer);
            } else {
                this._context.getRenderTarget().unbind(this._renderer);
            }
        };

        AbstractRenderPass.prototype._clearRenderTarget = function () {
            return this._context.clear(this._renderer.getStateManager(), this._renderTarget ? this._renderTarget : this._context.getRenderTarget());
        };

        AbstractRenderPass.prototype._collectInputDrawables = function (clearFrame, limit) {
            if (typeof limit === &quot;undefined&quot;) { limit = Number.POSITIVE_INFINITY; }
            if (clearFrame) {
                this._drawables.length = 0;
            }

            var count = 0;
            var slots = this._inputSlots[&quot;drawables&quot;].getSlots();
            var processed = 0, data = null, i, n;

            slots.forEach(function (slot) {
                data = slot.getResource().getData();
                processed = clearFrame ? 0 : slot.getProcessedCount();

                for (i = processed, n = data.length; count &lt; limit &amp;&amp; i &lt; n; i++) {
                    this._collectDrawable(data[i]);
                    count++;
                }

                slot.processed(i);
            }, this);
        };

        AbstractRenderPass.prototype._collectDrawable = function (drawable) {
            this._drawables.push(drawable);
        };

        AbstractRenderPass.prototype._getRenderState = function () {
            return this._renderState ? this._renderState : this._context.getRenderState();
        };

        AbstractRenderPass.prototype._bindShaderProgram = function (programID) {
            this._bindingManager.bindShaderProgram(this._shaderService.getShaderProgram(programID));
        };

        AbstractRenderPass.prototype._bindAppearance = function (appearanceID) {
            this._bindingManager.bindResourceContainer(this._objectCatalog.getAppearanceDescriptor(appearanceID), 3 /* APPEARANCE */);
        };

        AbstractRenderPass.prototype.attachResource = function (name, resource) {
            this._resources.attachResource(name, resource);
        };

        AbstractRenderPass.prototype.setRenderState = function (renderState) {
            this._renderState = renderState;
        };
        return AbstractRenderPass;
    })(pre.PipelineStage);
    pre.AbstractRenderPass = AbstractRenderPass;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var BoxVolumeRenderPass = (function (_super) {
        __extends(BoxVolumeRenderPass, _super);
        function BoxVolumeRenderPass(application) {
            _super.call(this, application);
            this._boxVolumeShaderId = -1;
            this._primitiveType = pre.PrimitiveType.LINES;
            this._bvDrawable = null;
            this._bvDrawableDesc = null;
            this._bvLinesForm = null;
            this._bvTrianglesForm = null;
            this._bvAppDesc = null;
            this._bvLinesGeoDesc = null;
            this._bvTrianglesGeoDesc = null;
            this._matrixResource = null;
            this._matrix = null;
            this._colorResource = null;
            this._color = null;
            this._matrixArray = [];
            this._colorArray = [];
            this._currentMatrixCount = 0;
            this._isDebugPass = false;

            var that = this;

            this._bvLinesGeoDesc = new pre.GeometryDescriptor();
            util.BasicShapes.AddBoxLinesToDescriptor(this._bvLinesGeoDesc);

            this._bvTrianglesGeoDesc = new pre.GeometryDescriptor();
            util.BasicShapes.AddBoxToDescriptor(this._bvTrianglesGeoDesc);

            this._bvLinesForm = new pre.Form(this._bvLinesGeoDesc, this._bvAppDesc);
            this._bvTrianglesForm = new pre.Form(this._bvTrianglesGeoDesc, this._bvAppDesc);

            this._bvDrawableDesc = new pre.DrawableDescriptor();

            this._matrix = mat4.create();
            this._matrixResource = pre.Resource.CreateLazy(pre.ResourceType.mat4f, function (callback) {
                return that._matrix;
            });

            this._color = vec4.fromValues(0.0, 1.0, 0.0, 1.0);
            this._colorResource = pre.Resource.CreateLazy(pre.ResourceType.vec4f, function (callback) {
                return that._color;
            });

            this._bvDrawableDesc.attachResource(&quot;mMatrix&quot;, this._matrixResource);
            this._bvDrawableDesc.attachResource(&quot;color&quot;, this._colorResource);

            this._bvDrawable = new pre.Drawable(this._bvDrawableDesc, this._bvLinesForm, new pre.RenderTreeNode(application));

            var i, n;
            for (i = 0, n = 100; i &lt; n; ++i) {
                this._matrixArray.push(mat4.create());
                this._colorArray.push(vec4.fromValues(0.0, 1.0, 0.0, 1.0));
            }

            this._boxVolumeShaderId = this._shaderService.requestShaderProgram(new pre.BoxVolumeShader(), this._application);

            this._triggers = [
                0 /* FULL */,
                4 /* APPEARANCE_CHANGED */,
                3 /* GEOMETRY_CHANGED */,
                6 /* NODES_CHANGED */,
                5 /* VIEW_CHANGED */
            ];
        }
        BoxVolumeRenderPass.prototype._collectDrawable = function (drawable) {
            this.addBoxVolume(drawable.getWorldVolume());
        };

        BoxVolumeRenderPass.prototype._execute = function (clearFrame) {
            this._stats.startMeasurement(&quot;BOXVOLUMES&quot;);

            if ((!this._isDebugPass || this._application.getSettings().showDebugVolumes)) {
                this._collectInputDrawables(clearFrame);

                if (this._currentMatrixCount &gt; 0) {
                    _super.prototype._execute.call(this, clearFrame);
                }
            }
            this._currentMatrixCount = 0;
            this._stats.stopMeasurement(&quot;BOXVOLUMES&quot;);
        };

        BoxVolumeRenderPass.prototype._checkResize = function () {
            if (this._currentMatrixCount == this._matrixArray.length) {
                var i, n;
                for (i = 0, n = this._currentMatrixCount / 2; i &lt; n; ++i) {
                    this._matrixArray.push(mat4.create());
                    this._colorArray.push(vec4.fromValues(0.0, 1.0, 0.0, 1.0));
                }
            }
        };

        BoxVolumeRenderPass.prototype.addBoxVolume = function (volume, color) {
            if (typeof color === &quot;undefined&quot;) { color = null; }
            this._checkResize();

            var mMatrix = this._matrixArray[this._currentMatrixCount];

            var col = this._colorArray[this._currentMatrixCount];
            vec4.copy(col, color == null ? vec4.fromValues(0, 1, 0, 1) : color);

            mat4.identity(mMatrix);
            mat4.translate(mMatrix, mMatrix, volume.getCenter());
            mat4.scale(mMatrix, mMatrix, volume.getRadialVec());

            this._currentMatrixCount++;
        };

        BoxVolumeRenderPass.prototype.addMatrix = function (matrix, color) {
            if (typeof color === &quot;undefined&quot;) { color = null; }
            this._checkResize();

            var mMatrix = this._matrixArray[this._currentMatrixCount];
            mat4.copy(mMatrix, matrix);

            var col = this._colorArray[this._currentMatrixCount];
            vec4.copy(col, color == null ? vec4.fromValues(0, 1, 0, 1) : color);

            this._currentMatrixCount++;
        };

        BoxVolumeRenderPass.prototype._render = function () {
            this._bindingManager.bindShaderProgram(this._shaderService.getShaderProgram(this._boxVolumeShaderId));
            this._bvDrawable.setForm(this._primitiveType == pre.PrimitiveType.LINES ? this._bvLinesForm : this._bvTrianglesForm);

            var i, n;
            for (i = 0, n = this._currentMatrixCount; i &lt; n; ++i) {
                this._matrix = this._matrixArray[i];
                this._color = this._colorArray[i];

                this._matrixResource.setDirty();
                this._colorResource.setDirty();

                this._bvDrawable.draw(this._renderer);
            }
        };

        BoxVolumeRenderPass.prototype.setBoxVolumePrimitiveType = function (type) {
            this._primitiveType = type;
        };

        BoxVolumeRenderPass.prototype.setDebugPass = function (dbgPass) {
            this._isDebugPass = dbgPass;
        };
        return BoxVolumeRenderPass;
    })(pre.AbstractRenderPass);
    pre.BoxVolumeRenderPass = BoxVolumeRenderPass;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var LinkedDrawableList = (function () {
        function LinkedDrawableList() {
            this.last = null;
        }
        return LinkedDrawableList;
    })();
    pre.LinkedDrawableList = LinkedDrawableList;

    var DrawMap = (function () {
        function DrawMap() {
            this._linkedDrawableLists = [];
            this._priorityKeys = [];
            this._programIDs = [];
            this._appearanceIDs = [];
            this._multiDimSortedLists = [];
            this._firstBin = 0;
            this._maxBin = 9;
            this._stats = null;
            this._settings = null;
            this._renderTarget = null;
            this._shaderService = null;
            this._objectCatalog = null;
            this._nextPrioIdx = -1;
            this._nextProgramIdx = 0;
            this._nextAppIdx = 0;
            this._lastDrawable = null;
            this._stats = util.Statistics.getInstance();

            for (var i = 0; i &lt;= this._maxBin; i++) {
                this._registerPriorityKey(i);
                this._stats.addValue(&quot;BIN &quot; + i, 0, DrawMap.statisticsGroupName);
            }

            var env = pre.Environment.getInstance();
            this._shaderService = env.getShaderService();
            this._objectCatalog = env.getObjectCatalog();
        }
        DrawMap.prototype._calculateBinIndex = function (drawingInfo) {
            return this._maxBin - Math.min(this._maxBin, Math.round(this._maxBin * (Math.max(drawingInfo.screenSpaceFootPrint - this._settings.smallFeatureTreshold, 0))));
        };

        DrawMap.prototype._registerPriorityKey = function (userSortKey) {
            if (typeof this._multiDimSortedLists[userSortKey] === 'undefined') {
                this._priorityKeys.push(userSortKey);
                var userSortKeyIdx = this._priorityKeys.length - 1;

                var map = [];
                this._multiDimSortedLists[userSortKeyIdx] = map;

                for (var i = 0; i &lt; this._programIDs.length; ++i) {
                    var programArray = [];
                    map[i] = programArray;

                    for (var j = 0; j &lt; this._appearanceIDs.length; ++j) {
                        var linkedList = new LinkedDrawableList();
                        this._linkedDrawableLists.push(linkedList);
                        programArray.push(linkedList);
                    }
                }
            } else {
                console.log(&quot;Error: userSortKey :&quot; + userSortKey + &quot; already defined in Drawmap!&quot;);
            }
        };

        DrawMap.prototype._registerProgramID = function (programID) {
            var idx, i, j;
            if ((idx = this._programIDs.indexOf(programID)) == -1) {
                idx = this._programIDs.push(programID) - 1;

                for (i = 0; i &lt; this._priorityKeys.length; ++i) {
                    var key = this._priorityKeys[i];

                    if (this._multiDimSortedLists[key].length == idx) {
                        var array = [];
                        this._multiDimSortedLists[key].push(array);

                        for (j = 0; j &lt; this._appearanceIDs.length; ++j) {
                            var linkedList = new LinkedDrawableList();
                            this._linkedDrawableLists.push(linkedList);
                            array.push(linkedList);
                        }
                    }
                }
            }
            return idx;
        };

        DrawMap.prototype._registerAppearanceID = function (apperanceID) {
            var idx, i, j;
            if ((idx = this._appearanceIDs.indexOf(apperanceID)) == -1) {
                this._appearanceIDs.push(apperanceID);

                for (i = 0; i &lt; this._priorityKeys.length; ++i) {
                    for (j = 0; j &lt; this._programIDs.length; ++j) {
                        var linkedList = new LinkedDrawableList();
                        this._linkedDrawableLists.push(linkedList);
                        this._multiDimSortedLists[i][j].push(linkedList);
                    }
                }

                return this._appearanceIDs.length - 1;
            }
            return idx;
        };

        DrawMap.prototype.setup = function (settings, renderTarget) {
            this._settings = settings;
            this._renderTarget = renderTarget;
        };

        DrawMap.prototype.insertDrawable = function (drawable) {
            this._stats.startMeasurement(&quot;INSERT&quot;);

            var drawingInfo = drawable.getDrawingInfo();

            var binIndex = this._calculateBinIndex(drawingInfo);

            this._stats.addValue(&quot;BIN &quot; + binIndex, 1, DrawMap.statisticsGroupName);

            if (binIndex &lt; this._firstBin) {
                this._firstBin = binIndex;
            }

            if (drawingInfo.programIDIdx == -1) {
                drawingInfo.programIDIdx = this._registerProgramID(drawingInfo.programID);
            }

            var currentClass = drawable.getForm().getAppearanceDescriptor().getClassID();
            if (drawingInfo.appearanceClass != currentClass || drawingInfo.appearanceIDIdx == -1) {
                drawingInfo.appearanceClass = currentClass;
                drawingInfo.appearanceIDIdx = this._registerAppearanceID(currentClass);
            }

            if (!this._multiDimSortedLists[binIndex]) {
            } else {
                var lList = this._multiDimSortedLists[binIndex][drawingInfo.programIDIdx][drawingInfo.appearanceIDIdx];

                drawable._prev = lList.last;
                lList.last = drawable;
            }
            this._stats.stopMeasurement(&quot;INSERT&quot;);
        };

        DrawMap.prototype.clear = function () {
            for (var i = 0; i &lt; this._linkedDrawableLists.length; ++i) {
                this._linkedDrawableLists[i].last = null;
            }

            this._firstBin = this._maxBin;

            this._nextPrioIdx = 0;
            this._nextProgramIdx = 0;
            this._nextAppIdx = 0;
            this._lastDrawable = null;
        };

        DrawMap.prototype.render = function (drawCount, renderer, callback) {
            var bindingManager = renderer.getBindingManager();

            var counter = 0;

            var priorityIdx = Math.max(this._nextPrioIdx, this._firstBin), priorityKeysCount = this._priorityKeys.length, programIdx, programCount = this._programIDs.length, appearanceIdx, appearanceCount = this._appearanceIDs.length, stats = util.Statistics.getInstance();

            stats.addValue(&quot;TP: &quot;, Math.round(drawCount * 100) / 100, DrawMap.statisticsGroupName);

            for (; priorityIdx &lt; priorityKeysCount; ++priorityIdx) {
                this._nextPrioIdx = priorityIdx;

                var priorityKeyMap = this._multiDimSortedLists[priorityIdx];

                for (programIdx = this._nextProgramIdx; programIdx &lt; programCount; ++programIdx) {
                    this._nextProgramIdx = programIdx;

                    bindingManager.bindShaderProgram(this._shaderService.getShaderProgram(this._programIDs[programIdx]));
                    var programIDMap = priorityKeyMap[programIdx];

                    for (appearanceIdx = this._nextAppIdx; appearanceIdx &lt; appearanceCount; ++appearanceIdx) {
                        this._nextAppIdx = appearanceIdx;
                        var drawable = (this._lastDrawable) ? this._lastDrawable._prev : programIDMap[appearanceIdx].last;

                        if (drawable != null) {
                            bindingManager.bindResourceContainer(this._objectCatalog.getAppearanceDescriptor(this._appearanceIDs[appearanceIdx]), 3 /* APPEARANCE */);
                        }

                        while (drawable != null) {
                            this._lastDrawable = drawable;
                            drawable.draw(renderer);

                            if (callback) {
                                callback(drawable);
                            }

                            counter++;
                            if (counter &gt;= drawCount) {
                                return;
                            }

                            drawable = drawable._prev;
                        }
                        this._lastDrawable = null;
                    }
                    this._nextAppIdx = 0;
                }
                this._nextProgramIdx = 0;
            }
            this._nextPrioIdx = 0;
        };
        DrawMap.statisticsGroupName = &quot;DRAWMAP&quot;;
        return DrawMap;
    })();
    pre.DrawMap = DrawMap;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var DrawMapRenderPass = (function (_super) {
        __extends(DrawMapRenderPass, _super);
        function DrawMapRenderPass(application) {
            _super.call(this, application);
            this._drawMap = new pre.DrawMap();
            this._settings = null;
            this._drawablesInMap = 0;
            this._triggers = [
                0 /* FULL */,
                4 /* APPEARANCE_CHANGED */,
                3 /* GEOMETRY_CHANGED */,
                6 /* NODES_CHANGED */,
                5 /* VIEW_CHANGED */,
                7 /* SCREENSHOT */
            ];
        }
        DrawMapRenderPass.prototype._collectDrawable = function (drawable) {
            var statsGroup = util.Statistics.getInstance().getValueGroups()[pre.DrawMap.statisticsGroupName];
            if (statsGroup.frameID &lt; this._context.getApplication().getSettings().frameId) {
                statsGroup.clear(this._context.getApplication().getSettings().frameId);
            }

            var drawingInfo = drawable.getDrawingInfo();

            if (drawingInfo.programID == -1) {
                drawingInfo.programID = this._shaderService.requestShaderForDrawable(drawable);
            }

            this._drawMap.insertDrawable(drawable);
            this._drawablesInMap++;
        };

        DrawMapRenderPass.prototype._execute = function (clearFrame) {
            var stats = util.Statistics.getInstance();
            stats.startMeasurement(&quot;RENDER&quot;);

            this._settings = this._context.getApplication().getSettings();
            if (clearFrame) {
                this._drawMap.clear();
                this._drawablesInMap = 0;
                this._drawables.length = 0;
                stats.addValue(&quot;TP: &quot;, 0, pre.DrawMap.statisticsGroupName);

                this._drawMap.setup(this._application.getSettings(), this.getRenderTarget());
                this._collectInputDrawables(clearFrame);
            }

            if (this._drawablesInMap &gt; this._drawables.length || clearFrame) {
                _super.prototype._execute.call(this, clearFrame);
            }

            stats.stopMeasurement(&quot;RENDER&quot;);
        };

        DrawMapRenderPass.prototype._render = function () {
            var that = this;

            this._drawMap.render(this._settings.getLimit(this._pipelineControl.isNavigating()), this._renderer, function (drawable) {
                that._drawables.push(drawable);
            });

            this.getRenderTarget().setDirty();
        };
        return DrawMapRenderPass;
    })(pre.AbstractRenderPass);
    pre.DrawMapRenderPass = DrawMapRenderPass;
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (PickMode) {
        PickMode[PickMode[&quot;ID&quot;] = 0] = &quot;ID&quot;;
        PickMode[PickMode[&quot;POINT&quot;] = 1] = &quot;POINT&quot;;
    })(pre.PickMode || (pre.PickMode = {}));
    var PickMode = pre.PickMode;

    var PickingRenderPass = (function (_super) {
        __extends(PickingRenderPass, _super);
        function PickingRenderPass(application, pickMode) {
            _super.call(this, application);
            this._pickingShaderID = -1;
            this._pickMode = new Int32Array([1 /* POINT */]);
            this._pickMode[0] = pickMode;
            this._pickModeRes = pre.Resource.Create(pre.ResourceType.INT_32, this._pickMode);
            this._pickModeRes.setDirty();

            var rt = application.getCanvasViews()[0].getHTMLCanvasRenderTarget();
            this._renderTarget = new renderer.FrameBufferRenderTarget(rt.getWidth(), rt.getHeight());
            pre.Environment.getInstance().addRenderTarget(this._application.getIdentifier() + &quot;_RT_&quot; + (this._pickMode[0] == 1 /* POINT */ ? &quot;POINT&quot; : &quot;ID&quot;), this._renderTarget);

            this._application.getPicker().setPickingBuffer(this._pickMode[0], this._renderTarget);

            this._pickingShaderID = this._shaderService.requestShaderProgram(new pre.PickingShader(), this._application);

            this._triggers = [
                0 /* FULL */,
                3 /* GEOMETRY_CHANGED */,
                6 /* NODES_CHANGED */,
                5 /* VIEW_CHANGED */
            ];
        }
        PickingRenderPass.prototype._setPickingColor = function (drawableDescriptor, inputID) {
            var drawID = inputID + 1;
            var r = ((drawID &gt;&gt;&gt; 24) &amp; 255) / 255.0;
            var g = ((drawID &gt;&gt;&gt; 16) &amp; 255) / 255.0;
            var b = ((drawID &gt;&gt;&gt; 8) &amp; 255) / 255.0;
            var a = (drawID &amp; 255) / 255.0;

            var pickingColor = drawableDescriptor.getResources()[&quot;pickingColor&quot;];

            if (!pickingColor) {
                drawableDescriptor.attachResource(&quot;pickingColor&quot;, pre.Resource.Create(pre.ResourceType.vec4f, new Float32Array([r, g, b, a])));
            } else {
                var data = pickingColor.getData();
                data[0] = r;
                data[1] = g;
                data[2] = b;
                data[3] = a;
                pickingColor.setDirty();
            }
        };

        PickingRenderPass.prototype._setBoundingBox = function (drawableDescriptor, volume) {
            var bbMin = drawableDescriptor.getResources()[&quot;bbMin&quot;];
            var bbMax = drawableDescriptor.getResources()[&quot;bbMax&quot;];

            if (!bbMin || !bbMax) {
                drawableDescriptor.attachResource(&quot;bbMin&quot;, pre.Resource.Create(pre.ResourceType.vec3f, volume.getMin()));
                drawableDescriptor.attachResource(&quot;bbMax&quot;, pre.Resource.Create(pre.ResourceType.vec3f, volume.getMax()));
            } else {
                bbMin.getData().set(volume.getMin());
                bbMax.getData().set(volume.getMax());
                bbMin.setDirty();
                bbMax.setDirty();
            }
        };

        PickingRenderPass.prototype._execute = function (clearFrame) {
            if (!this._pipelineControl.isNavigating() &amp;&amp; !this._shaderService.isFallbackShader(this._pickingShaderID)) {
                this._stats.startMeasurement(&quot;PICKING RENDER&quot;);

                this._collectInputDrawables(clearFrame, this._application.getSettings().getLimit(this._pipelineControl.isNavigating()));

                _super.prototype._execute.call(this, clearFrame);

                this._stats.stopMeasurement(&quot;PICKING RENDER&quot;);
            }
        };

        PickingRenderPass.prototype._render = function () {
            this._bindingManager.setGlobalShaderParam(&quot;pickMode&quot;, this._pickModeRes);
            this._bindingManager.bindShaderProgram(this._shaderService.getShaderProgram(this._pickingShaderID));

            _super.prototype._render.call(this);

            this._bindingManager.unsetGlobalShaderParam(&quot;pickMode&quot;);
        };

        PickingRenderPass.prototype._renderDrawable = function (drawable) {
            this._setPickingColor(drawable.getDrawableDescriptor(), drawable.getID());
            if (this._pickMode[0] == 1 /* POINT */) {
                this._setBoundingBox(drawable.getDrawableDescriptor(), drawable.getWorldVolume());
            }
            drawable.draw(this._renderer);
        };

        PickingRenderPass.prototype.setPickMode = function (pickMode) {
        };

        PickingRenderPass.prototype._collectDrawable = function (drawable) {
            if (!drawable.isPickable()) {
                return;
            }

            this._drawables.push(drawable);
        };
        return PickingRenderPass;
    })(pre.AbstractRenderPass);
    pre.PickingRenderPass = PickingRenderPass;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var PostProRenderPass = (function (_super) {
        __extends(PostProRenderPass, _super);
        function PostProRenderPass(application, shaderDescriptor) {
            _super.call(this, application);
            this._shaderDescriptor = null;
            this._shaderProgramID = -1;
            this._inverserViewPortSizeResource = null;
            this._shaderDescriptor = shaderDescriptor;
            this._shaderProgramID = this._shaderService.requestShaderProgram(this._shaderDescriptor, this._application);

            this._triggers = [
                0 /* FULL */,
                4 /* APPEARANCE_CHANGED */,
                3 /* GEOMETRY_CHANGED */,
                6 /* NODES_CHANGED */,
                5 /* VIEW_CHANGED */,
                7 /* SCREENSHOT */
            ];

            if (PostProRenderPass._geometryDescriptor == null) {
                PostProRenderPass._createGeometryDescriptor();
            }

            this._inverserViewPortSizeResource = pre.Resource.Create(pre.ResourceType.vec2i, new Float32Array([0, 0]));
            this._resources.attachResource(&quot;inverseViewportSize&quot;, this._inverserViewPortSizeResource);
        }
        PostProRenderPass._createGeometryDescriptor = function () {
            var positions = new pre.BufferResource(pre.ResourceType.FLOAT_32, function (callback) {
                return new Float32Array([
                    -1, -1,
                    3, -1,
                    -1, 3
                ]);
            }, 2, false, 0, 0);

            PostProRenderPass._geometryDescriptor = new pre.GeometryDescriptor();
            PostProRenderPass._geometryDescriptor.attachResource(&quot;position&quot;, positions);
            PostProRenderPass._geometryDescriptor.setNumElements(3);
            PostProRenderPass._geometryDescriptor.setPrimitiveType(pre.PrimitiveType.TRIANGLES);
        };

        PostProRenderPass.prototype._execute = function (clearFrame) {
            var stats = util.Statistics.getInstance();
            stats.startMeasurement(&quot;POSTPRO&quot;);

            _super.prototype._execute.call(this, clearFrame);

            stats.stopMeasurement(&quot;POSTPRO&quot;);
        };

        PostProRenderPass.prototype._render = function () {
            var renderTarget = this.getRenderTarget();

            this._inverserViewPortSizeResource.getData()[0] = 1 / renderTarget.getWidth();
            this._inverserViewPortSizeResource.getData()[1] = 1 / renderTarget.getHeight();
            this._inverserViewPortSizeResource.setDirty(true);

            this._bindingManager.bindShaderProgram(this._shaderService.getShaderProgram(this._shaderProgramID));
            this._bindingManager.bindResourceContainer(this._resources, 2 /* PASS */);
            PostProRenderPass._geometryDescriptor.prepare(this._bindingManager);
            PostProRenderPass._geometryDescriptor.draw(this._renderer);
        };
        PostProRenderPass._geometryDescriptor = null;
        return PostProRenderPass;
    })(pre.AbstractRenderPass);
    pre.PostProRenderPass = PostProRenderPass;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var SimpleRenderPass = (function (_super) {
        __extends(SimpleRenderPass, _super);
        function SimpleRenderPass(application) {
            _super.call(this, application);
            this._triggers = [
                0 /* FULL */,
                4 /* APPEARANCE_CHANGED */,
                3 /* GEOMETRY_CHANGED */,
                6 /* NODES_CHANGED */,
                5 /* VIEW_CHANGED */,
                7 /* SCREENSHOT */
            ];
        }
        SimpleRenderPass.prototype._collectDrawable = function (drawable) {
            var drawingInfo = drawable.getDrawingInfo();

            if (drawingInfo.programID == -1) {
                drawingInfo.programID = this._shaderService.requestShaderForDrawable(drawable);
            }

            var currentClass = drawable.getForm().getAppearanceDescriptor().getClassID();
            if (drawingInfo.appearanceClass != currentClass) {
                drawingInfo.appearanceClass = currentClass;
            }

            this._drawables.push(drawable);
        };

        SimpleRenderPass.prototype._execute = function (clearFrame) {
            var stats = util.Statistics.getInstance();
            stats.startMeasurement(&quot;RENDER&quot;);

            this._collectInputDrawables(clearFrame, this._application.getSettings().getLimit(this._pipelineControl.isNavigating()));

            _super.prototype._execute.call(this, clearFrame);

            stats.stopMeasurement(&quot;RENDER&quot;);
        };

        SimpleRenderPass.prototype._renderDrawable = function (drawable) {
            this._bindShaderProgram(drawable.getDrawingInfo().programID);
            this._bindAppearance(drawable.getDrawingInfo().appearanceClass);
            drawable.draw(this._renderer);
        };
        return SimpleRenderPass;
    })(pre.AbstractRenderPass);
    pre.SimpleRenderPass = SimpleRenderPass;
})(pre || (pre = {}));

var renderer;
(function (renderer) {
    var ShaderBounds = (function () {
        function ShaderBounds() {
            this.uniforms = [];
            this.uniformVersions = [];
            this.textures = [];
            this.texturesReverseMap = [];
            this.vertexAttribPointers = [];
        }
        return ShaderBounds;
    })();

    var GlobalBounds = (function () {
        function GlobalBounds() {
            this.viewport = [0, 0, 0, 0];
            this.index = -1;
            this.indexVersion = -1;
            this.attributes = [];
            this.attributeVersions = [];
            this.enabledAttribArrays = [];
        }
        return GlobalBounds;
    })();

    var BindingManager = (function () {
        function BindingManager(memoryManager, gl) {
            this._globalShaderParams = new pre.ResourceContainer();
            this._glTextures = [];
            this._textureLRUQueue = [];
            this._textureLRUReverseMap = [];
            this._shaderBounds = [];
            this._gl = null;
            this._boundGlobal = new GlobalBounds();
            this._memMan = memoryManager;

            this._gl = gl;
            this._textureEnumOffset = gl.TEXTURE0;
            this._maxTextureSlots = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            this._freeTextureSlots = this._maxTextureSlots;
        }
        BindingManager.prototype.bindResource = function (uniformVariable, resource) {
            if (this._boundPerShader.uniforms[uniformVariable.id] == resource.getID() &amp;&amp; this._boundPerShader.uniformVersions[uniformVariable.id] == resource.getVersion()) {
                return;
            }
            var resourceContent = resource.getData();
            if (!resourceContent) {
                return;
            }
            switch (uniformVariable.type) {
                case pre.ResourceType.bool:
                case pre.ResourceType.INT_32:
                    this._gl.uniform1iv(uniformVariable.location, resourceContent);
                    break;
                case pre.ResourceType.FLOAT_32:
                    this._gl.uniform1fv(uniformVariable.location, resourceContent);
                    break;
                case pre.ResourceType.vec2i:
                    this._gl.uniform2iv(uniformVariable.location, resourceContent);
                    break;
                case pre.ResourceType.vec2f:
                    this._gl.uniform2fv(uniformVariable.location, resourceContent);
                    break;
                case pre.ResourceType.vec3i:
                    this._gl.uniform3iv(uniformVariable.location, resourceContent);
                    break;
                case pre.ResourceType.vec3f:
                    this._gl.uniform3fv(uniformVariable.location, resourceContent);
                    break;
                case pre.ResourceType.vec4i:
                    this._gl.uniform4iv(uniformVariable.location, resourceContent);
                    break;
                case pre.ResourceType.vec4f:
                    this._gl.uniform4fv(uniformVariable.location, resourceContent);
                    break;

                case pre.ResourceType.mat2f:
                    this._gl.uniformMatrix2fv(uniformVariable.location, false, resourceContent);
                    break;
                case pre.ResourceType.mat3f:
                    this._gl.uniformMatrix3fv(uniformVariable.location, false, resourceContent);
                    break;
                case pre.ResourceType.mat4f:
                    this._gl.uniformMatrix4fv(uniformVariable.location, false, resourceContent);
                    break;
                default:
                    console.error(&quot;Could not upload resource&quot;);
            }
            this._boundPerShader.uniforms[uniformVariable.id] = resource.getID();
            this._boundPerShader.uniformVersions[uniformVariable.id] = resource.getVersion();
        };

        BindingManager.prototype.bindBuffer = function (bufferDesc, target, progressive) {
            if (typeof progressive === &quot;undefined&quot;) { progressive = false; }
            var glBuffer = this._memMan.requestGPUBuffer(bufferDesc);

            if (glBuffer) {
                this._gl.bindBuffer(target, glBuffer);
                return this._memMan.syncData(bufferDesc, target, progressive);
            } else {
                util.Log.postInfo(&quot;Buffer skipped : not yet ready for upload&quot;);
                return null;
            }
        };

        BindingManager.prototype.bindTexture = function (uniformLocation, resource) {
            var textureData = resource.getData();
            if (!resource.isReady()) {
            }
            var textureID = resource.getID();
            var textureBindPosition = this._boundPerShader.texturesReverseMap[textureID];

            var glTexture = this._glTextures[textureID];
            if (!glTexture) {
                glTexture = this._gl.createTexture();
                this._glTextures[textureID] = glTexture;
            }

            if (textureBindPosition == null || this._boundPerShader.uniforms[uniformLocation.id] != textureID || this._boundPerShader.uniformVersions[uniformLocation.id] != resource.getVersion()) {
                if (textureBindPosition == null) {
                    if (this._freeTextureSlots &gt; 0) {
                        textureBindPosition = this._maxTextureSlots - this._freeTextureSlots;
                        this._freeTextureSlots--;
                    } else {
                        textureBindPosition = this._textureLRUQueue.shift();
                        var toReplaceTextureID = this._boundPerShader.textures[textureBindPosition];
                        this._boundPerShader.texturesReverseMap[toReplaceTextureID] = null;
                    }
                }

                this._gl.activeTexture(this._gl.TEXTURE0 + textureBindPosition);
                this._gl.uniform1i(uniformLocation.location, textureBindPosition);
                this._gl.bindTexture(this._gl.TEXTURE_2D, glTexture);

                if (textureData != null) {
                    if (resource.needsUnpackFlipY()) {
                        this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);
                    }
                    if (ArrayBuffer.isView(textureData)) {
                        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, resource.getInternalFormat(), resource.getWidth(), resource.getHeight(), 0, resource.getFormat(), resource.getDataType(), textureData);
                    } else {
                        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, resource.getInternalFormat(), resource.getFormat(), resource.getDataType(), textureData);
                    }

                    if (resource.needsUnpackFlipY()) {
                        this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 0);
                    }
                }

                 {
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, resource.getMinFilter());
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, resource.getMagFilter());
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, resource.getWrapS());
                    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, resource.getWrapT());
                }

                if (resource.needsMipMaps()) {
                    this._gl.generateMipmap(this._gl.TEXTURE_2D);
                }
                this._textureLRUQueue.push(textureBindPosition);
                this._textureLRUReverseMap[textureBindPosition] = this._textureLRUQueue.push(textureBindPosition) - 1;
                this._boundPerShader.textures[textureBindPosition] = textureID;
                this._boundPerShader.texturesReverseMap[textureID] = textureBindPosition;
            } else {
                this._gl.activeTexture(this._gl.TEXTURE0 + textureBindPosition);
                this._gl.uniform1i(uniformLocation.location, textureBindPosition);
                this._gl.bindTexture(this._gl.TEXTURE_2D, glTexture);
            }

            this._boundPerShader.uniforms[uniformLocation.id] = textureID;
            this._boundPerShader.uniformVersions[uniformLocation.id] = resource.getVersion();
        };

        BindingManager.prototype.bindResourceContainer = function (container, stage) {
            var currentShaderProgram = this._boundShader;

            var shaderLocations = currentShaderProgram.getShaderLocations(stage);
            for (var i = 0; i &lt; shaderLocations.length; i++) {
                var location = shaderLocations[i];
                var resource = container.requestResource(location.name);
                if (resource) {
                    if (location.type == pre.ResourceType.sampler2D) {
                        this.bindTexture(location, resource);
                    } else {
                        this.bindResource(location, resource);
                    }
                } else {
                    currentShaderProgram.setLocationBindStage(location, 0 /* UNCLASSIFIED */);
                }
            }

            var unclassifiedShaderLocations = currentShaderProgram.getShaderLocations(0 /* UNCLASSIFIED */);
            for (var i = 0; i &lt; unclassifiedShaderLocations.length; i++) {
                var location = unclassifiedShaderLocations[i];
                var resource = container.requestResource(location.name);
                if (resource) {
                    currentShaderProgram.setLocationBindStage(location, stage);
                    if (location.type == pre.ResourceType.sampler2D) {
                        this.bindTexture(location, resource);
                    } else {
                        this.bindResource(location, resource);
                    }
                    i--;
                } else {
                }
            }
        };

        BindingManager.prototype.bindFramebuffer = function (renderTarget) {
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, renderTarget.getFramebuffer());
        };

        BindingManager.prototype.unbindFramebuffer = function () {
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
        };

        BindingManager.prototype.bindViewport = function (renderTarget) {
            var width = renderTarget.getWidth();
            var height = renderTarget.getHeight();
            var bv = this._boundGlobal.viewport;
            if (height != bv[3] || width != bv[4]) {
                this._gl.viewport(0, 0, width, height);
                bv[3] = height;
                bv[4] = width;
            }
        };

        BindingManager.prototype.setGlobalShaderParam = function (name, resource) {
            this._globalShaderParams.attachResource(name, resource);
        };

        BindingManager.prototype.unsetGlobalShaderParam = function (name) {
            this._globalShaderParams.removeResource(name);
        };

        BindingManager.prototype.bindShaderProgram = function (program) {
            if (program == undefined) {
                console.log(program == undefined);
            }
            var id = program.getID();
            if (this._boundShader &amp;&amp; id == this._boundShader.getID()) {
                this.bindResourceContainer(this._globalShaderParams, 1 /* GLOBAL */);
                return false;
            }
            this._boundShader = program;
            this._boundPerShader = this._shaderBounds[id];
            if (!this._boundPerShader) {
                this._boundPerShader = new ShaderBounds();
                this._shaderBounds[id] = this._boundPerShader;
            }
            program.bind(this._gl);
            this.bindResourceContainer(this._globalShaderParams, 1 /* GLOBAL */);
            return true;
        };

        BindingManager.prototype.bindIndexBuffer = function (indexDesc, chunked) {
            if (typeof chunked === &quot;undefined&quot;) { chunked = false; }
            if (this._boundGlobal.index == indexDesc.getID() &amp;&amp; this._boundGlobal.indexVersion == indexDesc.getVersion()) {
                return;
            }
            this.bindBuffer(indexDesc, this._gl.ELEMENT_ARRAY_BUFFER, chunked);
            this._boundGlobal.index = indexDesc.getID();
            this._boundGlobal.indexVersion = indexDesc.getVersion();
        };

        BindingManager.prototype.bindAttributeBuffers = function (attributeBufferMap, chunked) {
            if (typeof chunked === &quot;undefined&quot;) { chunked = false; }
            var i;
            var n;

            var attributeLocations = this._boundShader.getAttributeLocations();
            for (i = 0, n = attributeLocations.length; i &lt; n; i++) {
                var attrLocDesc = attributeLocations[i];
                var bufferResource;
                if (!(bufferResource = attributeBufferMap[attrLocDesc.name])) {
                    if (this._boundGlobal.enabledAttribArrays[attrLocDesc.location] == 1) {
                        this._gl.disableVertexAttribArray(attrLocDesc.location);
                        this._boundGlobal.enabledAttribArrays[attrLocDesc.location] = 0;
                    }
                    continue;
                }

                var attribData;

                if (!(this._boundGlobal.attributes[attrLocDesc.location] == bufferResource.getID() &amp;&amp; this._boundGlobal.attributeVersions[attrLocDesc.location] == bufferResource.getVersion())) {
                    attribData = this.bindBuffer(bufferResource, this._gl.ARRAY_BUFFER, chunked);

                    if (attribData) {
                        this._boundGlobal.attributes[attrLocDesc.location] = bufferResource.getID();
                        this._boundGlobal.attributeVersions[attrLocDesc.location] = bufferResource.getVersion();
                        this._gl.vertexAttribPointer(attrLocDesc.location, bufferResource.getComponentCount(), bufferResource.getType(), bufferResource.getNormalize(), bufferResource.getStride(), bufferResource.getOffset() + attribData.offset);
                    }
                }
                if (!this._boundGlobal.enabledAttribArrays[attrLocDesc.location]) {
                    this._gl.enableVertexAttribArray(attrLocDesc.location);
                    this._boundGlobal.enabledAttribArrays[attrLocDesc.location] = 1;
                }
            }
        };

        BindingManager.prototype.setupFrameBufferRenderTarget = function (frameBufferRenderTarget) {
            var colorTextureResource = frameBufferRenderTarget.getTextureResource(0 /* COLOR_TARGET0 */);

            var framebuffer = this._gl.createFramebuffer();

            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);

            var texture = this._gl.createTexture();
            this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, colorTextureResource.getMagFilter());
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, colorTextureResource.getMinFilter());
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, colorTextureResource.getWrapS());
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, colorTextureResource.getWrapT());
            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, colorTextureResource.getWidth(), colorTextureResource.getHeight(), 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null);
            this._glTextures[colorTextureResource.getID()] = texture;

            this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, texture, 0);

            var depthTextureResource = frameBufferRenderTarget.getTextureResource(1 /* DEPTH_TARGET */);

            if (!depthTextureResource) {
                var renderbuffer = this._gl.createRenderbuffer();
                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderbuffer);
                this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_COMPONENT16, frameBufferRenderTarget.getWidth(), frameBufferRenderTarget.getHeight());
                this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.RENDERBUFFER, renderbuffer);
                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null);
            } else {
                var depthTexture = this._gl.createTexture();
                this._gl.bindTexture(this._gl.TEXTURE_2D, depthTexture);
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, depthTextureResource.getMagFilter());
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, depthTextureResource.getMinFilter());
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, depthTextureResource.getWrapS());
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, depthTextureResource.getWrapT());
                this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.DEPTH_COMPONENT, depthTextureResource.getWidth(), depthTextureResource.getHeight(), 0, this._gl.DEPTH_COMPONENT, this._gl.UNSIGNED_SHORT, null);

                this._glTextures[depthTextureResource.getID()] = depthTexture;

                this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, depthTexture, 0);
            }

            var frameBufferStatus = this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER);

            switch (frameBufferStatus) {
                case this._gl.FRAMEBUFFER_COMPLETE:
                    frameBufferRenderTarget.setFramebuffer(framebuffer);
                    break;
                case this._gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    util.Log.postWarning(&quot;Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT&quot;);
                    break;
                case this._gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    util.Log.postWarning(&quot;Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT&quot;);
                    break;
                case this._gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    util.Log.postWarning(&quot;Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS&quot;);
                    break;
                case this._gl.FRAMEBUFFER_UNSUPPORTED:
                    util.Log.postWarning(&quot;Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED&quot;);
                    break;
                default:
                    util.Log.postWarning(&quot;Incomplete framebuffer: &quot; + status);
            }

            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
            this._gl.bindTexture(this._gl.TEXTURE_2D, null);
        };
        return BindingManager;
    })();
    renderer.BindingManager = BindingManager;
})(renderer || (renderer = {}));
var renderer;
(function (_renderer) {
    var FrameBufferRenderTarget = (function () {
        function FrameBufferRenderTarget(width, height) {
            if (typeof width === &quot;undefined&quot;) { width = 256; }
            if (typeof height === &quot;undefined&quot;) { height = 256; }
            this._framebuffer = null;
            this._textureUsages = [];
            this._textureResources = [];
            this._pixelBufferResources = [];
            this._clearFrameId = -1;
            this._width = width;
            this._height = height;

            this._textureUsages.push(0 /* COLOR_TARGET0 */);
        }
        FrameBufferRenderTarget.prototype._initTextureResource = function () {
            var i = 0, n = this._textureUsages.length, resource = null;

            this._textureResources = [];
            for (; i &lt; n; ++i) {
                resource = pre.TextureResource.Create(pre.ResourceType.sampler2D, null);
                resource.setWidth(this._width);
                resource.setHeight(this._height);
                resource.setMagFilter(pre.FilterType.NEAREST);
                resource.setMinFilter(pre.FilterType.NEAREST);
                resource.setWrapS(pre.WrapType.CLAMP_TO_EDGE);
                resource.setWrapT(pre.WrapType.CLAMP_TO_EDGE);
                var format = this._textureUsages[i] == 1 /* DEPTH_TARGET */ ? pre.FormatType.LUMINANCE : pre.FormatType.RGBA;
                resource.setInternalFormat(format);
                resource.setFormat(format);
                resource.setDirty(false);
                resource.setReady(true);

                this._textureResources[i] = resource;
            }
        };

        FrameBufferRenderTarget.prototype.setDimensions = function (width, height) {
            this._width = width;
            this._height = height;
            if (this._framebuffer) {
                this._framebuffer = null;
            }
            var i = 0, n = this._textureResources.length;
            for (; i &lt; n; ++i) {
                this._textureResources[i].setWidth(this._width);
                this._textureResources[i].setHeight(this._height);
            }
        };

        FrameBufferRenderTarget.prototype.getUsages = function () {
            return this._textureUsages;
        };

        FrameBufferRenderTarget.prototype.bind = function (renderer) {
            var bindingManager = renderer.getBindingManager();
            if (this._textureResources.length == 0) {
                this._initTextureResource();
            }

            if (this._pixelBufferResources.length == 0) {
                this._initPixelBufferResources(renderer);
            }

            if (this._framebuffer == null) {
                bindingManager.setupFrameBufferRenderTarget(this);
            }
            if (this._framebuffer) {
                bindingManager.bindViewport(this);
                bindingManager.bindFramebuffer(this);
            }
        };

        FrameBufferRenderTarget.prototype._initPixelBufferResources = function (renderer) {
            var i = 0, n = this._textureUsages.length;

            for (; i &lt; n; ++i) {
                if (this._pixelBufferResources[i] == null) {
                    var pixelData = new Uint8Array(4 * this._width * this._height);

                    var that = this;
                    this._pixelBufferResources[i] = pre.Resource.CreateLazy(pre.ResourceType.UINT_8, function (callback) {
                        that.bind(renderer);
                        renderer.readPixels(0, 0, that._width, that._height, pixelData);
                        that.unbind(renderer);
                        return pixelData;
                    });
                }
            }
        };

        FrameBufferRenderTarget.prototype.unbind = function (renderer) {
            renderer.getBindingManager().unbindFramebuffer();
        };

        FrameBufferRenderTarget.prototype.getWidth = function () {
            return this._width;
        };

        FrameBufferRenderTarget.prototype.getHeight = function () {
            return this._height;
        };

        FrameBufferRenderTarget.prototype.getFramebuffer = function () {
            return this._framebuffer;
        };

        FrameBufferRenderTarget.prototype.getTextureResource = function (usage) {
            if (typeof usage === &quot;undefined&quot;) { usage = 0 /* COLOR_TARGET0 */; }
            if (this._textureResources.length == 0) {
                this._initTextureResource();
            }
            var idx = this._textureUsages.indexOf(usage);
            if (idx &gt; -1) {
                return this._textureResources[idx];
            }
            return null;
        };

        FrameBufferRenderTarget.prototype.setFramebuffer = function (framebuffer) {
            this._framebuffer = framebuffer;
        };

        FrameBufferRenderTarget.prototype.setDirty = function () {
            var i = 0, n = this._textureUsages.length;

            for (; i &lt; n; ++i) {
                if (this._pixelBufferResources[i]) {
                    this._pixelBufferResources[i].setDirty();
                }
            }
        };

        FrameBufferRenderTarget.prototype.getPixelBuffer = function (usage) {
            var idx = -1;
            if ((idx = this._textureUsages.indexOf(usage)) &gt; -1 &amp;&amp; this._pixelBufferResources[idx]) {
                return this._pixelBufferResources[idx].getData();
            }

            return null;
        };

        FrameBufferRenderTarget.prototype.getLastClearFrameId = function () {
            return this._clearFrameId;
        };

        FrameBufferRenderTarget.prototype.setClearFrameId = function (frameId) {
            this._clearFrameId = frameId;
            var i = 0, n = this._textureUsages.length;

            for (; i &lt; n; ++i) {
                this._textureResources[i].setDirty(true);
                this._textureResources[i].setReady(false);
            }
        };
        return FrameBufferRenderTarget;
    })();
    _renderer.FrameBufferRenderTarget = FrameBufferRenderTarget;
})(renderer || (renderer = {}));
var pre;
(function (pre) {
    var HTMLCanvasRenderTarget = (function () {
        function HTMLCanvasRenderTarget(canvasElement) {
            this._canvasElement = null;
            this._glContext = null;
            this._scaleFactor = 1.0;
            this._clearFrameId = -1;
            this._canvasElement = canvasElement;
        }
        HTMLCanvasRenderTarget.prototype.getRenderingContext = function (contextNames) {
            if (this._glContext == null) {
                var params = {
                    alpha: true,
                    antialias: true,
                    depth: true,
                    premultipliedAlpha: false,
                    preserveDrawingBuffer: true,
                    stencil: false,
                    failifmajorperformancecaveat: true
                };

                var i = 0, n = contextNames.length;
                while (!this._glContext &amp;&amp; i &lt; n) {
                    this._glContext = this._canvasElement.getContext(contextNames[i], params);
                    if (!this._glContext) {
                        ++i;
                    } else {
                        util.Log.postInfo(&quot;WebGL Context : &quot; + contextNames[i]);
                    }
                }
            }

            return this._glContext;
        };

        HTMLCanvasRenderTarget.prototype.bind = function (renderer) {
            renderer.getBindingManager().bindViewport(this);
        };

        HTMLCanvasRenderTarget.prototype.unbind = function (renderer) {
        };

        HTMLCanvasRenderTarget.prototype.getWidth = function () {
            return this._canvasElement.width * this._scaleFactor;
        };

        HTMLCanvasRenderTarget.prototype.getHeight = function () {
            return this._canvasElement.height * this._scaleFactor;
        };

        HTMLCanvasRenderTarget.prototype.setScaleFactor = function (scaleFactor) {
            this._scaleFactor = scaleFactor;
        };

        HTMLCanvasRenderTarget.prototype.getLastClearFrameId = function () {
            return this._clearFrameId;
        };

        HTMLCanvasRenderTarget.prototype.setClearFrameId = function (frameId) {
            this._clearFrameId = frameId;
        };

        HTMLCanvasRenderTarget.prototype.setDirty = function () {
        };
        return HTMLCanvasRenderTarget;
    })();
    pre.HTMLCanvasRenderTarget = HTMLCanvasRenderTarget;
})(pre || (pre = {}));
var renderer;
(function (renderer) {
    var ShaderProgram = (function () {
        function ShaderProgram(gl, glProgram, id) {
            this._glProgram = glProgram;
            this._shaderLocations = [];
            this._shaderLocations[0 /* UNCLASSIFIED */] = [];
            this._shaderLocations[1 /* GLOBAL */] = [];
            this._shaderLocations[2 /* PASS */] = [];
            this._shaderLocations[3 /* APPEARANCE */] = [];
            this._shaderLocations[4 /* DRAWABLE */] = [];
            this._shaderLocations[5 /* GEOMETRY */] = [];
            this._attributeLocations = [];
            this._id = id;
        }
        ShaderProgram.prototype.setUniformLocations = function (uniformLocations) {
            this._shaderLocations[0 /* UNCLASSIFIED */] = uniformLocations;
        };

        ShaderProgram.prototype.setAttributeLocations = function (attributeLocations) {
            this._attributeLocations = attributeLocations;
        };

        ShaderProgram.prototype.setLocationBindStage = function (location, stage) {
            this._shaderLocations[stage].push(location);

            var pos = this._shaderLocations[0 /* UNCLASSIFIED */].indexOf(location);
            if (pos &gt; -1) {
                this._shaderLocations[0 /* UNCLASSIFIED */].splice(pos, 1);
            }
        };

        ShaderProgram.prototype.getShaderLocations = function (stage) {
            return this._shaderLocations[stage];
        };

        ShaderProgram.prototype.getAttributeLocations = function () {
            return this._attributeLocations;
        };

        ShaderProgram.prototype.bind = function (gl) {
            gl.useProgram(this._glProgram);
        };

        ShaderProgram.prototype.getID = function () {
            return this._id;
        };
        return ShaderProgram;
    })();
    renderer.ShaderProgram = ShaderProgram;
})(renderer || (renderer = {}));
var renderer;
(function (renderer) {
    var StateManager = (function () {
        function StateManager() {
            this._gl = null;
            this._constants = new pre.Constants();
            this._clearColor = vec4.create();
            this._clearDepth = 1.0;
            this._colorMask = [true, true, true, true];
            this._blendColor = vec4.create();
            this._blendEquation = null;
            this._blendEquationSeparate = null;
            this._blendFunc = null;
            this._blendFuncSeparate = null;
            this._viewport = null;
            this._depthRange = null;
            this._caps = {};
        }
        StateManager.prototype._setConstants = function () {
            var constants = Object.getOwnPropertyNames(this._constants), i = 0, n = constants.length, item;

            for (; i &lt; n; ++i) {
                item = constants[i];
                this._constants[item] = this._gl[item];
            }
        };

        StateManager.prototype.setWebGLRenderingContext = function (gl) {
            this._gl = gl;
            this._setConstants();
        };

        StateManager.prototype.getConstants = function () {
            return this._constants;
        };

        StateManager.prototype.clear = function (mask) {
            this._gl.clear(mask);
        };

        StateManager.prototype.finish = function () {
            this._gl.finish();
        };

        StateManager.prototype.flush = function () {
            this._gl.flush();
        };

        StateManager.prototype.caps = function (cap, flag) {
            var str = cap.toString();
            if (this._caps[str] !== flag) {
                if (flag)
                    this._gl.enable(cap);
                else
                    this._gl.disable(cap);
                this._caps[str] = flag;
                return true;
            }
            return false;
        };

        StateManager.prototype.clearColor = function (color) {
            if (this._clearColor[0] != color[0] || this._clearColor[1] != color[1] || this._clearColor[2] != color[2] || this._clearColor[3] != color[3]) {
                this._gl.clearColor(color[0], color[1], color[2], color[3]);
                this._clearColor[0] = color[0];
                this._clearColor[1] = color[1];
                this._clearColor[2] = color[2];
                this._clearColor[3] = color[3];
                return true;
            }
            return false;
        };

        StateManager.prototype.clearDepth = function (depth) {
            if (this._clearDepth != depth) {
                this._gl.clearDepth(depth);
                this._clearDepth = depth;
                return true;
            }
            return false;
        };

        StateManager.prototype.colorMask = function (colors) {
            if (this._colorMask[0] != colors[0] || this._colorMask[1] != colors[1] || this._colorMask[2] != colors[2] || this._colorMask[3] != colors[3]) {
                this._gl.colorMask(colors[0], colors[1], colors[2], colors[3]);
                this._colorMask[0] = colors[0];
                this._colorMask[1] = colors[1];
                this._colorMask[2] = colors[2];
                this._colorMask[3] = colors[3];
                return true;
            }
            return false;
        };

        StateManager.prototype.depthMask = function (flag) {
            if (this._depthMask != flag) {
                this._gl.depthMask(flag);
                this._depthMask = flag;
                return true;
            }
            return false;
        };

        StateManager.prototype.stencilMask = function (flag) {
            if (this._stencilMask != flag) {
                this._gl.stencilMask(flag);
                this._stencilMask = flag;
                return true;
            }
            return false;
        };

        StateManager.prototype.cullFace = function (flag) {
            if (this._cullFace != flag) {
                this._gl.cullFace(flag);
                this._cullFace = flag;
                return true;
            }
            return false;
        };

        StateManager.prototype.frontFace = function (flag) {
            if (this._frontFace != flag) {
                this._gl.frontFace(flag);
                this._frontFace = flag;
                return true;
            }
            return false;
        };

        StateManager.prototype.lineWidth = function (width) {
            width = (width &lt;= 1) ? 1 : width;

            if (this._lineWidth != width) {
                this._gl.lineWidth(width);
                this._lineWidth = width;
                return true;
            }
            return false;
        };

        StateManager.prototype.blendColor = function (color) {
            if (this._blendColor[0] != color[0] || this._blendColor[1] != color[1] || this._blendColor[2] != color[2] || this._blendColor[3] != color[3]) {
                this._gl.blendColor(color[0], color[1], color[2], color[3]);
                this._blendColor[0] = color[0];
                this._blendColor[1] = color[1];
                this._blendColor[2] = color[2];
                this._blendColor[3] = color[3];
                return true;
            }
            return false;
        };

        StateManager.prototype.depthFunc = function (func) {
            if (this._depthFunc != func) {
                this._gl.depthFunc(func);
                this._depthFunc = func;
                return true;
            }
            return false;
        };

        StateManager.prototype.polygonOffset = function (factor, unit) {
            this._gl.polygonOffset(factor, unit);
        };
        return StateManager;
    })();
    renderer.StateManager = StateManager;
})(renderer || (renderer = {}));
var renderer;
(function (renderer) {
    var WebGLRendererBase = (function () {
        function WebGLRendererBase(app, renderingContext) {
            this._glExtensions = {};
            this._uniformIDCount = 0;
            this._gl = renderingContext;

            var extNames = [&quot;WEBGL_depth_texture&quot;];

            var i;
            var extName;
            for (i = 0; i &lt; extNames.length; ++i) {
                extName = extNames[i];
                this._glExtensions[extName] = this._gl.getExtension(extName);
                if (!this._glExtensions[extName]) {
                    util.Log.postWarning(&quot;Unable to query WebGL extension \&quot;&quot; + extName + &quot;\&quot;.&quot; + &quot; WebGL rendering might not work as expected.&quot;);
                }
            }

            this._objectCatalog = pre.Environment.getInstance().getObjectCatalog();

            var stateManager = new renderer.StateManager();
            this._stateManager = stateManager;
            stateManager.setWebGLRenderingContext(this._gl);

            this._memoryManager = new renderer.MemoryManager(app, this._gl);
            this._bindingManager = new renderer.BindingManager(this._memoryManager, this._gl);
        }
        WebGLRendererBase.prototype._drawElements = function (primitiveType, numElements, type, offset) {
            this._gl.drawElements(primitiveType, numElements, type, offset);
        };

        WebGLRendererBase.prototype._drawArrays = function (primitiveType, startIdx, numElements) {
            this._gl.drawArrays(primitiveType, startIdx, numElements);
        };

        WebGLRendererBase.prototype._computeMinVectorRowCount = function (uniforms) {
            var minNumNeededRows = 0;

            var shaderVar;
            var minRowsPerElement;
            var i;

            var largestPackableArraySize = 0;

            for (i = 0; i &lt; uniforms.length; ++i) {
                shaderVar = uniforms[i];

                switch (shaderVar.type) {
                    case pre.ResourceType.vec4f:
                    case pre.ResourceType.vec4i:
                    case pre.ResourceType.vec4bool:
                        minNumNeededRows += shaderVar.numElements;
                        break;

                    case pre.ResourceType.mat4f:
                        minNumNeededRows += shaderVar.numElements * 4;
                        break;

                    default:
                        if (shaderVar.numElements &gt; 1 &amp;&amp; shaderVar.numElements &gt; largestPackableArraySize) {
                            largestPackableArraySize = shaderVar.numElements;
                        }
                }
            }

            minNumNeededRows += largestPackableArraySize;

            return minNumNeededRows;
        };

        WebGLRendererBase.prototype._countTextureSamplers = function (uniforms) {
            var numSamplers = 0;

            var uniform;
            var i;

            for (i = 0; i &lt; uniforms.length; ++i) {
                uniform = uniforms[i];

                if (uniform.type == pre.ResourceType.sampler2D || uniform.type == pre.ResourceType.samplerCube) {
                    numSamplers += uniform.numElements;
                }
            }

            return numSamplers;
        };

        WebGLRendererBase.prototype._checkShaderLimitations = function (shader, gl) {
            if (typeof gl === &quot;undefined&quot;) { gl = null; }
            var vertexAttribLimit = 8;
            var vertexVectorRowLimit = 128;
            var fragmentVectorRowLimit = 16;
            var varyingVectorRowLimit = 8;
            var vertexTextureUnitLimit = 0;
            var combinedTextureUnitLimit = 8;
            var fragmentTextureUnitLimit = 8;

            if (gl) {
                vertexAttribLimit = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                vertexVectorRowLimit = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
                fragmentVectorRowLimit = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
                varyingVectorRowLimit = gl.getParameter(gl.MAX_VARYING_VECTORS);
                vertexTextureUnitLimit = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                combinedTextureUnitLimit = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                fragmentTextureUnitLimit = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            }

            var numVertexAttributes = shader.getAttributes().length;
            if (numVertexAttributes &gt; vertexAttribLimit) {
                util.Log.postError(&quot;Shader \&quot;&quot; + shader.getName() + &quot;\&quot; exceeds the limit of VERTEX ATTRIBUTES. &quot; + &quot;Given: &quot; + numVertexAttributes + &quot; Allowed: &quot; + vertexAttribLimit);
                return false;
            }

            var vertexUniforms = shader.getUniforms(1 /* VERTEX */);
            var fragmentUniforms = shader.getUniforms(2 /* FRAGMENT */);

            var minVectorRowsVertex = this._computeMinVectorRowCount(vertexUniforms);
            if (minVectorRowsVertex &gt; vertexVectorRowLimit) {
                util.Log.postError(&quot;Shader \&quot;&quot; + shader.getName() + &quot;\&quot; exceeds the limit of VERTEX UNIFORM registers. &quot; + &quot;Given: &quot; + minVectorRowsVertex + &quot; Allowed: &quot; + vertexVectorRowLimit);
                return false;
            }

            var minVectorRowsFragment = this._computeMinVectorRowCount(fragmentUniforms);
            if (minVectorRowsFragment &gt; fragmentVectorRowLimit) {
                util.Log.postError(&quot;Shader \&quot;&quot; + shader.getName() + &quot;\&quot; exceeds the limit of FRAGMENT UNIFORM registers. &quot; + &quot;Given: &quot; + minVectorRowsFragment + &quot; Allowed: &quot; + fragmentVectorRowLimit);
                return false;
            }

            var numVaryingRows = this._computeMinVectorRowCount(shader.getVaryings());
            if (numVaryingRows &gt; varyingVectorRowLimit) {
                util.Log.postError(&quot;Shader \&quot;&quot; + shader.getName() + &quot;\&quot; exceeds the limit of VARYING registers. &quot; + &quot;Given: &quot; + numVaryingRows + &quot; Allowed: &quot; + varyingVectorRowLimit);
                return false;
            }

            var numSamplersVertex = this._countTextureSamplers(vertexUniforms);
            if (numSamplersVertex &gt; vertexTextureUnitLimit) {
                util.Log.postError(&quot;Shader \&quot;&quot; + shader.getName() + &quot;\&quot; exceeds the limit of VERTEX TEXTURE units. &quot; + &quot;Given: &quot; + numSamplersVertex + &quot; Allowed: &quot; + vertexTextureUnitLimit);
                return false;
            }

            var numSamplersFragment = this._countTextureSamplers(fragmentUniforms);
            if (numSamplersFragment &gt; fragmentTextureUnitLimit) {
                util.Log.postError(&quot;Shader \&quot;&quot; + shader.getName() + &quot;\&quot; exceeds the limit of FRAGMENT TEXTURE units. &quot; + &quot;Given: &quot; + numSamplersFragment + &quot; Allowed: &quot; + fragmentTextureUnitLimit);
                return false;
            }

            var numSamplersCombined = numSamplersVertex + numSamplersFragment;
            if (numSamplersCombined &gt; combinedTextureUnitLimit) {
                util.Log.postError(&quot;Shader \&quot;&quot; + shader.getName() + &quot;\&quot; exceeds the limit of COMBINED TEXTURE units. &quot; + &quot;Given: &quot; + numSamplersCombined + &quot; Allowed: &quot; + combinedTextureUnitLimit);
                return false;
            }

            return true;
        };

        WebGLRendererBase.prototype.draw = function (geoDesc) {
            var indices = geoDesc.requestResource(&quot;indices&quot;);

            var numElements = geoDesc.getNumElements();

            var primType = geoDesc.getPrimitiveType();

            if (numElements &gt; 0) {
                var stats = util.Statistics.getInstance();

                switch (primType) {
                    case pre.PrimitiveType.TRIANGLES: {
                        stats.addValue(&quot;TRIANGLES&quot;, numElements / 3, &quot;DRAWING&quot;);
                        break;
                    }
                    case pre.PrimitiveType.LINES: {
                        stats.addValue(&quot;LINES&quot;, numElements / 2, &quot;DRAWING&quot;);
                        break;
                    }
                }
                stats.addValue(&quot;drawcalls&quot;, 1, &quot;DRAWING&quot;);

                if (indices) {
                    this._drawElements(primType, numElements, indices.getType(), 0);
                } else {
                    this._drawArrays(primType, 0, numElements);
                }
            }
        };

        WebGLRendererBase.prototype.getBindingManager = function () {
            return this._bindingManager;
        };

        WebGLRendererBase.prototype.getMemoryManager = function () {
            return this._memoryManager;
        };

        WebGLRendererBase.prototype.getStateManager = function () {
            return this._stateManager;
        };

        WebGLRendererBase.prototype.createShader = function (shaderSource, type) {
            var shader = this._gl.createShader(type);
            this._gl.shaderSource(shader, shaderSource);
            this._gl.compileShader(shader);

            var typeStr;

            if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {
                typeStr = type == this._gl.VERTEX_SHADER ? &quot;vertex&quot; : &quot;fragment&quot;;
                util.Log.postError(&quot;Error during &quot; + typeStr + &quot; shader compilation: &quot; + this._gl.getShaderInfoLog(shader));
            }

            return shader;
        };

        WebGLRendererBase.prototype.buildShaderProgram = function (shader, id) {
            var vSource = shader.getVSSource();
            var fSource = shader.getPSSource();

            if (!this._checkShaderLimitations(shader, this._gl)) {
                util.Log.postError(&quot;Unable to build program for shader descriptor \&quot;&quot; + shader.getName() + &quot;\&quot;: &quot; + &quot;Shader exceeds WebGL limits.&quot;);
                return;
            }

            var uniforms = shader.getUniforms();
            var attributes = shader.getAttributes();
            var vShader = this.createShader(vSource, this._gl.VERTEX_SHADER);
            var fShader = this.createShader(fSource, this._gl.FRAGMENT_SHADER);

            if (!vShader || !fShader) {
                util.Log.postError(&quot;Unable to build program for shader descriptor \&quot;&quot; + shader.getName() + &quot;\&quot;: &quot; + &quot;At least one shader could not be created.&quot;);
                return null;
            }

            var glProgram = this._gl.createProgram();
            this._gl.attachShader(glProgram, vShader);
            this._gl.attachShader(glProgram, fShader);

            this._gl.linkProgram(glProgram);

            var linked = this._gl.getProgramParameter(glProgram, this._gl.LINK_STATUS);
            if (!linked) {
                util.Log.postError(&quot;Unable to build program for shader descriptor \&quot;&quot; + shader.getName() + &quot;\&quot;. &quot; + &quot;Error occurred when trying to link program:\n&quot; + this._gl.getProgramInfoLog(glProgram));
                this._gl.deleteProgram(glProgram);
                return null;
            }

            var shaderProgram = new renderer.ShaderProgram(this._gl, glProgram, id);
            this.findShaderLocations(shaderProgram, glProgram, uniforms, attributes);
            return shaderProgram;
        };

        WebGLRendererBase.prototype.findShaderLocations = function (shaderProgram, glProgram, uniforms, attributes) {
            var validUniforms = [], validAttributeLocations = [];
            var uniformVariable = null, attributeLocation = null;
            var location;

            for (var uniformID = 0; uniformID &lt; uniforms.length; uniformID++) {
                uniformVariable = uniforms[uniformID];

                location = this._gl.getUniformLocation(glProgram, uniformVariable.name);

                if (location != null) {
                    validUniforms.push(new pre.UniformShaderVariable(uniformVariable.name, uniformVariable.type, uniformVariable.shaderType, location, this._uniformIDCount++));
                }
            }
            for (var attributeID = 0; attributeID &lt; attributes.length; attributeID++) {
                attributeLocation = attributes[attributeID];
                location = this._gl.getAttribLocation(glProgram, attributeLocation.name);

                if (location != null) {
                    validAttributeLocations.push(new pre.AttributeLocation(attributeLocation.name, location));
                }
            }

            validAttributeLocations.sort(function (v0, v1) {
                return v0.location - v1.location;
            });

            shaderProgram.setAttributeLocations(validAttributeLocations);
            shaderProgram.setUniformLocations(validUniforms);
        };

        WebGLRendererBase.prototype.readPixels = function (x, y, width, height, buffer) {
            this._gl.readPixels(x, y, width, height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, buffer);
        };

        WebGLRendererBase.prototype.createQuery = function () {
            return this._gl.createQuery();
        };

        WebGLRendererBase.prototype.deleteQuery = function (query) {
            this._gl.deleteQuery(query);
        };

        WebGLRendererBase.prototype.beginQuery = function (query) {
            this._gl.beginQuery(this._gl.ANY_SAMPLES_PASSED, query);
        };

        WebGLRendererBase.prototype.endQuery = function () {
            this._gl.endQuery(this._gl.ANY_SAMPLES_PASSED);
        };

        WebGLRendererBase.prototype.queryResultAvailable = function (query) {
            var available = this._gl.getQueryObject(query, this._gl.QUERY_RESULT_AVAILABLE);
            return available;
        };

        WebGLRendererBase.prototype.getQueryResult = function (query) {
            var test = this._gl.getQueryObject(query, this._gl.QUERY_RESULT);
            return test;
        };
        return WebGLRendererBase;
    })();
    renderer.WebGLRendererBase = WebGLRendererBase;
})(renderer || (renderer = {}));
var pre;
(function (pre) {
    var RenderTreeTraverser = (function (_super) {
        __extends(RenderTreeTraverser, _super);
        function RenderTreeTraverser() {
            _super.call(this);
            this._target = null;
        }
        RenderTreeTraverser.prototype.traverse = function (node) {
            if (node.isEnabled()) {
                if (!this._settings.frustumCulling || this._frustum.nodeIsWithinFrustum(node)) {
                    var worldVolume = node.requestWorldVolume();
                    if (worldVolume &amp;&amp; worldVolume.isValid()) {
                        var ssc = this.calculateScreenSpaceCoverage(worldVolume);
                        node.setScreenSpaceCoverage(ssc);
                    }
                    if (!this._settings.smallFeatureCulling || ssc &gt;= this._settings.smallFeatureTreshold) {
                        node.collectDrawables(this._target, this._context);

                        var children = node.getChildren();
                        for (var i = 0, n = children.length; i &lt; n; ++i) {
                            this.traverse(children[i]);
                        }
                    }
                }
            }
        };

        RenderTreeTraverser.prototype.setTarget = function (target) {
            this._target = target;
        };
        return RenderTreeTraverser;
    })(pre.CullingTraverser);
    pre.RenderTreeTraverser = RenderTreeTraverser;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var TreeNodeCollector = (function (_super) {
        __extends(TreeNodeCollector, _super);
        function TreeNodeCollector() {
            _super.call(this);
            this._target = null;
        }
        TreeNodeCollector.prototype.traverse = function (node) {
            if (this._target) {
                this._target.push(node);
            }
            _super.prototype.traverse.call(this, node);
        };

        TreeNodeCollector.prototype.setTarget = function (target) {
            this._target = target;
        };
        return TreeNodeCollector;
    })(pre.TreeTraverserBase);
    pre.TreeNodeCollector = TreeNodeCollector;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var DrawableCollector = (function (_super) {
        __extends(DrawableCollector, _super);
        function DrawableCollector(application) {
            _super.call(this, application);
            this._traverser = new pre.RenderTreeTraverser();
            this._settings = new pre.Settings();
            this._triggers = [
                0 /* FULL */,
                3 /* GEOMETRY_CHANGED */,
                6 /* NODES_CHANGED */,
                5 /* VIEW_CHANGED */,
                7 /* SCREENSHOT */
            ];

            this._outputSlots[&quot;drawables&quot;] = new pre.Slot(&quot;drawables&quot;, pre.ObjectResource.Create(this._drawables));
        }
        DrawableCollector.prototype._execute = function (clearFrame) {
            var stats = util.Statistics.getInstance();

            stats.startMeasurement(&quot;TREECOLLECT&quot;);

            var rootNode = this._application.getRenderTreeRoot();

            if (rootNode != null &amp;&amp; clearFrame) {
                if (!DrawableCollector._visibilityFreeze) {
                    this._settings.smallFeatureTreshold = this._application.getSettings().smallFeatureTreshold;

                    this._traverser.setContext(this._context);
                    this._traverser.setTarget(this);

                    this._clearOutputSlots();
                    rootNode.setPlaneMask(0);
                    this._traverser.traverse(rootNode);
                }
            }
            stats.stopMeasurement(&quot;TREECOLLECT&quot;);
        };

        DrawableCollector.prototype._clearOutputSlots = function () {
            var slot, resource;
            for (slot in this._outputSlots) {
                resource = this._outputSlots[slot].getResource();
                resource.setDirty();
                resource.getData().length = 0;
            }
        };

        DrawableCollector.setVisibilityFreeze = function (active) {
            DrawableCollector._visibilityFreeze = active;
        };

        DrawableCollector.prototype.add = function (drawable) {
            this._drawables.push(drawable);
        };
        DrawableCollector._visibilityFreeze = false;
        return DrawableCollector;
    })(pre.PipelineStage);
    pre.DrawableCollector = DrawableCollector;
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (FilterMode) {
        FilterMode[FilterMode[&quot;EXCLUSIVE&quot;] = 0] = &quot;EXCLUSIVE&quot;;
        FilterMode[FilterMode[&quot;ADDITIVE&quot;] = 1] = &quot;ADDITIVE&quot;;
    })(pre.FilterMode || (pre.FilterMode = {}));
    var FilterMode = pre.FilterMode;

    var DrawableFilter = (function () {
        function DrawableFilter(name, filterFunction, mode) {
            if (typeof mode === &quot;undefined&quot;) { mode = 0 /* EXCLUSIVE */; }
            this.filterFunction = null;
            this.name = name;
            this.mode = mode;
            this.filterFunction = filterFunction;
        }
        return DrawableFilter;
    })();
    pre.DrawableFilter = DrawableFilter;

    var FilteredDrawableCollector = (function (_super) {
        __extends(FilteredDrawableCollector, _super);
        function FilteredDrawableCollector(application, filterList) {
            if (typeof filterList === &quot;undefined&quot;) { filterList = []; }
            _super.call(this, application);
            this._filterFunctions = [];
            this._filters = [];

            var i = 0, n = filterList.length, filter = null;

            for (; i &lt; n; ++i) {
                filter = filterList[i];
                this._filters.push(filter);

                var slotArray = [];
                this._outputSlots[filter.name] = new pre.Slot(filter.name, pre.ObjectResource.Create(slotArray));

                this._filterFunctions.push(function (drawable) {
                    var array = slotArray;
                    if (filter.filterFunction(drawable)) {
                        array.push(drawable);
                        return true;
                    }
                    return false;
                });
            }
        }
        FilteredDrawableCollector.prototype.add = function (drawable) {
            var i = 0, n = this._filterFunctions.length;
            for (; i &lt; n; ++i) {
                if (this._filterFunctions[i](drawable) &amp;&amp; this._filters[i].mode == 0 /* EXCLUSIVE */) {
                    return;
                }
            }
            this._drawables.push(drawable);
        };
        return FilteredDrawableCollector;
    })(pre.DrawableCollector);
    pre.FilteredDrawableCollector = FilteredDrawableCollector;
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (FilterType) {
        FilterType[FilterType[&quot;NEAREST&quot;] = parseInt(&quot;0x2600&quot;, 16)] = &quot;NEAREST&quot;;
        FilterType[FilterType[&quot;LINEAR&quot;] = parseInt(&quot;0x2601&quot;, 16)] = &quot;LINEAR&quot;;
        FilterType[FilterType[&quot;NEAREST_MIPMAP_NEAREST&quot;] = parseInt(&quot;0x2700&quot;, 16)] = &quot;NEAREST_MIPMAP_NEAREST&quot;;
        FilterType[FilterType[&quot;LINEAR_MIPMAP_NEAREST&quot;] = parseInt(&quot;0x2701&quot;, 16)] = &quot;LINEAR_MIPMAP_NEAREST&quot;;
        FilterType[FilterType[&quot;NEAREST_MIPMAP_LINEAR&quot;] = parseInt(&quot;0x2702&quot;, 16)] = &quot;NEAREST_MIPMAP_LINEAR&quot;;
        FilterType[FilterType[&quot;LINEAR_MIPMAP_LINEAR&quot;] = parseInt(&quot;0x2703&quot;, 16)] = &quot;LINEAR_MIPMAP_LINEAR&quot;;
    })(pre.FilterType || (pre.FilterType = {}));
    var FilterType = pre.FilterType;
    (function (WrapType) {
        WrapType[WrapType[&quot;REPEAT&quot;] = parseInt(&quot;0x2901&quot;, 16)] = &quot;REPEAT&quot;;
        WrapType[WrapType[&quot;CLAMP_TO_EDGE&quot;] = parseInt(&quot;0x812F&quot;, 16)] = &quot;CLAMP_TO_EDGE&quot;;
        WrapType[WrapType[&quot;MIRRORED_REPEAT&quot;] = parseInt(&quot;0x8370&quot;, 16)] = &quot;MIRRORED_REPEAT&quot;;
    })(pre.WrapType || (pre.WrapType = {}));
    var WrapType = pre.WrapType;
    (function (FormatType) {
        FormatType[FormatType[&quot;DEPTH_COMPONENT&quot;] = parseInt(&quot;0x1902&quot;, 16)] = &quot;DEPTH_COMPONENT&quot;;
        FormatType[FormatType[&quot;ALPHA&quot;] = parseInt(&quot;0x1906&quot;, 16)] = &quot;ALPHA&quot;;
        FormatType[FormatType[&quot;RGB&quot;] = parseInt(&quot;0x1907&quot;, 16)] = &quot;RGB&quot;;
        FormatType[FormatType[&quot;RGBA&quot;] = parseInt(&quot;0x1908&quot;, 16)] = &quot;RGBA&quot;;
        FormatType[FormatType[&quot;LUMINANCE&quot;] = parseInt(&quot;0x1909&quot;, 16)] = &quot;LUMINANCE&quot;;
        FormatType[FormatType[&quot;LUMINANCE_ALPHA&quot;] = parseInt(&quot;0x190A&quot;, 16)] = &quot;LUMINANCE_ALPHA&quot;;
    })(pre.FormatType || (pre.FormatType = {}));
    var FormatType = pre.FormatType;
    (function (DataType) {
        DataType[DataType[&quot;BYTE&quot;] = parseInt(&quot;0x1400&quot;, 16)] = &quot;BYTE&quot;;
        DataType[DataType[&quot;UNSIGNED_BYTE&quot;] = parseInt(&quot;0x1401&quot;, 16)] = &quot;UNSIGNED_BYTE&quot;;
        DataType[DataType[&quot;SHORT&quot;] = parseInt(&quot;0x1402&quot;, 16)] = &quot;SHORT&quot;;
        DataType[DataType[&quot;UNSIGNED_SHORT&quot;] = parseInt(&quot;0x1403&quot;, 16)] = &quot;UNSIGNED_SHORT&quot;;
        DataType[DataType[&quot;INT&quot;] = parseInt(&quot;0x1404&quot;, 16)] = &quot;INT&quot;;
        DataType[DataType[&quot;UNSIGNED_INT&quot;] = parseInt(&quot;0x1405&quot;, 16)] = &quot;UNSIGNED_INT&quot;;
        DataType[DataType[&quot;FLOAT&quot;] = parseInt(&quot;0x1406&quot;, 16)] = &quot;FLOAT&quot;;
    })(pre.DataType || (pre.DataType = {}));
    var DataType = pre.DataType;

    var AbstractTextureResource = (function (_super) {
        __extends(AbstractTextureResource, _super);
        function AbstractTextureResource(type, fetch) {
            _super.call(this, type, fetch);
            this._width = 0;
            this._height = 0;
            this._wrapS = WrapType.REPEAT;
            this._wrapT = WrapType.REPEAT;
            this._minFilter = FilterType.LINEAR;
            this._magFilter = FilterType.LINEAR;
            this._format = FormatType.RGBA;
            this._internalFormat = FormatType.RGBA;
            this._dataType = DataType.UNSIGNED_BYTE;
            this._unpackFlipY = false;
        }
        AbstractTextureResource.prototype.setWidth = function (val) {
            this._width = val;
        };

        AbstractTextureResource.prototype.setHeight = function (val) {
            this._height = val;
        };

        AbstractTextureResource.prototype.setWrapS = function (val) {
            this._wrapS = val;
        };

        AbstractTextureResource.prototype.setWrapT = function (val) {
            this._wrapT = val;
        };

        AbstractTextureResource.prototype.setMinFilter = function (val) {
            this._minFilter = val;
        };

        AbstractTextureResource.prototype.setMagFilter = function (val) {
            this._magFilter = val;
        };

        AbstractTextureResource.prototype.setFormat = function (val) {
            this._format = val;
        };

        AbstractTextureResource.prototype.setInternalFormat = function (val) {
            this._internalFormat = val;
        };

        AbstractTextureResource.prototype.setDataType = function (val) {
            this._dataType = val;
        };

        AbstractTextureResource.prototype.getWidth = function () {
            return this._width;
        };

        AbstractTextureResource.prototype.getHeight = function () {
            return this._height;
        };

        AbstractTextureResource.prototype.getWrapS = function () {
            return this._wrapS;
        };

        AbstractTextureResource.prototype.getWrapT = function () {
            return this._wrapT;
        };

        AbstractTextureResource.prototype.getMinFilter = function () {
            return this._minFilter;
        };

        AbstractTextureResource.prototype.getMagFilter = function () {
            return this._magFilter;
        };

        AbstractTextureResource.prototype.getFormat = function () {
            return this._format;
        };

        AbstractTextureResource.prototype.getInternalFormat = function () {
            return this._internalFormat;
        };

        AbstractTextureResource.prototype.getDataType = function () {
            return this._dataType;
        };

        AbstractTextureResource.prototype.needsMipMaps = function () {
            return this._minFilter &gt;= FilterType.NEAREST_MIPMAP_NEAREST;
        };

        AbstractTextureResource.prototype.needsUnpackFlipY = function () {
            return this._unpackFlipY;
        };
        return AbstractTextureResource;
    })(pre.AbstractResource);
    pre.AbstractTextureResource = AbstractTextureResource;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var BufferResource = (function (_super) {
        __extends(BufferResource, _super);
        function BufferResource(type, fetch, componentCount, normalized, stride, offset, usageHint) {
            if (typeof componentCount === &quot;undefined&quot;) { componentCount = 0; }
            if (typeof normalized === &quot;undefined&quot;) { normalized = false; }
            if (typeof stride === &quot;undefined&quot;) { stride = 0; }
            if (typeof offset === &quot;undefined&quot;) { offset = 0; }
            if (typeof usageHint === &quot;undefined&quot;) { usageHint = 35044 /* STATIC */; }
            _super.call(this, type, fetch, componentCount, normalized, stride, offset, usageHint);
        }
        BufferResource.Create = function (type, data, componentCount, normalized, stride, offset, usageHint) {
            if (typeof componentCount === &quot;undefined&quot;) { componentCount = 0; }
            if (typeof normalized === &quot;undefined&quot;) { normalized = false; }
            if (typeof stride === &quot;undefined&quot;) { stride = 0; }
            if (typeof offset === &quot;undefined&quot;) { offset = 0; }
            if (typeof usageHint === &quot;undefined&quot;) { usageHint = 35044 /* STATIC */; }
            return new BufferResource(type, function (callback) {
                return data;
            }, componentCount, normalized, stride, offset, usageHint);
        };

        BufferResource.CreateLazy = function (type, fetch, componentCount, normalized, stride, offset, usageHint) {
            if (typeof componentCount === &quot;undefined&quot;) { componentCount = 0; }
            if (typeof normalized === &quot;undefined&quot;) { normalized = false; }
            if (typeof stride === &quot;undefined&quot;) { stride = 0; }
            if (typeof offset === &quot;undefined&quot;) { offset = 0; }
            if (typeof usageHint === &quot;undefined&quot;) { usageHint = 35044 /* STATIC */; }
            return new BufferResource(type, fetch, componentCount, normalized, stride, offset, usageHint);
        };
        return BufferResource;
    })(pre.AbstractBufferResource);
    pre.BufferResource = BufferResource;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var ChunkedBufferResource = (function (_super) {
        __extends(ChunkedBufferResource, _super);
        function ChunkedBufferResource(type, fetch, componentCount, normalized, stride, offset, bufferSize, decodeOffset, decodeScale) {
            if (typeof componentCount === &quot;undefined&quot;) { componentCount = 0; }
            if (typeof normalized === &quot;undefined&quot;) { normalized = false; }
            if (typeof stride === &quot;undefined&quot;) { stride = 0; }
            if (typeof offset === &quot;undefined&quot;) { offset = 0; }
            if (typeof bufferSize === &quot;undefined&quot;) { bufferSize = 0; }
            if (typeof decodeOffset === &quot;undefined&quot;) { decodeOffset = null; }
            if (typeof decodeScale === &quot;undefined&quot;) { decodeScale = null; }
            _super.call(this, type, fetch, componentCount, normalized, stride, offset, bufferSize, decodeOffset, decodeScale);
        }
        ChunkedBufferResource.prototype.getData = function () {
            return this._fetch(function () {
            });
        };
        return ChunkedBufferResource;
    })(pre.AbstractBufferResource);
    pre.ChunkedBufferResource = ChunkedBufferResource;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var ChunkedTextureResource = (function (_super) {
        __extends(ChunkedTextureResource, _super);
        function ChunkedTextureResource(type, fetch) {
            _super.call(this, type, fetch);
            this._levels = 1;
            this._loadedLevelsCount = 0;
        }
        ChunkedTextureResource.Create = function (type, data) {
            return new ChunkedTextureResource(type, function (callback) {
                return data;
            });
        };

        ChunkedTextureResource.CreateLazy = function (type, fetch) {
            return new ChunkedTextureResource(type, fetch);
        };

        ChunkedTextureResource.prototype.setLevels = function (val) {
            this._levels = val;
        };

        ChunkedTextureResource.prototype.incLoadedLevelsCount = function (count) {
            if (typeof count === &quot;undefined&quot;) { count = 1; }
            this._loadedLevelsCount += count;
        };

        ChunkedTextureResource.prototype.getLoadedLevelsCount = function () {
            return this._loadedLevelsCount;
        };
        return ChunkedTextureResource;
    })(pre.AbstractTextureResource);
    pre.ChunkedTextureResource = ChunkedTextureResource;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var ObjectResource = (function (_super) {
        __extends(ObjectResource, _super);
        function ObjectResource(type, fetch) {
            _super.call(this, type, fetch);
        }
        ObjectResource.Create = function (data) {
            return new pre.Resource(0 /* OBJECT */, function (callback) {
                return data;
            });
        };

        ObjectResource.CreateLazy = function (fetch) {
            return new pre.Resource(0 /* OBJECT */, fetch);
        };

        ObjectResource.prototype.equals = function (other) {
            if (this.getType() == other.getType() &amp;&amp; this.constructor == other.constructor) {
                var data = this.getData();
                var otherData = other.getData();

                return data === otherData;
            }
            return false;
        };
        return ObjectResource;
    })(pre.AbstractResource);
    pre.ObjectResource = ObjectResource;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var TextureResource = (function (_super) {
        __extends(TextureResource, _super);
        function TextureResource(type, fetch) {
            _super.call(this, type, fetch);
        }
        TextureResource.Create = function (type, data) {
            return new TextureResource(type, function (callback) {
                return data;
            });
        };

        TextureResource.CreateLazy = function (type, fetch) {
            return new TextureResource(type, fetch);
        };
        return TextureResource;
    })(pre.AbstractTextureResource);
    pre.TextureResource = TextureResource;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var AbstractCamera = (function () {
        function AbstractCamera() {
            this._viewChangedListener = [];
            this._viewMatrixVersion = -1;
            this._projectionMatrixVersion = -1;
            this._projectionMatrixNeedsRecompute = true;
            this._sceneVolume = new pre.BoxVolume();
            this._autoComputeNearFar = true;
            this._zNear = 0.01;
            this._zFar = 1000;
            this._aspectRatio = 1;
            this._frustum = new pre.Frustum();
            this._viewProjectionMatrix = mat4.create();

            this._viewMatrix = pre.Resource.Create(pre.ResourceType.mat4f, mat4.create());
            this._projectionMatrix = pre.Resource.Create(pre.ResourceType.mat4f, mat4.create());
            this._pivotPoint = pre.Resource.Create(pre.ResourceType.vec3f, vec3.create());
        }
        AbstractCamera.prototype._computeProjectionMatrix = function () {
        };

        AbstractCamera.prototype._updateNearFarFromSceneVolume = function () {
            var sceneVolumeViewSpace;

            if (this._sceneVolume.isValid()) {
                sceneVolumeViewSpace = new pre.BoxVolume();

                sceneVolumeViewSpace.transformFrom(this._viewMatrix.getData(), this._sceneVolume);

                this._zNear = Math.max(0, -1.0 * sceneVolumeViewSpace.getMax()[2]);
                this._zFar = Math.max(0, -1.0 * sceneVolumeViewSpace.getMin()[2]);

                if (this._zNear == 0) {
                    this._zNear = this._zFar / AbstractCamera._MAX_FAR_NEAR_RATIO;
                } else {
                    this._zNear = this._zFar / Math.min(this._zFar / this._zNear, AbstractCamera._MAX_FAR_NEAR_RATIO);
                }
            } else {
            }
        };

        AbstractCamera.prototype.toggleAutoComputeNearFar = function (b) {
            if (this._autoComputeNearFar != b) {
                this._autoComputeNearFar = b;

                if (b) {
                }
            }
        };

        AbstractCamera.prototype.updateSceneVolume = function (vol) {
            this._sceneVolume.copy(vol);
        };

        AbstractCamera.prototype.getSceneVolume = function () {
            return this._sceneVolume;
        };

        AbstractCamera.prototype.getViewMatrixResource = function () {
            return this._viewMatrix;
        };

        AbstractCamera.prototype.requestProjectionMatrix = function () {
            if (this._autoComputeNearFar) {
                this._updateNearFarFromSceneVolume();
                this._computeProjectionMatrix();

                this._projectionMatrix.setDirty();
            } else if (this._projectionMatrixNeedsRecompute) {
                this._computeProjectionMatrix();

                this._projectionMatrix.setDirty();
            }

            return this._projectionMatrix;
        };

        AbstractCamera.prototype.getViewDir = function () {
            var viewMatInv = mat4.create();
            mat4.invert(viewMatInv, this._viewMatrix.getData());

            return vec3.fromValues(-viewMatInv[8], -viewMatInv[9], -viewMatInv[10]);
        };

        AbstractCamera.prototype.getUpVec = function () {
            var viewMatInv = mat4.create();
            mat4.invert(viewMatInv, this._viewMatrix.getData());

            return vec3.fromValues(viewMatInv[4], viewMatInv[5], viewMatInv[6]);
        };

        AbstractCamera.prototype.getFrustum = function () {
            if (this._viewMatrix.getVersion() != this._viewMatrixVersion || this._projectionMatrix.getVersion() != this._projectionMatrixVersion) {
                this._frustum.calcFrustum(this._viewMatrix.getData(), this.requestProjectionMatrix().getData(), true);
                this._viewMatrixVersion = this._viewMatrix.getVersion();
                this._projectionMatrixVersion = this._projectionMatrix.getVersion();
            }
            return this._frustum;
        };

        AbstractCamera.prototype.getImagePlaneHeightAtDistanceOne = function () {
            return 2.0;
        };

        AbstractCamera.prototype.getZNear = function () {
            return this._zNear;
        };

        AbstractCamera.prototype.setZNear = function (zNear) {
            if (this._zNear != zNear) {
                this._projectionMatrixNeedsRecompute = true;
            }

            this._zNear = zNear;
        };

        AbstractCamera.prototype.getZFar = function () {
            return this._zFar;
        };

        AbstractCamera.prototype.setZFar = function (zFar) {
            if (this._zFar != zFar) {
                this._projectionMatrixNeedsRecompute = true;
            }

            this._zFar = zFar;
        };

        AbstractCamera.prototype.getAspectRatio = function () {
            return this._aspectRatio;
        };

        AbstractCamera.prototype.setAspectRatio = function (ratio) {
            if (this._aspectRatio != ratio) {
                this._projectionMatrixNeedsRecompute = true;
            }

            this._aspectRatio = ratio;
        };

        AbstractCamera.prototype.getMutableViewMatrix = function () {
            return this._viewMatrix.getData();
        };

        AbstractCamera.prototype.dirtyMutableViewMatrix = function () {
            for (var i = 0, n = this._viewChangedListener.length; i &lt; n; i++) {
                this._viewChangedListener[i].viewChanged(this._viewMatrix.getData());
            }

            this._viewMatrix.setDirty();
        };

        AbstractCamera.prototype.getMutableCenterOfRotation = function () {
            return this._pivotPoint.getData();
        };

        AbstractCamera.prototype.dirtyMutableCenterOfRotation = function () {
            this._pivotPoint.setDirty();
        };

        AbstractCamera.prototype.computeFitMatrixForVolume = function (result, volume, viewDir, upVec) {
        };

        AbstractCamera.prototype.fitViewToVolume = function (volume, viewDir, upVec) {
        };

        AbstractCamera.prototype.addViewChangedListener = function (listener) {
            if (this._viewChangedListener.indexOf(listener) == -1) {
                this._viewChangedListener.push(listener);
            }
        };

        AbstractCamera.prototype.removeViewChangedListener = function (listener) {
            var idx = this._viewChangedListener.indexOf(listener);

            if (idx != -1) {
                this._viewChangedListener.splice(idx, 1);
            }
        };
        AbstractCamera._MAX_FAR_NEAR_RATIO = 1000;
        return AbstractCamera;
    })();
    pre.AbstractCamera = AbstractCamera;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var AbstractLight = (function () {
        function AbstractLight(vector, color) {
            if (typeof vector === &quot;undefined&quot;) { vector = null; }
            if (typeof color === &quot;undefined&quot;) { color = null; }
            this._vector = vector;
            this._color = color;
        }
        AbstractLight.prototype.getVector = function () {
            return this._vector;
        };

        AbstractLight.prototype.setVector = function (vector) {
            this._vector = vector;
        };

        AbstractLight.prototype.getColor = function () {
            return this._color;
        };

        AbstractLight.prototype.setColor = function (color) {
            this._color = color;
        };

        AbstractLight.prototype.getTypeFlag = function () {
            return 0;
        };
        return AbstractLight;
    })();
    pre.AbstractLight = AbstractLight;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var DirectionalLight = (function (_super) {
        __extends(DirectionalLight, _super);
        function DirectionalLight(direction, color) {
            if (typeof direction === &quot;undefined&quot;) { direction = null; }
            if (typeof color === &quot;undefined&quot;) { color = null; }
            _super.call(this, direction, color);
        }
        DirectionalLight.prototype.getDirection = function () {
            return this.getVector();
        };

        DirectionalLight.prototype.setDirection = function (direction) {
            this.setVector(direction);
        };

        DirectionalLight.prototype.getTypeFlag = function () {
            return 2;
        };
        return DirectionalLight;
    })(pre.AbstractLight);
    pre.DirectionalLight = DirectionalLight;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var OrthoCamera = (function (_super) {
        __extends(OrthoCamera, _super);
        function OrthoCamera() {
            _super.apply(this, arguments);
        }
        OrthoCamera.prototype._computeProjectionMatrix = function () {
        };
        return OrthoCamera;
    })(pre.AbstractCamera);
    pre.OrthoCamera = OrthoCamera;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var PerspectiveCamera = (function (_super) {
        __extends(PerspectiveCamera, _super);
        function PerspectiveCamera() {
            _super.apply(this, arguments);
            this._fieldOfView = 0.7853981;
        }
        PerspectiveCamera.prototype._computeProjectionMatrix = function () {
            mat4.perspective(this._projectionMatrix.getData(), this._fieldOfView, this._aspectRatio, this._zNear, this._zFar);
        };

        PerspectiveCamera.prototype.getFieldOfView = function () {
            return this._fieldOfView;
        };

        PerspectiveCamera.prototype.setFieldOfView = function (fov) {
            if (this._fieldOfView != fov) {
                this._projectionMatrixNeedsRecompute = true;
            }

            this._fieldOfView = fov;
        };

        PerspectiveCamera.prototype.getImagePlaneHeightAtDistanceOne = function () {
            return 2.0 * Math.tan(this._fieldOfView / 2.0);
        };

        PerspectiveCamera.prototype.computeFitMatrixForVolume = function (result, volume, viewDir, upVec) {
            var center = volume.getCenter();
            var boundingSphereRadius = 0.5 * volume.getDiameter();

            var fov = Math.min(this._fieldOfView, this._fieldOfView * this._aspectRatio);

            var idealDist = boundingSphereRadius / Math.tan(fov * 0.5);

            var distVec = vec3.create();
            vec3.scale(distVec, viewDir, idealDist);

            var eye = vec3.create();
            vec3.subtract(eye, center, distVec);

            mat4.lookAt(result, eye, center, upVec);
        };

        PerspectiveCamera.prototype.fitViewToVolume = function (volume, viewDir, upVec) {
            this.computeFitMatrixForVolume(this.getMutableViewMatrix(), volume, viewDir, upVec);

            this.dirtyMutableViewMatrix();
        };
        return PerspectiveCamera;
    })(pre.AbstractCamera);
    pre.PerspectiveCamera = PerspectiveCamera;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight(position, color) {
            if (typeof position === &quot;undefined&quot;) { position = null; }
            if (typeof color === &quot;undefined&quot;) { color = null; }
            _super.call(this, position, color);
        }
        PointLight.prototype.getPosition = function () {
            return this.getVector();
        };

        PointLight.prototype.setPosition = function (position) {
            this.setVector(position);
        };

        PointLight.prototype.getTypeFlag = function () {
            return 1;
        };
        return PointLight;
    })(pre.AbstractLight);
    pre.PointLight = PointLight;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var BoxVolume = (function () {
        function BoxVolume(min, max) {
            if (typeof min === &quot;undefined&quot;) { min = null; }
            if (typeof max === &quot;undefined&quot;) { max = null; }
            this._validMin = false;
            this._validMax = false;
            this._center = vec3.fromValues(0, 0, 0);
            this._radialVec = vec3.fromValues(0, 0, 0);
            this._diameter = null;
            if (min &amp;&amp; max) {
                this._min = min;
                this._max = max;
                this.setValid();
                this._updateInternals();
            } else {
                this._min = vec3.fromValues(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
                this._max = vec3.fromValues(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
                this._validMin = false;
                this._validMax = false;
            }
        }
        BoxVolume.prototype._updateInternals = function () {
            if (this._validMin &amp;&amp; this._validMax) {
                vec3.sub(this._radialVec, this._max, this._min);

                vec3.scale(this._radialVec, this._radialVec, 0.5);

                vec3.add(this._center, this._min, this._radialVec);

                this._diameter = 2 * vec3.length(this._radialVec);
            }
        };

        BoxVolume.prototype._setDirectionIndexPoint = function (index) {
            if (index &amp; 1) {
                BoxVolume._DirectionIndexPoint[0] = this._min[0];
            } else {
                BoxVolume._DirectionIndexPoint[0] = this._max[0];
            }
            if (index &amp; 2) {
                BoxVolume._DirectionIndexPoint[1] = this._min[1];
            } else {
                BoxVolume._DirectionIndexPoint[1] = this._max[1];
            }
            if (index &amp; 4) {
                BoxVolume._DirectionIndexPoint[2] = this._min[2];
            } else {
                BoxVolume._DirectionIndexPoint[2] = this._max[2];
            }
        };

        BoxVolume.prototype.isValid = function () {
            return this._validMin &amp;&amp; this._validMax &amp;&amp; util.vec3Ext.lequal(this._min, this._max);
        };

        BoxVolume.prototype.setValid = function (valid) {
            if (typeof valid === &quot;undefined&quot;) { valid = true; }
            this._validMin = valid;
            this._validMax = valid;
        };

        BoxVolume.prototype.reset = function () {
            vec3.set(this._min, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
            vec3.set(this._max, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
            this._validMin = false;
            this._validMax = false;
        };

        BoxVolume.prototype.setFromCenterSize = function (center, size) {
            vec3.scaleAndAdd(this._min, center, size, -0.5);
            vec3.scaleAndAdd(this._max, center, size, 0.5);
            this.setValid();
            this._updateInternals();
        };

        BoxVolume.prototype.setMin = function (min) {
            vec3.copy(this._min, min);
            this._validMin = true;

            this._updateInternals();
        };

        BoxVolume.prototype.setMax = function (max) {
            vec3.copy(this._max, max);
            this._validMax = true;

            this._updateInternals();
        };

        BoxVolume.prototype.includePoint = function (p) {
            this.extend(p, p);
        };

        BoxVolume.prototype.extend = function (newMin, newMax) {
            if (this._validMin) {
                vec3.min(this._min, this._min, newMin);
            } else {
                vec3.copy(this._min, newMin);
                this._validMin = true;
            }

            if (this._validMax) {
                vec3.max(this._max, this._max, newMax);
            } else {
                vec3.copy(this._max, newMax);
                this._validMax = true;
            }

            this._updateInternals();
        };

        BoxVolume.prototype.extendByVolume = function (other) {
            if (other.isValid()) {
                this.extend(other.getMin(), other.getMax());
            }
        };

        BoxVolume.prototype.extendByTransformedVolume = function (other, transform) {
            if (typeof transform === &quot;undefined&quot;) { transform = null; }
            if (transform) {
                if (this.isValid()) {
                    BoxVolume._TmpBoxVolume.transformFrom(transform, other);
                    this.extendByVolume(BoxVolume._TmpBoxVolume);
                } else if (other.isValid()) {
                    this.transformFrom(transform, other);
                }
            } else {
                this.extendByVolume(other);
            }
        };

        BoxVolume.prototype.getMin = function () {
            return this._min;
        };

        BoxVolume.prototype.getMax = function () {
            return this._max;
        };

        BoxVolume.prototype.getCenter = function () {
            return this._center;
        };

        BoxVolume.prototype.getRadialVec = function () {
            return this._radialVec;
        };

        BoxVolume.prototype.getDiameter = function () {
            return this._diameter;
        };

        BoxVolume.prototype.copy = function (other) {
            vec3.copy(this._min, other._min);
            vec3.copy(this._max, other._max);

            this._validMin = other._validMin;
            this._validMax = other._validMax;

            this._center = other._center;
            this._radialVec = other._radialVec;
            this._diameter = other._diameter;
        };

        BoxVolume.prototype.getDistance = function (index, plane) {
            this._setDirectionIndexPoint(index);
            return plane.getDistance(BoxVolume._DirectionIndexPoint);
        };

        BoxVolume.prototype.transformFrom = function (matrix, other) {
            if (other.isValid()) {
                var min = other.getMin(), max = other.getMax();

                var bb = [
                    vec3.clone(min),
                    vec3.fromValues(min[0], min[1], max[2]),
                    vec3.fromValues(min[0], max[1], min[2]),
                    vec3.fromValues(min[0], max[1], max[2]),
                    vec3.fromValues(max[0], min[1], min[2]),
                    vec3.fromValues(max[0], min[1], max[2]),
                    vec3.fromValues(max[0], max[1], min[2]),
                    vec3.clone(max)
                ];

                vec3.transformMat4(bb[0], bb[0], matrix);
                vec3.copy(this._min, bb[0]);
                vec3.copy(this._max, bb[0]);

                for (var i = 1; i &lt; 8; ++i) {
                    vec3.transformMat4(bb[i], bb[i], matrix);
                    vec3.min(this._min, this._min, bb[i]);
                    vec3.max(this._max, this._max, bb[i]);
                }

                this.setValid();
                this._updateInternals();
            }
        };

        BoxVolume.prototype.overlaps = function (other) {
            var t = vec3.create();
            vec3.subtract(t, other._center, this._center);

            var extThis = vec3.fromValues(Math.abs(this._radialVec[0]), Math.abs(this._radialVec[1]), Math.abs(this._radialVec[2]));
            var extOther = vec3.fromValues(Math.abs(other._radialVec[0]), Math.abs(other._radialVec[1]), Math.abs(other._radialVec[2]));

            return Math.abs(t[0]) &lt;= (extThis[0] + extOther[0]) &amp;&amp; Math.abs(t[1]) &lt;= (extThis[1] + extOther[1]) &amp;&amp; Math.abs(t[2]) &lt;= (extThis[2] + extOther[2]);
        };

        BoxVolume.prototype.equals = function (other) {
            if (!this.isValid() || !other.isValid()) {
                return false;
            }
            return Math.abs(this._min[0] - other._min[0]) &lt; BoxVolume._compDelta &amp;&amp; Math.abs(this._min[1] - other._min[1]) &lt; BoxVolume._compDelta &amp;&amp; Math.abs(this._min[2] - other._min[2]) &lt; BoxVolume._compDelta &amp;&amp; Math.abs(this._max[0] - other._max[0]) &lt; BoxVolume._compDelta &amp;&amp; Math.abs(this._max[1] - other._max[1]) &lt; BoxVolume._compDelta &amp;&amp; Math.abs(this._max[2] - other._max[2]) &lt; BoxVolume._compDelta;
        };
        BoxVolume._TmpBoxVolume = new BoxVolume();
        BoxVolume._compDelta = 0.000001;

        BoxVolume._DirectionIndexPoint = vec3.create();
        return BoxVolume;
    })();
    pre.BoxVolume = BoxVolume;
})(pre || (pre = {}));
var pre;
(function (pre) {
    (function (FrustumPlanes) {
        FrustumPlanes[FrustumPlanes[&quot;NEAR_PLANE&quot;] = 0] = &quot;NEAR_PLANE&quot;;
        FrustumPlanes[FrustumPlanes[&quot;FAR_PLANE&quot;] = 1] = &quot;FAR_PLANE&quot;;
        FrustumPlanes[FrustumPlanes[&quot;LEFT_PLANE&quot;] = 2] = &quot;LEFT_PLANE&quot;;
        FrustumPlanes[FrustumPlanes[&quot;RIGHT_PLANE&quot;] = 3] = &quot;RIGHT_PLANE&quot;;
        FrustumPlanes[FrustumPlanes[&quot;TOP_PLANE&quot;] = 4] = &quot;TOP_PLANE&quot;;
        FrustumPlanes[FrustumPlanes[&quot;BOTTOM_PLANE&quot;] = 5] = &quot;BOTTOM_PLANE&quot;;
        FrustumPlanes[FrustumPlanes[&quot;NUM_PLANES&quot;] = 6] = &quot;NUM_PLANES&quot;;
    })(pre.FrustumPlanes || (pre.FrustumPlanes = {}));
    var FrustumPlanes = pre.FrustumPlanes;

    var Frustum = (function () {
        function Frustum() {
            this._clipPlanes = [];
            this._directionIndices = [0, 0, 0, 0, 0, 0];
            var i;
            for (i = 0; i &lt; 6 /* NUM_PLANES */; ++i) {
                this._clipPlanes.push(new pre.Plane());
            }
        }
        Frustum.prototype._testPlane = function (node, planeIndex) {
            var planeMask = node.getPlaneMask();

            var mask = 1;
            mask &lt;&lt;= planeIndex;

            if (planeMask &amp; mask) {
                return true;
            }

            var box = node.requestWorldVolume();
            var plane = this._clipPlanes[planeIndex];

            var distance = box.getDistance(this._directionIndices[planeIndex] ^ 7, plane);
            if (distance &lt; 0.0) {
                node.setPreferredPlane(planeIndex);
                return false;
            }

            distance = box.getDistance(this._directionIndices[planeIndex], plane);
            if (distance &gt;= 0.0) {
                planeMask |= mask;
                node.setPlaneMask(planeMask);
            } else {
                node.setIntersect(true);
            }

            return true;
        };

        Frustum._GetDirectionIndexPoint = function (planeNormal) {
            var ind = 0;
            if (planeNormal[0] &gt; 0)
                ind |= 1;
            if (planeNormal[1] &gt; 0)
                ind |= 2;
            if (planeNormal[2] &gt; 0)
                ind |= 4;
            return ind;
        };

        Frustum.prototype.calcFrustum = function (view, projection, normalize) {
            var i, row;

            var mat = mat4.clone(view);

            mat4.multiply(mat, projection, mat);

            for (i = 0; i &lt; 4; ++i) {
                row = i * 4;

                this._clipPlanes[3 /* RIGHT_PLANE */]._normalWithDistance[i] = mat[row + 3] - mat[row];
                this._clipPlanes[2 /* LEFT_PLANE */]._normalWithDistance[i] = mat[row + 3] + mat[row];

                this._clipPlanes[5 /* BOTTOM_PLANE */]._normalWithDistance[i] = mat[row + 3] + mat[row + 1];
                this._clipPlanes[4 /* TOP_PLANE */]._normalWithDistance[i] = mat[row + 3] - mat[row + 1];

                this._clipPlanes[1 /* FAR_PLANE */]._normalWithDistance[i] = mat[row + 3] - mat[row + 2];
                this._clipPlanes[0 /* NEAR_PLANE */]._normalWithDistance[i] = mat[row + 3] + mat[row + 2];
            }

            if (normalize) {
                var normal = null;
                for (i = 0; i &lt; this._clipPlanes.length; ++i) {
                    if (this._clipPlanes[i] == null) {
                        continue;
                    }
                    normal = this._clipPlanes[i]._normalWithDistance;

                    if (i &lt; 6) {
                        var invLength = 1.0 / vec3.length(this._clipPlanes[i]._normalWithDistance);
                        normal[0] *= invLength;
                        normal[1] *= invLength;
                        normal[2] *= invLength;
                        normal[3] *= -invLength;
                    }

                    this._directionIndices[i] = Frustum._GetDirectionIndexPoint(normal);
                }
            }
        };

        Frustum.prototype.nodeIsWithinFrustum = function (node) {
            if (!node.requestWorldVolume().isValid()) {
                return 1;
            }

            var i, n, parent = node.getParent();

            node.setIntersect(false);

            if (parent) {
                node.setPlaneMask(parent.getPlaneMask());
            }

            var prefPlane = node.getPreferredPlane();

            for (i = prefPlane, n = this._clipPlanes.length; i &lt; n; ++i) {
                if (this._clipPlanes[i] == null || !this._clipPlanes[i].isEnabled()) {
                    continue;
                }
                if (!this._testPlane(node, i))
                    return 0;
            }

            for (i = 0; i &lt; prefPlane; ++i) {
                if (this._clipPlanes[i] == null || !this._clipPlanes[i].isEnabled()) {
                    continue;
                }
                if (!this._testPlane(node, i))
                    return 0;
            }

            return node.getIntersect() ? -1 : 1;
        };

        Frustum.prototype.getPlanes = function () {
            return this._clipPlanes;
        };

        Frustum.prototype.addPlane = function (plane) {
            var index = this._clipPlanes.push(plane) - 1;
            this._directionIndices.push(Frustum._GetDirectionIndexPoint(plane._normalWithDistance));

            return index;
        };

        Frustum.prototype.removePlane = function (index) {
            this._clipPlanes.splice(index, 1);
            this._directionIndices.splice(index, 1);
        };
        return Frustum;
    })();
    pre.Frustum = Frustum;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var Plane = (function () {
        function Plane(normalWithDistance, enabled) {
            this._normalWithDistance = normalWithDistance || vec4.create();
            this._enabled = enabled || new Float32Array([1]);
        }
        Plane.prototype.setValues = function (normal, point) {
            vec3.copy(this._normalWithDistance, normal);
            this.setPoint(point);
        };

        Plane.prototype.setNormal = function (normal) {
            vec3.copy(this._normalWithDistance, normal);
            if (this._point) {
                this.setPoint(this._point);
            }
        };

        Plane.prototype.setPoint = function (point) {
            this._point = point;
            this._normalWithDistance[3] = vec3.dot(this._normalWithDistance, point);
        };

        Plane.prototype.getDistance = function (point) {
            return vec3.dot(point, this._normalWithDistance) - this._normalWithDistance[3];
        };

        Plane.prototype.setEnabled = function (enabled) {
            if (typeof enabled === &quot;undefined&quot;) { enabled = true; }
            this._enabled[0] = enabled ? 1 : 0;
        };

        Plane.prototype.isEnabled = function () {
            return this._enabled[0] &gt; 0;
        };
        return Plane;
    })();
    pre.Plane = Plane;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var DrawableContainer = (function () {
        function DrawableContainer() {
            this._drawables = [];
        }
        DrawableContainer.prototype.clearDrawables = function () {
            this._drawables = [];
        };

        DrawableContainer.prototype.addDrawable = function (drawable) {
            this._drawables.push(drawable);
            return true;
        };

        DrawableContainer.prototype.removeDrawable = function (drawable) {
            var index = this._drawables.indexOf(drawable);
            if (index &gt; -1)
                this._drawables.splice(index, 1);
            return true;
        };

        DrawableContainer.prototype.getDrawables = function () {
            return this._drawables;
        };

        DrawableContainer.prototype.getDrawableCount = function () {
            return this._drawables.length;
        };
        return DrawableContainer;
    })();
    pre.DrawableContainer = DrawableContainer;
})(pre || (pre = {}));

var pre;
(function (pre) {
    var OcclusionQuery = (function () {
        function OcclusionQuery(id) {
            this._id = -1;
            this._nodes = [];
            this._id = id;
            this._qry = OcclusionQuery._renderer.createQuery();
        }
        OcclusionQuery.setRenderer = function (renderer) {
            OcclusionQuery._renderer = renderer;
        };

        OcclusionQuery.prototype.reset = function () {
            this._nodes.length = 0;
        };

        OcclusionQuery.prototype.getSize = function () {
            return this._nodes.length;
        };

        OcclusionQuery.prototype.addNode = function (node) {
            this._nodes.push(node);
        };

        OcclusionQuery.prototype.getNodes = function () {
            return this._nodes;
        };

        OcclusionQuery.prototype.deleteQuery = function () {
            OcclusionQuery._renderer.deleteQuery(this._qry);
        };

        OcclusionQuery.prototype.beginQuery = function () {
            OcclusionQuery._renderer.beginQuery(this._qry);
            OcclusionQuery.currentQuery = this;
        };

        OcclusionQuery.prototype.endQuery = function () {
            OcclusionQuery._renderer.endQuery();
        };

        OcclusionQuery.prototype.resultAvailable = function () {
            return OcclusionQuery._renderer.queryResultAvailable(this._qry);
        };

        OcclusionQuery.prototype.getQueryResult = function () {
            return OcclusionQuery._renderer.getQueryResult(this._qry);
        };
        OcclusionQuery._renderer = null;
        OcclusionQuery.currentQuery = null;
        return OcclusionQuery;
    })();
    pre.OcclusionQuery = OcclusionQuery;

    var ASMCuller = (function (_super) {
        __extends(ASMCuller, _super);
        function ASMCuller(application) {
            _super.call(this, application);
            this._renderTargetHeight = 0;
            this._renderStateId = 0;
            this._drawmapRenderState = new pre.RenderState();
            this._queryRenderState = new pre.RenderState();
            this._renderer = null;
            this._pipelineControl = null;
            this._drawMapInput = [];
            this._drawMapSlot = null;
            this._drawMapRenderPass = null;
            this._queryPass = null;
            this._stats = null;
            this._occlusionQueries = [];
            this._nodeMatrices = [];

            if (ASMCuller.instance == null) {
                ASMCuller.instance = this;
            } else {
                throw new Error(&quot;Multiple ASMCuller not supported yet&quot;);
            }
            this._pipelineControl = new pre.PipelineControl();

            this._pipelineControl.setFlag(0 /* FULL */);
            this._pipelineControl.newFrame(0);

            this._drawmapRenderState.blendEnabled = true;
            this._drawmapRenderState.colorMask = [true, true, true, true];
            this._drawmapRenderState.depthMask = true;

            this._queryRenderState.blendEnabled = false;
            this._queryRenderState.colorMask = [false, false, false, false];
            this._queryRenderState.depthMask = false;

            var renderTarget = application.getCanvasViews()[0].getHTMLCanvasRenderTarget();
            this._renderTargetHeight = renderTarget.getHeight();

            this._renderer = application.getDefaultRenderer();
            OcclusionQuery.setRenderer(this._renderer);

            this._drawMapSlot = new pre.Slot(&quot;drawables&quot;, pre.ObjectResource.Create(this._drawMapInput));
            this._drawMapRenderPass = new pre.DrawMapRenderPass(application);
            this._drawMapRenderPass.setRenderer(this._renderer);
            this._drawMapRenderPass.getInputSlot(&quot;drawables&quot;).connectOutput(this._drawMapSlot);
            this._drawMapRenderPass.setRenderState(this._drawmapRenderState);
            this._drawMapRenderPass.setRenderTarget(renderTarget);

            var pickingPasses = application.getStages(pre.PickingRenderPass);
            var i = 0, n = pickingPasses.length;

            for (; i &lt; n; i++) {
                pickingPasses[i].getInputSlot(&quot;drawables&quot;).connectOutput(this._drawMapSlot);
            }

            this._queryPass = new pre.BoxVolumeRenderPass(application);
            this._queryPass.setRenderer(this._renderer);
            this._queryPass.setRenderState(this._queryRenderState);
            this._queryPass.setRenderTarget(renderTarget);
            this._queryPass.setBoxVolumePrimitiveType(pre.PrimitiveType.TRIANGLES);

            this._setCompileSetupValues = Module.cwrap('setCompileSetupValues', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
            this._createCuller = Module.cwrap('createCuller', 'number', []);
            this._addDrawableWithBoundingBox = Module.cwrap('addDrawableWithBoundingBox', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
            this._doCompile = Module.cwrap('compile', 'number', []);
            this._setTraverseSetupValues = Module.cwrap('setTraverseSetupValues', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
            this._setViewMatrix = Module.cwrap('setViewMatrix', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
            this._setProjectionMatrix = Module.cwrap('setProjectionMatrix', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
            this._setWorldSpaceEyePosition = Module.cwrap('setWorldSpaceEyePosition', 'number', ['number', 'number', 'number']);
            this._setViewFrustum = Module.cwrap('setViewFrustum', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
            this._cull = Module.cwrap('cull', 'number', []);
            this._printTree = Module.cwrap('printTree', 'number', []);

            this._stats = util.Statistics.getInstance();
        }
        ASMCuller.prototype._runCuller = function (context) {
            var camera = context.getCamera();

            var viewMatrix = camera.getViewMatrixResource().getData();
            var projectionMatrix = camera.requestProjectionMatrix().getData();
            this._setViewMatrix(viewMatrix[0], viewMatrix[4], viewMatrix[8], viewMatrix[12], viewMatrix[1], viewMatrix[5], viewMatrix[9], viewMatrix[13], viewMatrix[2], viewMatrix[6], viewMatrix[10], viewMatrix[14], viewMatrix[3], viewMatrix[7], viewMatrix[11], viewMatrix[15]);

            this._setProjectionMatrix(projectionMatrix[0], projectionMatrix[4], projectionMatrix[8], projectionMatrix[12], projectionMatrix[1], projectionMatrix[5], projectionMatrix[9], projectionMatrix[13], projectionMatrix[2], projectionMatrix[6], projectionMatrix[10], projectionMatrix[14], projectionMatrix[3], projectionMatrix[7], projectionMatrix[11], projectionMatrix[15]);

            var frustumPlanes = camera.getFrustum().getPlanes();

            this._setViewFrustum(frustumPlanes[0]._normalWithDistance[0], frustumPlanes[0]._normalWithDistance[1], frustumPlanes[0]._normalWithDistance[2], frustumPlanes[0]._normalWithDistance[3], frustumPlanes[1]._normalWithDistance[0], frustumPlanes[1]._normalWithDistance[1], frustumPlanes[1]._normalWithDistance[2], frustumPlanes[1]._normalWithDistance[3], frustumPlanes[2]._normalWithDistance[0], frustumPlanes[2]._normalWithDistance[1], frustumPlanes[2]._normalWithDistance[2], frustumPlanes[2]._normalWithDistance[3], frustumPlanes[3]._normalWithDistance[0], frustumPlanes[3]._normalWithDistance[1], frustumPlanes[3]._normalWithDistance[2], frustumPlanes[3]._normalWithDistance[3], frustumPlanes[4]._normalWithDistance[0], frustumPlanes[4]._normalWithDistance[1], frustumPlanes[4]._normalWithDistance[2], frustumPlanes[4]._normalWithDistance[3], frustumPlanes[5]._normalWithDistance[0], frustumPlanes[5]._normalWithDistance[1], frustumPlanes[5]._normalWithDistance[2], frustumPlanes[5]._normalWithDistance[3]);

            var cor = camera.getMutableCenterOfRotation();
            this._setWorldSpaceEyePosition(cor[0], cor[1], cor[2]);

            var settings = context.getApplication().getSettings();
            var sft = settings.smallFeatureTreshold * this._renderTargetHeight;
            var pixelHeightAtDistOne = (camera.getImagePlaneHeightAtDistanceOne() / this._renderTargetHeight) * 2;

            var pipelineControl = this._context.getApplication().getPipelineControl();

            var interaction = pipelineControl.isNavigating();
            var frameID = pipelineControl.getCurrentFrame();

            var queryBatchSize = Math.min(Math.pow(2, frameID), 1024);

            var sft = this._context.getApplication().getSettings().smallFeatureTreshold * this._renderTargetHeight;

            this._setTraverseSetupValues(frameID, this._traverserType, 0, 1, 1, interaction ? sft * 5 : sft, queryBatchSize, 1000, 7, 1, 0.8, pixelHeightAtDistOne, camera.getZNear());

            this._cull();
        };

        ASMCuller.prototype.addNodeAsBoxVolume = function (id, depth, minX, minY, minZ, maxX, maxY, maxZ) {
            if (this._nodeMatrices.length != id) {
                console.log(&quot;Error, invalid node count&quot;);
            }
            var bbox = new pre.BoxVolume(vec3.fromValues(minX, minY, minZ), vec3.fromValues(maxX, maxY, maxZ));

            var matrix = mat4.create();
            mat4.translate(matrix, matrix, bbox.getCenter());
            mat4.scale(matrix, matrix, bbox.getRadialVec());

            this._nodeMatrices.push(matrix);
        };

        ASMCuller.prototype.addRenderTreeNodeForRendering = function (id, coverage) {
            var renderTreeNode = this._renderTreeNodes[id], drawables, drawable, i;

            if (renderTreeNode.isEnabled()) {
                drawables = renderTreeNode.getDrawables();

                for (i = 0; i &lt; drawables.length; ++i) {
                    drawable = drawables[i];
                    drawable.getDrawingInfo().screenSpaceFootPrint = coverage / this._renderTargetHeight;
                    this._drawMapInput.push(drawable);
                }
            }
        };

        ASMCuller.prototype.triggerRendering = function (state) {
            this._stats.stopMeasurement(&quot;ASM&quot;);
            this._renderStateId = state;
            if (state == 0) {
                 {
                    this._drawMapRenderPass.execute(this._context);
                }
            } else if (state == 1) {
                this._stats.startMeasurement(&quot;QUERY&quot;);

                var query = OcclusionQuery.currentQuery, nodes = query.getNodes(), i, n = query.getSize();

                for (i = 0; i &lt; n; i++) {
                    this._queryPass.addMatrix(nodes[i]);
                }
                this._queryPass.execute(this._context);
                this._stats.stopMeasurement(&quot;QUERY&quot;);
            }
            this._stats.startMeasurement(&quot;ASM&quot;);
        };

        ASMCuller.prototype.getRenderState = function () {
            return this._renderStateId;
        };

        ASMCuller.prototype.collectDrawables = function (target, context) {
            this._stats.startMeasurement(&quot;ASM&quot;);

            this._context = context;

            var i, n;

            if (!this._compiled) {
                var compileStart = performance.now();
                this._renderTreeNodes = [];
                this.collectSubtreeNodes();
                this.compile();
                this._stats.addValue(&quot;COMPILE (MS)&quot;, Math.ceil(performance.now() - compileStart), &quot;SPATIAL&quot;);
            }

            if (this._compiled &amp;&amp; this._renderTreeNodes.length &gt; 0) {
                this._pipelineControl.setFlag(0 /* FULL */);
                this._pipelineControl.newFrame();

                this._drawMapInput.length = 0;

                this._runCuller(context);

                if (this._context.getApplication().getSettings().showDebugVolumes) {
                    var dbgPass = this._context.getApplication().getDebugRenderPass();
                    var color = vec4.fromValues(0, 1, 1, 1);
                    for (i = 0, n = this._nodeMatrices.length; i &lt; n; ++i) {
                        dbgPass.addMatrix(this._nodeMatrices[i], color);
                    }

                    for (i = 0, n = this._drawables.length; i &lt; n; ++i) {
                        dbgPass.addBoxVolume(this._drawables[i].getWorldVolume());
                    }
                    dbgPass.execute(context);
                }
            }

            this._stats.stopMeasurement(&quot;ASM&quot;);
            return false;
        };

        ASMCuller.prototype.compile = function () {
            var i, n, bbox, min, max;

            this._setCompileSetupValues(1, 1, this._renderTreeNodes.length, this._maxDepth, 10, 0.1);

            this._createCuller();

            for (i = 0; i &lt; this._renderTreeNodes.length;) {
                if (this._renderTreeNodes[i].getDrawables().length == 0) {
                    this._renderTreeNodes.splice(i, 1);
                } else {
                    ++i;
                }
            }

            for (i = 0, n = this._renderTreeNodes.length; i &lt; n; ++i) {
                bbox = this._renderTreeNodes[i].requestWorldVolume();

                min = bbox.getMin();
                max = bbox.getMax();
                this._addDrawableWithBoundingBox(i, min[0], min[1], min[2], max[0], max[1], max[2]);
            }

            this._doCompile();
            _super.prototype.compile.call(this);
        };
        ASMCuller.instance = null;
        return ASMCuller;
    })(pre.SpatialIndexBase);
    pre.ASMCuller = ASMCuller;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var Octree = (function (_super) {
        __extends(Octree, _super);
        function Octree(application) {
            _super.call(this, application);
            this._nodes = [];
            var rootNode = new pre.OctreeNode(this);
            this._nodes.push(rootNode);
        }
        Octree.prototype.collectDrawables = function (target, context) {
            var statistics = util.Statistics.getInstance();
            statistics.startMeasurement(&quot;octree&quot;);
            if (!this._compiled) {
                this._drawables = [];
                this.compile();
            }

            if (this._compiled &amp;&amp; this._drawables.length &gt; 0) {
                this._traverser.setContext(context);
                this._traverser.setTarget(target);
                this._traverser.traverse(this._nodes[0]);

                if (this._compiled) {
                    var i, n;
                    for (i = 0, n = this._nodes.length; i &lt; n; ++i) {
                        context.getApplication().getDebugRenderPass().addBoxVolume(this._nodes[i].getBoxVolume(), vec4.fromValues(0, 0, 1, 1));
                    }
                }
            }
            statistics.stopMeasurement(&quot;octree&quot;);
            return false;
        };

        Octree.prototype.compile = function () {
            var i, n, rootNode = this._nodes[0];

            rootNode.setBoxVolume(this.requestWorldVolume());
            rootNode.setDepth(0);

            for (i = 0, n = this._drawables.length; i &lt; n; ++i) {
                this._rasterizeDrawable(rootNode, i);
            }
            _super.prototype.compile.call(this);
        };

        Octree.prototype._passThroughDrawable = function (node, drawableId) {
            if (node.isLeaf()) {
                node.getDrawableIDs().push(drawableId);
            } else {
                for (var i = 0, n = 8; i &lt; n; ++i) {
                    this._passThroughDrawable(node.getChild(i), drawableId);
                }
            }
        };

        Octree.prototype._rasterizeDrawable = function (node, drawableID) {
            var depth = node.getDepth();
            var i, n, drawableBoxVolume, child = null;

            if (depth &gt;= this._maxDepth) {
                node.getDrawableIDs().push(drawableID);
            } else {
                var volume = node.getBoxVolume(), min = volume.getMin(), max = volume.getMax(), center = volume.getCenter();

                var childVolumes = node.isLeaf() ? [
                    new pre.BoxVolume(min, center),
                    new pre.BoxVolume(vec3.fromValues(center[0], min[1], min[2]), vec3.fromValues(max[0], center[1], center[2])),
                    new pre.BoxVolume(vec3.fromValues(min[0], center[1], min[2]), vec3.fromValues(center[0], max[1], center[2])),
                    new pre.BoxVolume(vec3.fromValues(center[0], center[1], min[2]), vec3.fromValues(max[0], max[1], center[2])),
                    new pre.BoxVolume(vec3.fromValues(min[0], min[1], center[2]), vec3.fromValues(center[0], center[1], max[2])),
                    new pre.BoxVolume(vec3.fromValues(center[0], min[1], center[2]), vec3.fromValues(max[0], center[1], max[2])),
                    new pre.BoxVolume(vec3.fromValues(min[0], center[1], center[2]), vec3.fromValues(center[0], max[1], max[2])),
                    new pre.BoxVolume(center, max)
                ] : [
                    node.getChild(0).getBoxVolume(),
                    node.getChild(1).getBoxVolume(),
                    node.getChild(2).getBoxVolume(),
                    node.getChild(3).getBoxVolume(),
                    node.getChild(4).getBoxVolume(),
                    node.getChild(5).getBoxVolume(),
                    node.getChild(6).getBoxVolume(),
                    node.getChild(7).getBoxVolume()
                ];

                drawableBoxVolume = this._drawables[drawableID].getWorldVolume();

                var recurse = false;
                var overlap = -1;
                for (i = 0, n = 8; i &lt; n; ++i) {
                    if (drawableBoxVolume.overlaps(childVolumes[i])) {
                        if (overlap == -1) {
                            overlap = i;
                            recurse = true;
                        } else {
                            recurse = false;
                        }
                    }
                }

                if (recurse) {
                    if (node.isLeaf()) {
                        for (i = 0, n = 8; i &lt; n; ++i) {
                            child = new pre.OctreeNode(this);
                            this._nodes.push(child);
                            node.addChild(child);
                            child.setDepth(depth + 1);
                            child.setBoxVolume(childVolumes[i]);
                            child.setParent(node);
                        }
                    }
                    this._rasterizeDrawable(node.getChild(overlap), drawableID);
                } else {
                    node.getDrawableIDs().push(drawableID);
                }
            }
        };
        return Octree;
    })(pre.SpatialIndexBase);
    pre.Octree = Octree;
})(pre || (pre = {}));
var pre;
(function (pre) {
    var OctreeNode = (function (_super) {
        __extends(OctreeNode, _super);
        function OctreeNode(octree) {
            _super.call(this, octree);
            this._drawableIDs = [];
            this._enabled = true;
        }
        OctreeNode.prototype.getChild = function (index) {
            return this._children[index];
        };

        OctreeNode.prototype.getChildCount = function () {
            return this._leaf ? 0 : 8;
        };

        OctreeNode.prototype.getDrawableIDs = function () {
            return this._drawableIDs;
        };

        OctreeNode.prototype.setEnabled = function (val) {
            if (typeof val === &quot;undefined&quot;) { val = true; }
            this._enabled = val;
        };

        OctreeNode.prototype.isEnabled = function () {
            return this._enabled;
        };

        OctreeNode.prototype.collectDrawables = function (target, context) {
            for (var i = 0, n = this._drawableIDs.length; i &lt; n; ++i) {
                this._bvh.saveAddDrawable(target, this._drawableIDs[i]);
            }
            return false;
        };
        return OctreeNode;
    })(pre.SpatialIndexNodeBase);
    pre.OctreeNode = OctreeNode;
})(pre || (pre = {}));
var util;
(function (util) {
    var BasicShapes = (function () {
        function BasicShapes() {
        }
        BasicShapes.CreateBoxBuffers = function () {
            BasicShapes._boxLinesVertexBuffer = new pre.BufferResource(pre.ResourceType.FLOAT_32, function (callback) {
                return BasicShapes._boxVertexArray;
            }, 3, false, 0, 0);

            BasicShapes._boxLinesIndexBuffer = new pre.BufferResource(pre.ResourceType.UINT_16, function (callback) {
                return BasicShapes._boxLinesIndexArray;
            }, 1, false, 0, 0);

            var quadIndices = [
                0, 3, 2, 1,
                1, 2, 6, 5,
                5, 6, 7, 4,
                4, 7, 3, 0,
                0, 1, 5, 4,
                3, 7, 6, 2
            ];

            BasicShapes._boxTriangleIndexArray = util.TriangleMeshGenerator.createTriIndicesFromQuadIndices(quadIndices, pre.ResourceType.UINT_16);

            var positionsReference = { array: BasicShapes._boxVertexArray };

            BasicShapes._boxNormalsArray = util.TriangleMeshGenerator.createFlatShadedNormals(BasicShapes._boxTriangleIndexArray, positionsReference, pre.ResourceType.FLOAT_32, pre.ResourceType.FLOAT_32);

            BasicShapes._boxTrianglesVertexBuffer = new pre.BufferResource(pre.ResourceType.FLOAT_32, function (callback) {
                return positionsReference.array;
            }, 3, false, 0, 0);

            BasicShapes._boxTrianglesIndexBuffer = new pre.BufferResource(pre.ResourceType.UINT_16, function (callback) {
                return BasicShapes._boxTriangleIndexArray;
            }, 1, false, 0, 0);

            BasicShapes._boxNormalsBuffer = new pre.BufferResource(pre.ResourceType.FLOAT_32, function (callback) {
                return BasicShapes._boxNormalsArray;
            }, 3, false, 0, 0);

            BasicShapes._boxUVsBuffer = new pre.BufferResource(pre.ResourceType.FLOAT_32, function (callback) {
                return BasicShapes._boxUVsArray;
            }, 2, false, 0, 0);

            BasicShapes._boxCreated = true;
        };

        BasicShapes.AddBoxToDescriptor = function (geoDesc) {
            if (!BasicShapes._boxCreated) {
                BasicShapes.CreateBoxBuffers();
            }

            geoDesc.attachResource(&quot;indices&quot;, BasicShapes._boxTrianglesIndexBuffer);
            geoDesc.setNumElements(BasicShapes._boxTriangleIndexArray.length);
            geoDesc.attachResource(&quot;position&quot;, BasicShapes._boxTrianglesVertexBuffer);
            geoDesc.attachResource(&quot;normal&quot;, BasicShapes._boxNormalsBuffer);
            geoDesc.attachResource(&quot;texcoord&quot;, BasicShapes._boxUVsBuffer);
            geoDesc.setPrimitiveType(pre.PrimitiveType.TRIANGLES);
            geoDesc.getVolume().setFromCenterSize(new Float32Array([0, 0, 0]), new Float32Array([2, 2, 2]));
        };

        BasicShapes.AddBoxLinesToDescriptor = function (geoDesc, resetVolume) {
            if (typeof resetVolume === &quot;undefined&quot;) { resetVolume = true; }
            if (!BasicShapes._boxCreated) {
                BasicShapes.CreateBoxBuffers();
            }

            geoDesc.attachResource(&quot;indices&quot;, BasicShapes._boxLinesIndexBuffer);
            geoDesc.setNumElements(BasicShapes._boxLinesIndexArray.length);
            geoDesc.attachResource(&quot;position&quot;, BasicShapes._boxLinesVertexBuffer);
            geoDesc.setPrimitiveType(pre.PrimitiveType.LINES);
            if (resetVolume) {
                geoDesc.getVolume().setFromCenterSize(new Float32Array([0, 0, 0]), new Float32Array([2, 2, 2]));
            }
        };
        BasicShapes._boxVertexArray = new Float32Array([
            -1, -1, -1,
            1, -1, -1,
            1, 1, -1,
            -1, 1, -1,
            -1, -1, 1,
            1, -1, 1,
            1, 1, 1,
            -1, 1, 1
        ]);

        BasicShapes._boxTriangleIndexArray = null;

        BasicShapes._boxLinesIndexArray = new Uint16Array([
            0, 1, 1, 2,
            2, 3, 3, 0,
            4, 5, 5, 6,
            6, 7, 7, 4,
            0, 4, 1, 5,
            2, 6, 3, 7
        ]);

        BasicShapes._boxNormalsArray = null;
        BasicShapes._boxUVsArray = new Float32Array([
            1, 1, 1, 0,
            0, 1, 0, 1,
            1, 0, 0, 0,
            1, 1, 1, 0,
            0, 1, 0, 1,
            1, 0, 0, 0,
            1, 1, 1, 0,
            0, 1, 0, 1,
            1, 0, 0, 0,
            1, 1, 1, 0,
            0, 1, 0, 1,
            1, 0, 0, 0,
            1, 1, 1, 0,
            0, 1, 0, 1,
            1, 0, 0, 0,
            1, 1, 1, 0,
            0, 1, 0, 1,
            1, 0, 0, 0
        ]);

        BasicShapes._boxLinesVertexBuffer = null;
        BasicShapes._boxTrianglesVertexBuffer = null;
        BasicShapes._boxTrianglesIndexBuffer = null;
        BasicShapes._boxLinesIndexBuffer = null;
        BasicShapes._boxNormalsBuffer = null;
        BasicShapes._boxUVsBuffer = null;
        BasicShapes._boxCreated = false;
        return BasicShapes;
    })();
    util.BasicShapes = BasicShapes;
})(util || (util = {}));
var util;
(function (util) {
    var ColorUtils = (function () {
        function ColorUtils() {
        }
        ColorUtils.RGB2HSV = function (hsvColor, rgbColor) {
            var cMin;
            var cMax;
            var range;

            cMin = Math.min(Math.min(rgbColor[0], rgbColor[1]), rgbColor[2]);
            cMax = Math.max(Math.max(rgbColor[0], rgbColor[1]), rgbColor[2]);

            range = cMax - cMin;

            if (cMax == rgbColor[0]) {
                hsvColor[0] = 0.1666 * (rgbColor[1] - rgbColor[2]) / range;
            } else if (cMax == rgbColor[1]) {
                hsvColor[1] = 0.1666 * 2.0 * (rgbColor[2] - rgbColor[0]) / range;
            } else {
                hsvColor[2] = 0.1666 * 4.0 * (rgbColor[0] - rgbColor[1]) / range;
            }

            if (hsvColor[0] &lt; 0.0)
                hsvColor[0] += 1.0;

            hsvColor[1] = cMax &gt; 0 ? range / cMax : 0;
            hsvColor[2] = cMax;
        };

        ColorUtils.HSV2RGB = function (rgbColor, hsvColor) {
            var region;
            var remainder;
            var p;
            var q;
            var t;

            var h = hsvColor[0];
            var s = hsvColor[1];
            var v = hsvColor[2];

            if (s == 0) {
                rgbColor[0] = v;
                rgbColor[1] = v;
                rgbColor[2] = v;
                return;
            }

            region = Math.floor(h / 0.1666);
            remainder = (h / 0.1666) - region;

            p = v * (1.0 - s);
            q = v * (1.0 - (s * remainder));
            t = v * (1.0 - (s * (1.0 - remainder)));

            switch (region) {
                case 0:
                    rgbColor[0] = v;
                    rgbColor[1] = t;
                    rgbColor[2] = p;
                    break;
                case 1:
                    rgbColor[0] = q;
                    rgbColor[1] = v;
                    rgbColor[2] = p;
                    break;
                case 2:
                    rgbColor[0] = p;
                    rgbColor[1] = v;
                    rgbColor[2] = t;
                    break;
                case 3:
                    rgbColor[0] = p;
                    rgbColor[1] = q;
                    rgbColor[2] = v;
                    break;
                case 4:
                    rgbColor[0] = t;
                    rgbColor[1] = p;
                    rgbColor[2] = v;
                    break;
                default:
                    rgbColor[0] = v;
                    rgbColor[1] = p;
                    rgbColor[2] = q;
                    break;
            }
        };

        ColorUtils.ColorBandRGBValue = function (rgbColor, value) {
            ColorUtils.HSV2RGB(rgbColor, new Float32Array([(1.0 - value) * 0.66666, 1.0, 1.0]));
        };
        return ColorUtils;
    })();
    util.ColorUtils = ColorUtils;
})(util || (util = {}));
var util;
(function (util) {
    var DisableSelectionHandler = (function () {
        function DisableSelectionHandler(applicationID) {
            this._objectCatalog = null;
            this._application = pre.Environment.getInstance().getApplication(applicationID);
            this._objectCatalog = pre.Environment.getInstance().getObjectCatalog();
        }
        DisableSelectionHandler.prototype.onAdd = function (label, index) {
            this._application.getContext().getPartControl().enablePart(label, false);
        };

        DisableSelectionHandler.prototype.onRemove = function (label, index) {
            this._application.getContext().getPartControl().enablePart(label, true);
        };
        return DisableSelectionHandler;
    })();
    util.DisableSelectionHandler = DisableSelectionHandler;
})(util || (util = {}));
var util;
(function (util) {
    var Request = (function () {
        function Request(url, onloadCallback, priority) {
            this._url = url;
            this._priority = priority;
            this._xhr = new XMLHttpRequest();
            this._onloadCallbacks = [onloadCallback];

            var self = this;

            this._xhr.onload = function () {
                --DownloadService.getInstance()._activeDownloadCount;

                var that = DownloadService.getInstance();
                that._downloadVolume += self._xhr.response.byteLength;
                if (that._activeDownloadCount == 0) {
                    that._downloadTime += new Date().getTime() - that._lastStart;

                    var downloadRate = that._downloadVolume / 1024 / 1024 / that._downloadTime * 1000;

                    util.Statistics.getInstance().addValue(&quot;DownloadRate&quot;, Math.round(downloadRate * 100) / 100, &quot;Connection&quot;);
                }
                var i;
                if (self._xhr.status == 200) {
                    if (DownloadService.getInstance()._debugOutput) {
                        util.Log.postInfo('Download manager received data for URL \'' + self._url + '\'.');
                    }
                    for (i = 0; i &lt; self._onloadCallbacks.length; ++i) {
                        self._onloadCallbacks[i](self._xhr.response);
                    }
                } else {
                    util.Log.postWarning('Download manager received error for URL \'' + self._url + '\':');
                    for (i = 0; i &lt; self._onloadCallbacks.length; ++i) {
                        self._onloadCallbacks[i](null);
                    }
                }

                DownloadService.getInstance()._removeDownload(self);

                DownloadService.getInstance()._tryNextDownload();
            };

            this._xhr.onerror = function (e) {
                var that = DownloadService.getInstance();
                if (that._activeDownloadCount == 0) {
                    that._downloadTime += new Date().getTime() - that._lastStart;

                    var downloadRate = that._downloadVolume / 1024 / 1024 / that._downloadTime * 1000;

                    util.Statistics.getInstance().addValue(&quot;DownloadRate&quot;, Math.round(downloadRate * 100) / 100, &quot;Connection&quot;);
                }
                var i;

                DownloadService.getInstance()._removeDownload(self);

                DownloadService.getInstance()._tryNextDownload();
            };
        }
        Request.prototype.send = function () {
            this._xhr.open('GET', encodeURI(this._url), true);

            this._xhr.responseType = 'arraybuffer';

            this._xhr.send(null);

            if (DownloadService.getInstance()._debugOutput) {
                util.Log.postInfo('Download manager posted XHR for URL \'' + this._url + '\'.');
            }
        };
        return Request;
    })();
    util.Request = Request;

    var DownloadService = (function () {
        function DownloadService() {
            this._requests = [];
            this._requestIndex = [];
            this._downloadTime = 0;
            this._downloadVolume = 0;
            this._lastStart = -1;
            this._activeDownloadCount = 0;
            this._maxDownloadCount = 100;
            this._debugOutput = false;
        }
        DownloadService.getInstance = function () {
            if (DownloadService._instance === null) {
                DownloadService._instance = new DownloadService();
            }
            return DownloadService._instance;
        };

        DownloadService.prototype._removeDownload = function (req) {
            var i, j;
            var done = false;

            for (i = 0; i &lt; this._requests.length &amp;&amp; !done; ++i) {
                if (this._requests[i]) {
                    for (j = 0; j &lt; this._requests[i].length; ++j) {
                        if (this._requests[i][j] === req) {
                            this._requests[i].splice(j, 1);
                            done = true;
                            break;
                        }
                    }
                }
            }
        };

        DownloadService.prototype._tryNextDownload = function () {
            var firstRequest = null;
            var i, j;

            if (this._activeDownloadCount &lt; this._maxDownloadCount) {
                for (i = 0; i &lt; this._requests.length &amp;&amp; !firstRequest; ++i) {
                    if (this._requests[i]) {
                        for (j = 0; j &lt; this._requests[i].length; ++j) {
                            if (this._websocket != null) {
                                if (this._websocket.readyState == WebSocket.CONNECTING) {
                                    var that = this;
                                    setTimeout(function () {
                                        that._tryNextDownload.call(that);
                                    }, 100);
                                    return;
                                } else if (this._websocket.readyState == WebSocket.OPEN) {
                                    this._requestIndex.push(this._requests[i][j]);
                                    if (this._activeDownloadCount == 0) {
                                        console.log(&quot;Using WebSockets&quot;);
                                        this._lastStart = new Date().getTime();
                                    }
                                    this._websocket.send(this._requests[i][j]._url);
                                    ++this._activeDownloadCount;
                                    this._requests[i].splice(j, 1);
                                } else {
                                    util.Log.postError(&quot;WebSocket closed&quot;);
                                    delete this._websocket;
                                }
                                return;
                            } else {
                                if (this._requests[i][j]._xhr.readyState === XMLHttpRequest.UNSENT) {
                                    firstRequest = this._requests[i][j];
                                    break;
                                }
                            }
                        }
                    }
                }

                if (firstRequest) {
                    if (this._activeDownloadCount == 0) {
                        this._lastStart = new Date().getTime();
                    }
                    firstRequest.send();

                    ++this._activeDownloadCount;
                }
            }
        };

        DownloadService.prototype.toggleDebugOutput = function (flag) {
            this._debugOutput = flag;
        };

        DownloadService.prototype.initWebSocket = function () {
            var that = this;
            this._websocket = new WebSocket(&quot;ws://localhost:8080&quot;, [&quot;download&quot;]);
            this._websocket.binaryType = &quot;arraybuffer&quot;;
            this._websocket.onopen = function () {
                util.Statistics.getInstance().addValue(&quot;WebSockets enabled&quot;, 1, &quot;Connection&quot;);
            };
            this._websocket.onerror = function (error) {
                util.Statistics.getInstance().addValue(&quot;WebSockets enabled&quot;, 0, &quot;Connection&quot;);
                delete that._websocket;
            };
            this._websocket.onmessage = function (message) {
                 {
                    that._activeDownloadCount--;
                    that._downloadVolume += message.data.byteLength;
                    if (that._activeDownloadCount == 0) {
                        that._downloadTime += new Date().getTime() - that._lastStart;

                        var downloadRate = that._downloadVolume / 1024 / 1024 / that._downloadTime * 1000;

                        util.Statistics.getInstance().addValue(&quot;DownloadRate&quot;, Math.round(downloadRate * 100) / 100, &quot;Connection&quot;);
                    }
                    that._tryNextDownload();

                    var r = that._requestIndex.shift();

                    for (var i = 0; i &lt; r._onloadCallbacks.length; ++i) {
                        r._onloadCallbacks[i](message.data);
                    }
                    that._targetUrl = &quot;&quot;;
                }
            };
        };

        DownloadService.prototype.get = function (urls, onloadCallbacks, priorities) {
            var i, j, k, r;
            var found = false;
            var url, onloadCallback, priority;

            if (urls.length !== onloadCallbacks.length || (priorities &amp;&amp; urls.length !== priorities.length)) {
                util.Log.postError('DownloadManager: The number of given urls, onload callbacks and priorities is not equal. Ignoring requests.');
                return;
            }

            for (k = 0; k &lt; urls.length; ++k) {
                if (!onloadCallbacks[k] === undefined || (priorities &amp;&amp; !priorities[k] === undefined)) {
                    util.Log.postError('DownloadManager: No onload callback and / or priority specified. Ignoring requestGeometryDescriptor for \&quot;' + url + '\&quot;');
                    continue;
                } else {
                    url = urls[k];
                    onloadCallback = onloadCallbacks[k];
                    priority = priorities ? priorities[k] : 0;

                    for (i = 0; i &lt; this._requests.length &amp;&amp; !found; ++i) {
                        if (this._requests[i]) {
                            for (j = 0; j &lt; this._requests[i].length; ++j) {
                                if (this._requests[i][j]._url === url) {
                                    this._requests[i][j]._onloadCallbacks.push(onloadCallback);

                                    if (DownloadService.getInstance()._debugOutput) {
                                        util.Log.postInfo('Download manager appended onload callback for URL \'' + url + '\' to a registered requestGeometryDescriptor using the same URL.');
                                    }

                                    found = true;
                                    break;
                                }
                            }
                        }
                    }

                    if (!found) {
                        r = new Request(url, onloadCallback, priority);

                        if (this._requests[priority]) {
                            this._requests[priority].push(r);
                        } else {
                            this._requests[priority] = [r];
                        }
                    }
                }
            }

            for (i = 0; i &lt; urls.length &amp;&amp; this._activeDownloadCount &lt; this._maxDownloadCount; ++i) {
                this._tryNextDownload();
            }
        };

        DownloadService.prototype.getActiveDownloadCount = function () {
            return this._activeDownloadCount;
        };

        DownloadService.prototype.getTotalRequestCount = function () {
            var count = 0;
            var i;
            for (i = 0; i &lt; this._requests.length; ++i) {
                count += this._requests[i].length;
            }

            return count;
        };
        DownloadService._instance = null;
        return DownloadService;
    })();
    util.DownloadService = DownloadService;
})(util || (util = {}));
var util;
(function (util) {
    var HighlightSelectionHandler = (function () {
        function HighlightSelectionHandler(application) {
            this._cachedColors = [];
            this._highlightColor = [1.0, 1.0, 0.0, 1.0];
            this._objectCatalog = null;
            this._application = application;
            this._objectCatalog = pre.Environment.getInstance().getObjectCatalog();
            this._partControl = this._application.getContext().getPartControl();
        }
        HighlightSelectionHandler.prototype.onAdd = function (label, index) {
            if (this._cachedColors[index] = this._partControl.getPartColor(label)) {
                this._application.getContext().getPartControl().setPartColor(label, this._highlightColor);

                this._application.getPipelineControl().setFlag(4 /* APPEARANCE_CHANGED */);
            }
        };

        HighlightSelectionHandler.prototype.onRemove = function (label, index) {
            var oldColor = this._cachedColors[index];

            if (oldColor) {
                this._application.getContext().getPartControl().setPartColor(label, oldColor);

                this._application.getPipelineControl().setFlag(4 /* APPEARANCE_CHANGED */);
            }
        };
        return HighlightSelectionHandler;
    })();
    util.HighlightSelectionHandler = HighlightSelectionHandler;
})(util || (util = {}));
var util;
(function (util) {
    (function (PointerActionTrigger) {
        PointerActionTrigger[PointerActionTrigger[&quot;NONE&quot;] = 0] = &quot;NONE&quot;;
        PointerActionTrigger[PointerActionTrigger[&quot;FIRST&quot;] = 1] = &quot;FIRST&quot;;
        PointerActionTrigger[PointerActionTrigger[&quot;SECOND&quot;] = 2] = &quot;SECOND&quot;;
        PointerActionTrigger[PointerActionTrigger[&quot;THIRD&quot;] = 3] = &quot;THIRD&quot;;
        PointerActionTrigger[PointerActionTrigger[&quot;TOUCH&quot;] = 4] = &quot;TOUCH&quot;;
    })(util.PointerActionTrigger || (util.PointerActionTrigger = {}));
    var PointerActionTrigger = util.PointerActionTrigger;

    (function (PointerActionType) {
        PointerActionType[PointerActionType[&quot;CLICKED&quot;] = 0] = &quot;CLICKED&quot;;
        PointerActionType[PointerActionType[&quot;PRESSED&quot;] = 1] = &quot;PRESSED&quot;;
        PointerActionType[PointerActionType[&quot;RELEASED&quot;] = 2] = &quot;RELEASED&quot;;
        PointerActionType[PointerActionType[&quot;DOUBLECLICKED&quot;] = 3] = &quot;DOUBLECLICKED&quot;;
        PointerActionType[PointerActionType[&quot;TOUCH_PICKED&quot;] = 4] = &quot;TOUCH_PICKED&quot;;
        PointerActionType[PointerActionType[&quot;TOUCH_DOUBLE_PICKED&quot;] = 5] = &quot;TOUCH_DOUBLE_PICKED&quot;;
    })(util.PointerActionType || (util.PointerActionType = {}));
    var PointerActionType = util.PointerActionType;
})(util || (util = {}));
var util;
(function (util) {
    var ListItem = (function () {
        function ListItem(member, prev) {
            this._prev = null;
            this._member = null;
            this._member = member;
            this._prev = prev;
        }
        ListItem.prototype.getPrev = function () {
            return this._prev;
        };

        ListItem.prototype.getMember = function () {
            return this._member;
        };
        return ListItem;
    })();
    util.ListItem = ListItem;
})(util || (util = {}));
var util;
(function (util) {
    var Log = (function () {
        function Log() {
        }
        Log.postWarning = function (msg) {
            console.warn(&quot;WARNING: &quot; + msg);
        };

        Log.postError = function (msg) {
            alert(&quot;ERROR: &quot; + msg);
        };

        Log.postInfo = function (msg) {
            console.log(&quot;INFO: &quot; + msg);
        };
        return Log;
    })();
    util.Log = Log;
})(util || (util = {}));
var util;
(function (util) {
    var vec3Ext = (function () {
        function vec3Ext() {
        }
        vec3Ext.less = function (a, b) {
            return (a[0] &lt; b[0] &amp;&amp; a[1] &lt; b[1] &amp;&amp; a[2] &lt; b[2]);
        };

        vec3Ext.greater = function (a, b) {
            return (a[0] &gt; b[0] &amp;&amp; a[1] &gt; b[1] &amp;&amp; a[2] &gt; b[2]);
        };

        vec3Ext.equal = function (a, b) {
            return (a[0] == b[0] &amp;&amp; a[1] == b[1] &amp;&amp; a[2] == b[2]);
        };

        vec3Ext.lequal = function (a, b) {
            return (a[0] &lt;= b[0] &amp;&amp; a[1] &lt;= b[1] &amp;&amp; a[2] &lt;= b[2]);
        };

        vec3Ext.gequal = function (a, b) {
            return (a[0] &gt;= b[0] &amp;&amp; a[1] &gt;= b[1] &amp;&amp; a[2] &gt;= b[2]);
        };
        return vec3Ext;
    })();
    util.vec3Ext = vec3Ext;

    var mat4Ext = (function () {
        function mat4Ext() {
        }
        mat4Ext.add = function (out, a, b) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
            out[2] = a[2] + b[2];
            out[3] = a[3] + b[3];
            out[4] = a[4] + b[4];
            out[5] = a[5] + b[5];
            out[6] = a[6] + b[6];
            out[7] = a[7] + b[7];
            out[8] = a[8] + b[8];
            out[9] = a[9] + b[9];
            out[10] = a[10] + b[10];
            out[11] = a[11] + b[11];
            out[12] = a[12] + b[12];
            out[13] = a[13] + b[13];
            out[14] = a[14] + b[14];
            out[15] = a[15] + b[15];
        };

        mat4Ext.addScaled = function (out, a, b, s) {
            out[0] = a[0] + s * b[0];
            out[1] = a[1] + s * b[1];
            out[2] = a[2] + s * b[2];
            out[3] = a[3] + s * b[3];
            out[4] = a[4] + s * b[4];
            out[5] = a[5] + s * b[5];
            out[6] = a[6] + s * b[6];
            out[7] = a[7] + s * b[7];
            out[8] = a[8] + s * b[8];
            out[9] = a[9] + s * b[9];
            out[10] = a[10] + s * b[10];
            out[11] = a[11] + s * b[11];
            out[12] = a[12] + s * b[12];
            out[13] = a[13] + s * b[13];
            out[14] = a[14] + s * b[14];
            out[15] = a[15] + s * b[15];
        };

        mat4Ext.subtract = function (out, a, b) {
            out[0] = a[0] - b[0];
            out[1] = a[1] - b[1];
            out[2] = a[2] - b[2];
            out[3] = a[3] - b[3];
            out[4] = a[4] - b[4];
            out[5] = a[5] - b[5];
            out[6] = a[6] - b[6];
            out[7] = a[7] - b[7];
            out[8] = a[8] - b[8];
            out[9] = a[9] - b[9];
            out[10] = a[10] - b[10];
            out[11] = a[11] - b[11];
            out[12] = a[12] - b[12];
            out[13] = a[13] - b[13];
            out[14] = a[14] - b[14];
            out[15] = a[15] - b[15];
        };

        mat4Ext.multScalar = function (out, a, s) {
            out[0] = s * a[0];
            out[1] = s * a[1];
            out[2] = s * a[2];
            out[3] = s * a[3];
            out[4] = s * a[4];
            out[5] = s * a[5];
            out[6] = s * a[6];
            out[7] = s * a[7];
            out[8] = s * a[8];
            out[9] = s * a[9];
            out[10] = s * a[10];
            out[11] = s * a[11];
            out[12] = s * a[12];
            out[13] = s * a[13];
            out[14] = s * a[14];
            out[15] = s * a[15];
        };

        mat4Ext.zeros = function (out) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = 0;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 0;
            out[11] = 0;
            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 0;
        };

        mat4Ext.isEqual = function (a, b, epsilon) {
            if (typeof epsilon === &quot;undefined&quot;) { epsilon = 0.0; }
            if (Math.abs(a[0] - b[0]) &lt;= epsilon &amp;&amp; Math.abs(a[1] - b[1]) &lt;= epsilon &amp;&amp; Math.abs(a[2] - b[2]) &lt;= epsilon &amp;&amp; Math.abs(a[3] - b[3]) &lt;= epsilon &amp;&amp; Math.abs(a[4] - b[4]) &lt;= epsilon &amp;&amp; Math.abs(a[5] - b[5]) &lt;= epsilon &amp;&amp; Math.abs(a[6] - b[6]) &lt;= epsilon &amp;&amp; Math.abs(a[7] - b[7]) &lt;= epsilon &amp;&amp; Math.abs(a[8] - b[8]) &lt;= epsilon &amp;&amp; Math.abs(a[9] - b[9]) &lt;= epsilon &amp;&amp; Math.abs(a[10] - b[10]) &lt;= epsilon &amp;&amp; Math.abs(a[11] - b[11]) &lt;= epsilon &amp;&amp; Math.abs(a[12] - b[12]) &lt;= epsilon &amp;&amp; Math.abs(a[13] - b[13]) &lt;= epsilon &amp;&amp; Math.abs(a[14] - b[14]) &lt;= epsilon &amp;&amp; Math.abs(a[15] - b[15]) &lt;= epsilon) {
                return true;
            }

            return false;
        };

        mat4Ext.sqrt = function (out, a) {
            var Y = mat4.create();
            mat4.identity(Y);

            var iX = mat4.create();
            var iY = mat4.create();
            mat4.identity(iY);

            var od;
            var yd;
            var g;
            var ig;

            mat4.copy(out, a);

            var i = 0;
            for (; i &lt; 6; ++i) {
                mat4.invert(iX, out);

                if (i &gt; 0) {
                    mat4.invert(iY, Y);
                }

                od = mat4.determinant(out);
                yd = mat4.determinant(Y);

                g = Math.abs(Math.pow(od * yd, -0.125));
                ig = 1.0 / g;

                util.mat4Ext.multScalar(out, out, g);
                util.mat4Ext.addScaled(out, out, iY, ig);
                util.mat4Ext.multScalar(out, out, 0.5);

                util.mat4Ext.multScalar(Y, Y, g);
                util.mat4Ext.addScaled(Y, Y, iX, ig);
                util.mat4Ext.multScalar(Y, Y, 0.5);
            }
        };

        mat4Ext.maxAbsoluteValue = function (a) {
            var v = Math.abs(a[0]);
            var i = 1;

            for (; i &lt; 16; ++i) {
                v = Math.max(v, Math.abs(a[i]));
            }

            return v;
        };

        mat4Ext.log = function (out, a) {
            var maxIterations = 12;
            var eps = 1e-12;

            var A = mat4.create();
            var Z = mat4.create();

            mat4.copy(A, a);
            mat4.copy(Z, a);

            var I = mat4.create();
            mat4.identity(I);

            util.mat4Ext.subtract(Z, Z, I);

            var k = 0;

            while (util.mat4Ext.maxAbsoluteValue(Z) &gt; 0.5) {
                util.mat4Ext.sqrt(A, A);

                mat4.copy(Z, A);

                util.mat4Ext.subtract(Z, Z, I);

                ++k;
            }

            util.mat4Ext.subtract(A, A, I);

            util.mat4Ext.multScalar(A, A, -1.0);

            mat4.copy(Z, A);

            mat4.copy(out, A);

            var i = 1;

            while (util.mat4Ext.maxAbsoluteValue(Z) &gt; eps &amp;&amp; i &lt; maxIterations) {
                mat4.multiply(Z, Z, A);

                ++i;

                util.mat4Ext.addScaled(out, out, Z, 1.0 / i);
            }

            util.mat4Ext.multScalar(out, out, -Math.pow(2, k));
        };

        mat4Ext.exp = function (out, a) {
            var q = 6;

            var A = mat4.create();
            var D = mat4.create();
            var N = mat4.create();

            mat4.copy(A, a);
            mat4.identity(D);
            mat4.identity(N);

            mat4.identity(out);

            var k = 0;
            var c = 1.0;

            var j = 1.0 + Math.floor(Math.log(util.mat4Ext.maxAbsoluteValue(A) / 0.693));

            j = Math.max(j, 0.0);

            util.mat4Ext.multScalar(A, A, 1.0 / Math.pow(2, j));

            for (k = 1; k &lt;= q; ++k) {
                c *= (q - k + 1) / (k * (2 * q - k + 1));

                mat4.multiply(out, A, out);

                util.mat4Ext.addScaled(N, N, out, c);

                if (k % 2) {
                    util.mat4Ext.addScaled(D, D, out, -c);
                } else {
                    util.mat4Ext.addScaled(D, D, out, c);
                }
            }

            mat4.invert(out, D);
            mat4.multiply(out, out, N);

            for (k = 0; k &lt; j; k++) {
                mat4.multiply(out, out, out);
            }
        };
        return mat4Ext;
    })();
    util.mat4Ext = mat4Ext;
})(util || (util = {}));
var util;
(function (util) {
    var Observable = (function () {
        function Observable() {
            this._observers = [];
            this._taggedObservers = {};
        }
        Observable.prototype._notifyObservers = function (info) {
            for (var i = 0; i &lt; this._observers.length; i++) {
                this._observers[i].notify(info);
            }
        };

        Observable.prototype._notifyTaggedObservers = function (tag, info) {
            if (this._taggedObservers[tag] == null) {
                return;
            }
            for (var i = 0; i &lt; this._taggedObservers[tag].length; i++) {
                this._taggedObservers[tag][i].notify(info);
            }
        };

        Observable.prototype._notifyAllTaggedObservers = function (info) {
            var tags = Object.keys(this._taggedObservers);
            for (var i = 0; i &lt; tags.length; i++) {
                this._notifyTaggedObservers(tags[i], info);
            }
        };

        Observable.prototype.registerObserver = function (obs) {
            if (this._observers.indexOf(obs) == -1) {
                this._observers.push(obs);
            }
        };

        Observable.prototype.registerTaggedObserver = function (tag, obs) {
            if (this._taggedObservers[tag] == null) {
                this._taggedObservers[tag] = new Array();
            }
            this._taggedObservers[tag].push(obs);
        };

        Observable.prototype.unregisterObserver = function (obs) {
            var pos = this._observers.indexOf(obs);
            if (pos &gt; -1)
                this._observers.splice(pos, 1);
        };

        Observable.prototype.unregisterTaggedObserver = function (tag, obs) {
            if (this._taggedObservers[tag] == null) {
                return;
            }
            var pos = this._taggedObservers[tag].indexOf(obs);
            if (pos &gt; -1)
                this._taggedObservers[tag].splice(pos, 1);
        };
        return Observable;
    })();
    util.Observable = Observable;
})(util || (util = {}));
var util;
(function (util) {
    var Picker = (function () {
        function Picker(application) {
            this._application = null;
            this._frameBufferID = null;
            this._frameBufferPoint = null;
            this._objectCatalog = null;
            this._pickedDrawable = null;
            this._pickedPoint = null;
            this._pickedLabel = null;
            this._lastX = -1;
            this._lastY = -1;
            this._timestamp = -1;
            this._application = application;
            this._objectCatalog = pre.Environment.getInstance().getObjectCatalog();
        }
        Picker.prototype._findDrawable = function (globalTexPos) {
            var drawables = this._objectCatalog.getDrawables(this._application);
            var leftBound = 0;
            var rightBound = drawables.length;
            var pos;

            while ((pos = leftBound + Math.floor((rightBound - leftBound) / 2)) &gt;= 0) {
                var drawable = drawables[pos];
                var offset = drawable.getDrawableDescriptor().getSubMeshIDOffset();
                var globalID = globalTexPos - offset;
                var geoDesc = drawable.getForm().getGeometryDescriptor();
                if (globalID &gt;= 0) {
                    var idToLabelMap;
                    var bufferLength = geoDesc.hasMultipleParts() ? (idToLabelMap = geoDesc.getIDToLabelMap()).length : 1;
                    if (globalID &lt; bufferLength) {
                        this._pickedLabel = geoDesc.hasMultipleParts() ? idToLabelMap[globalID] : geoDesc.getLabels()[0];
                        return drawable;
                    } else {
                        leftBound = pos + 1;
                    }
                } else {
                    rightBound = pos;
                }
            }
            this._pickedLabel = null;
            return null;
        };

        Picker.prototype._setPickedDrawable = function (pixelData, pos) {
            var r = pixelData[pos + 0] &lt;&lt; 24;
            var g = pixelData[pos + 1] &lt;&lt; 16;
            var b = pixelData[pos + 2] &lt;&lt; 8;
            var a = pixelData[pos + 3];

            var globalTexPos = r + g + b + a - 1;

            if (globalTexPos &amp;&amp; globalTexPos &lt; 0) {
                this._pickedDrawable = null;
                this._pickedLabel = null;
                return;
            }
            this._pickedDrawable = this._findDrawable(globalTexPos);
        };

        Picker.prototype._setPickedPoint = function (pixelData, pos, volume) {
            if (pixelData[pos + 0] + pixelData[pos + 1] + pixelData[pos + 2] == 0) {
                this._pickedPoint = null;
            }

            var point = [];

            var min = volume.getMin();
            var max = volume.getMax();
            var range = vec3.create();
            vec3.sub(range, max, min);

            point[0] = pixelData[pos + 0] / 255 * range[0] + min[0];
            point[1] = pixelData[pos + 1] / 255 * range[1] + min[1];
            point[2] = pixelData[pos + 2] / 255 * range[2] + min[2];
            this._pickedPoint = point;
        };

        Picker.prototype._pick = function (x, y, trigger, timestamp) {
            if (x == this._lastX &amp;&amp; y == this._lastY &amp;&amp; timestamp != null &amp;&amp; timestamp == this._timestamp) {
                return;
            }

            if (!(this._frameBufferID &amp;&amp; this._frameBufferPoint)) {
                return;
            }
            var pixelBufferID = this._frameBufferID.getPixelBuffer(0 /* COLOR_TARGET0 */);
            var pixelBufferPoint = this._frameBufferPoint.getPixelBuffer(0 /* COLOR_TARGET0 */);
            var pickListener = null;

            if (pixelBufferID != null) {
                var xCoord = Math.round((this._frameBufferID.getWidth() - 1) * x);
                var yCoord = Math.round((this._frameBufferID.getHeight() - 1) * (1 - y));

                var canvasCoords = [xCoord, this._frameBufferID.getHeight() - yCoord];

                var pickPosition = 4 * (yCoord * this._frameBufferID.getWidth() + xCoord);

                this._setPickedDrawable(pixelBufferID, pickPosition);

                var img = document.getElementById(&quot;debug2&quot;);
                if (img) {
                    var canvas = document.createElement('canvas');
                    canvas.width = this._frameBufferID.getWidth();
                    canvas.height = this._frameBufferID.getHeight();
                    var context = canvas.getContext('2d');

                    var imageData = context.createImageData(this._frameBufferID.getWidth(), this._frameBufferID.getHeight());
                    imageData.data.set(pixelBufferID);
                    context.putImageData(imageData, 0, 0);

                    img.setAttribute(&quot;src&quot;, canvas.toDataURL());
                }

                if (this._pickedDrawable != null) {
                    if (pixelBufferPoint != null) {
                        this._setPickedPoint(pixelBufferPoint, pickPosition, this._pickedDrawable.getWorldVolume());
                    }

                    if ((pickListener = this._pickedDrawable.getRenderTreeNode().getPickListener()) != null) {
                        if (trigger == null || trigger == 0 /* NONE */) {
                            pickListener.drawableMouseOver(this._pickedDrawable, this._pickedPoint, canvasCoords, this._pickedLabel);
                        } else {
                            pickListener.drawablePicked(this._pickedDrawable, this._pickedPoint, canvasCoords, trigger, this._pickedLabel);
                        }
                    }
                }
            }

            this._lastX = x;
            this._lastY = y;
            if (timestamp != null) {
                this._timestamp = timestamp;
            }
        };

        Picker.prototype.getPickedDrawable = function (x, y, trigger, timestamp) {
            this._pick(x, y, trigger, timestamp);

            return this._pickedDrawable;
        };

        Picker.prototype.getPickedPoint = function (x, y, trigger, timestamp) {
            this._pick(x, y, trigger, timestamp);

            return this._pickedPoint;
        };

        Picker.prototype.getPickedLabel = function (x, y, trigger, timestamp) {
            this._pick(x, y, trigger, timestamp);

            return this._pickedLabel;
        };

        Picker.prototype.setPickingBuffer = function (pickmode, buffer) {
            if (pickmode == 1 /* POINT */) {
                this._frameBufferPoint = buffer;
            }
            if (pickmode == 0 /* ID */) {
                this._frameBufferID = buffer;
            }
        };
        return Picker;
    })();
    util.Picker = Picker;
})(util || (util = {}));
var util;
(function (util) {
    var ProxyShapes = (function () {
        function ProxyShapes() {
        }
        ProxyShapes.getLoadingAppearance = function () {
            if (ProxyShapes._loadingAppearanceDescriptor == null) {
                ProxyShapes._loadingAppearanceDescriptor = new pre.AppearanceDescriptor();
                ProxyShapes._loadingAppearanceDescriptor.attachResource(&quot;diffuseColor&quot;, pre.Resource.Create(pre.ResourceType.vec3f, new Float32Array([1.0, 1.0, 0.0])));
                ProxyShapes._loadingAppearanceDescriptor.attachResource(&quot;specularColor&quot;, pre.Resource.Create(pre.ResourceType.vec3f, new Float32Array([1.0, 1.0, 0.0])));
            }
            return ProxyShapes._loadingAppearanceDescriptor;
        };

        ProxyShapes.getLoadedAppearance = function () {
            if (ProxyShapes._loadedAppearanceDescriptor == null) {
                ProxyShapes._loadedAppearanceDescriptor = new pre.AppearanceDescriptor();
                ProxyShapes._loadedAppearanceDescriptor.attachResource(&quot;emissiveColor&quot;, pre.Resource.Create(pre.ResourceType.vec3f, new Float32Array([0.0, 0.0, 0.0])));
                ProxyShapes._loadedAppearanceDescriptor.attachResource(&quot;diffuseColor&quot;, pre.Resource.Create(pre.ResourceType.vec3f, new Float32Array([0.0, 1.0, 0.2])));
                ProxyShapes._loadedAppearanceDescriptor.attachResource(&quot;specularColor&quot;, pre.Resource.Create(pre.ResourceType.vec3f, new Float32Array([0.0, 1.0, 0.2])));
            }
            return ProxyShapes._loadedAppearanceDescriptor;
        };

        ProxyShapes.getFailedAppearance = function () {
            if (ProxyShapes._failedAppearanceDescriptor == null) {
                ProxyShapes._failedAppearanceDescriptor = new pre.AppearanceDescriptor();
                ProxyShapes._failedAppearanceDescriptor.attachResource(&quot;emissiveColor&quot;, pre.Resource.Create(pre.ResourceType.vec3f, new Float32Array([0.5, 0.0, 0.0])));
                ProxyShapes._failedAppearanceDescriptor.attachResource(&quot;diffuseColor&quot;, pre.Resource.Create(pre.ResourceType.vec3f, new Float32Array([0.0, 0.0, 0.0])));
                ProxyShapes._failedAppearanceDescriptor.attachResource(&quot;specularColor&quot;, pre.Resource.Create(pre.ResourceType.vec3f, new Float32Array([0.0, 0.0, 0.0])));
            }
            return ProxyShapes._failedAppearanceDescriptor;
        };

        ProxyShapes.createProxyGeometry = function (applicationID, url, callback, bboxCenter, bboxSize) {
            var volume = new pre.BoxVolume();
            if (vec3.length(bboxSize) &gt; 0) {
                volume.setFromCenterSize(bboxCenter, bboxSize);
            }

            var hasGeometry = volume.isValid();

            var geometryDescriptor = new pre.SRCGeometryDescriptor(util.SRCLoader.getInstance(applicationID), url, callback, hasGeometry);
            util.BasicShapes.AddBoxToDescriptor(geometryDescriptor);

            if (hasGeometry) {
                geometryDescriptor.copyVolume(volume);
                ProxyShapes.setLocalVolumeToBoundingBox(geometryDescriptor);
            } else {
                geometryDescriptor.copyVolume(volume);
            }

            return geometryDescriptor;
        };

        ProxyShapes.createProxyForm = function (applicationID, url, callback, bboxCenter, bboxSize) {
            var geometryDescriptor = ProxyShapes.createProxyGeometry(applicationID, url, callback, bboxCenter, bboxSize);

            var form = new pre.Form(geometryDescriptor, util.ProxyShapes.getLoadingAppearance());

            geometryDescriptor.setForm(form);

            return form;
        };

        ProxyShapes.setLocalVolumeToBoundingBox = function (geoDesc) {
            if (geoDesc.getVolume().isValid()) {
                var localMatrix = mat4.create();
                mat4.translate(localMatrix, localMatrix, geoDesc.getVolume().getCenter());
                mat4.scale(localMatrix, localMatrix, geoDesc.getVolume().getRadialVec());
                geoDesc.setLocalMatrix(localMatrix);
            }
        };
        ProxyShapes._loadingAppearanceDescriptor = null;
        ProxyShapes._loadedAppearanceDescriptor = null;
        ProxyShapes._failedAppearanceDescriptor = null;
        return ProxyShapes;
    })();
    util.ProxyShapes = ProxyShapes;
})(util || (util = {}));
var util;
(function (util) {
    var SRC = (function (_super) {
        __extends(SRC, _super);
        function SRC(url) {
            var _this = this;
            _super.call(this);
            this._header = null;
            this._arrayBuffer = null;
            this._chunkParsed = {};
            this._bufferBytes = {};
            this._attributeViewElementProgression = {};
            this._attribViewOffset = {};
            this._indexViewElementProgression = {};
            this._indexViewOffset = {};
            this._meshLastLevel = {};
            this._buffers = {};
            this._texBuffers = {};
            this._chunkBufferUses = {};
            this._chunkAttributeViewUses = {};
            this._chunkIndexViewUses = {};
            this._chunkTexBufferUses = {};
            this._chunkMeshUses = {};
            this._chunkTexUses = {};
            this._geometries = {};
            this._geometriesArray = [];
            this._appearances = null;
            this._forms = {};
            this._formsArray = [];
            this._textures = {};
            this._idToLabelMap = {};
            this._labelToIDMap = {};
            this._idUses = {};
            this._idToColorMap = {};
            this._meshAttributeIDs = {};
            this._bodyOffset = -1;
            this._url = &quot;&quot;;
            this.processArrayBuffer = function (arrayBuffer) {
                if (arrayBuffer == null) {
                    _this._notifyAllTaggedObservers(null);
                    _this._notifyObservers(null);
                    return;
                }
                _this._arrayBuffer = arrayBuffer;
                if (!_this._header) {
                    _this._parseHeader.call(_this, arrayBuffer);
                }

                if (_this._header) {
                    _this._splitBody.call(_this, arrayBuffer);
                }
            };
            this._url = url;
            this._cacheTrueFlagResource = pre.Resource.Create(pre.ResourceType.bool, new Int32Array([1]));
        }
        SRC._ab2str = function (buf) {
            var s = &quot;&quot;;
            for (var i = 0; i &lt; buf.byteLength; i++) {
                s += String.fromCharCode.call(null, buf[i]);
            }
            return s;
        };

        SRC._getComponentCount = function (type) {
            if (type == &quot;SCALAR&quot;) {
                return 1;
            }
            if (type == &quot;VEC2&quot;) {
                return 2;
            }
            if (type == &quot;VEC3&quot;) {
                return 3;
            }
        };

        SRC._getComponentSize = function (componentType) {
            if (componentType == 0x1400 || componentType == 0x1401) {
                return 1;
            }
            if (componentType == 0x1402 || componentType == 0x1403) {
                return 2;
            }
            if (componentType == 0x1404 || componentType == 0x1405 || componentType == 0x1406) {
                return 4;
            }
        };

        SRC._parseMaterialString = function (appDesc, data) {
            var keys = Object.keys(data);
            for (var i = 0; i &lt; keys.length; i++) {
                var name = keys[i];

                var content = data[name].value || data[name];
                var resourceData;
                var resourceType;

                if (content instanceof Array) {
                    if (content.length == 2) {
                        resourceData = vec2.fromValues(content[0], content[1]);
                        resourceType = pre.ResourceType.vec2f;
                    } else if (content.length == 3) {
                        resourceData = vec3.fromValues(content[0], content[1], content[2]);
                        resourceType = pre.ResourceType.vec3f;
                    } else if (content.length == 4) {
                        resourceData = vec4.fromValues(content[0], content[1], content[2], content[3]);
                        resourceType = pre.ResourceType.vec4f;
                    }
                } else {
                    resourceData = new Float32Array([content]);
                    resourceType = pre.ResourceType.FLOAT_32;
                }

                appDesc.attachResource(name, pre.Resource.Create(resourceType, resourceData));
            }
        };

        SRC.prototype._parseHeader = function (arrayBuffer) {
            var miniHeaderLength = 12;
            if (arrayBuffer.byteLength &lt; miniHeaderLength) {
                return;
            }
            var dataView = new DataView(arrayBuffer);
            var headerLength = dataView.getInt32(8, true);

            if (headerLength &gt; arrayBuffer.byteLength - miniHeaderLength) {
                return;
            }

            var headerString = SRC._ab2str(new Uint8Array(arrayBuffer, miniHeaderLength, headerLength));
            var header = JSON.parse(headerString);
            this._bodyOffset = headerLength + miniHeaderLength;
            this._header = header;

            this._init();
            this._createDependencyLists();
        };

        SRC.prototype._init = function () {
            this._meshIDs = Object.keys(this._header.meshes);

            this._textureIDs = Object.keys(this._header.textures);
            this._chunkIDs = Object.keys(this._header.bufferChunks);
            this._bufferViewIDs = Object.keys(this._header.bufferViews);
            this._textureViewIDs = Object.keys(this._header.textureViews);
            this._attributeViewIDs = Object.keys(this._header.accessors.attributeViews);
            this._indexViewIDs = Object.keys(this._header.accessors.indexViews);

            if (this._header.meta &amp;&amp; this._header.meta.idMaps) {
                this._idMapIDs = Object.keys(this._header.meta.idMaps);
                this._parseIDMaps();
            }

            var i;
            var n;
            var bufferViewKeys = this._bufferViewIDs;
            for (i = 0, n = bufferViewKeys.length; i &lt; n; i++) {
                this._buffers[bufferViewKeys[i]] = [];
                this._bufferBytes[bufferViewKeys[i]] = 0;
            }

            var textureViewKeys = this._textureViewIDs;
            for (i = 0, n = textureViewKeys.length; i &lt; n; i++) {
                this._texBuffers[textureViewKeys[i]] = [];
            }

            var chunkKeys = this._chunkIDs;
            for (i = 0, n = chunkKeys.length; i &lt; n; i++) {
                var chunkKey = chunkKeys[i];
                this._chunkParsed[chunkKey] = false;
                this._chunkBufferUses[chunkKey] = [];
                this._chunkTexBufferUses[chunkKey] = [];
                this._chunkMeshUses[chunkKey] = [];
                this._chunkTexUses[chunkKey] = [];
                this._chunkAttributeViewUses[chunkKey] = [];
                this._chunkIndexViewUses[chunkKey] = [];
            }

            var attributeViews = this._attributeViewIDs;
            for (i = 0, n = attributeViews.length; i &lt; n; i++) {
                var attribViewKey = attributeViews[i];
                var attribView = this._header.accessors.attributeViews[attribViewKey];
                this._attribViewOffset[attribViewKey] = attribView.byteOffset + SRC._getComponentCount(attribView.type) * SRC._getComponentSize(attribView.componentType);
                this._attributeViewElementProgression[attribViewKey] = 0;
            }
            var indexViews = this._indexViewIDs;
            for (i = 0, n = indexViews.length; i &lt; n; i++) {
                var indexViewKey = indexViews[i];
                var indexView = this._header.accessors.indexViews[indexViewKey];
                this._indexViewOffset[indexViewKey] = indexView.byteOffset + SRC._getComponentCount(indexView.type) * SRC._getComponentSize(indexView.componentType);
                this._indexViewElementProgression[indexViewKey] = 0;
            }
        };

        SRC.prototype._createDependencyLists = function () {
            var i, j, k;
            var n, o, p;

            var meshKeys = this._meshIDs;
            for (i = 0, n = meshKeys.length; i &lt; n; i++) {
                var meshID = meshKeys[i];
                this._meshLastLevel[meshID] = -1;
                var attributeKeys = Object.keys(this._header.meshes[meshID].attributes);
                this._meshAttributeIDs[meshID] = attributeKeys;
                for (j = 0, o = attributeKeys.length; j &lt; o; j++) {
                    var attributeView = this._header.meshes[meshID].attributes[attributeKeys[j]];
                    var bufferView = this._header.accessors.attributeViews[attributeView].bufferView;
                    var chunkKeys = this._header.bufferViews[bufferView].chunks;
                    for (k = 0, p = chunkKeys.length; k &lt; p; k++) {
                        var chunkID = chunkKeys[k];
                        if (this._chunkMeshUses[chunkID].indexOf(meshID) &lt; 0) {
                            this._chunkMeshUses[chunkID].push(meshID);
                        }
                        if (this._chunkBufferUses[chunkID].indexOf(bufferView) &lt; 0) {
                            this._chunkBufferUses[chunkID].push(bufferView);
                        }
                        if (this._chunkAttributeViewUses[chunkID].indexOf(attributeView) &lt; 0) {
                            this._chunkAttributeViewUses[chunkID].push(attributeView);
                        }
                    }
                }
                var indexViewID = this._header.meshes[meshID].indices;
                if (indexViewID) {
                    var indexBufferView = this._header.accessors.indexViews[indexViewID].bufferView;
                    var chunkKeys = this._header.bufferViews[indexBufferView].chunks;
                    for (j = 0, o = chunkKeys.length; j &lt; o; j++) {
                        var chunkID = chunkKeys[j];
                        if (this._chunkMeshUses[chunkID].indexOf(meshID) &lt; 0) {
                            this._chunkMeshUses[chunkID].push(meshID);
                        }
                        if (this._chunkBufferUses[chunkID].indexOf(indexBufferView) &lt; 0) {
                            this._chunkBufferUses[chunkID].push(indexBufferView);
                        }
                        if (this._chunkIndexViewUses[chunkID].indexOf(indexViewID) &lt; 0) {
                            this._chunkIndexViewUses[chunkID].push(indexViewID);
                        }
                    }
                }
            }

            var textureKeys = this._textureIDs;
            for (i = 0, n = textureKeys.length; i &lt; n; i++) {
                var texID = textureKeys[i];
                var textureView = this._header.textures[texID].textureView;
                var chunkKeys = this._header.textureViews[textureView].chunks;
                for (j = 0, o = chunkKeys.length; j &lt; o; j++) {
                    var chunkID = chunkKeys[j];
                    if (this._chunkTexUses[chunkID].indexOf(texID) &lt; 0) {
                        this._chunkTexUses[chunkID].push(texID);
                    }
                    if (this._chunkTexBufferUses[chunkID].indexOf(textureView) &lt; 0) {
                        this._chunkTexBufferUses[chunkID].push(textureView);
                    }
                }
            }
        };

        SRC.prototype._splitBody = function (arrayBuffer) {
            var i;
            var n;
            var modifiedMeshes = [];
            var modifiedTextures = [];

            var chunkKeys = this._chunkIDs;
            for (i = 0, n = chunkKeys.length; i &lt; n; i++) {
                var chunkName = chunkKeys[i];
                if (!this._chunkParsed[chunkName]) {
                    var chunkDesc = this._header.bufferChunks[chunkName];
                    var chunkStart = this._bodyOffset + chunkDesc.byteOffset;
                    var chunkEnd = chunkStart + chunkDesc.byteLength;

                    if (chunkEnd &lt;= arrayBuffer.byteLength) {
                        var chunk = new Uint8Array(arrayBuffer, chunkStart, chunkEnd - chunkStart);
                        this._chunkParsed[chunkName] = true;
                        this._addChunkToBuffers(chunkName, chunk, modifiedMeshes, modifiedTextures);
                    }
                }
            }

            for (i = 0, n = modifiedMeshes.length; i &lt; n; i++) {
                var meshID = modifiedMeshes[i];
                var geoDesc = this._geometries[meshID];
                if (geoDesc) {
                    geoDesc.setNumElements(this._calculateElementsToDraw(meshID));
                }
                this._notifyTaggedObservers(meshID, this);
            }
            for (i = 0, n = modifiedTextures.length; i &lt; n; i++) {
                var meshID = modifiedTextures[i];
                var tex = this._textures[meshID];
                if (tex) {
                    tex.incLoadedLevelsCount();
                    tex.setDirty();
                }
                this._notifyTaggedObservers(meshID, this);
            }
            if (modifiedMeshes.length &gt; 0) {
                this._notifyObservers(this);
            }
        };

        SRC.prototype._addChunkToBuffers = function (chunkName, chunk, modifiedMeshes, modifiedTextures) {
            var i;
            var n;

            var bufferViews = this._chunkBufferUses[chunkName];
            for (i = 0, n = bufferViews.length; i &lt; n; i++) {
                this._buffers[bufferViews[i]].push(chunk);
                this._bufferBytes[bufferViews[i]] += chunk.byteLength;
            }

            var texBufferViews = this._chunkTexBufferUses[chunkName];
            for (i = 0, n = texBufferViews.length; i &lt; n; i++) {
                this._texBuffers[texBufferViews[i]].push(chunk);
            }

            var meshes = this._chunkMeshUses[chunkName];
            for (i = 0, n = meshes.length; i &lt; n; i++) {
                var meshID = meshes[i];
                if (modifiedMeshes.indexOf(meshID) &lt; 0) {
                    modifiedMeshes.push(meshID);
                }
            }

            var texs = this._chunkTexUses[chunkName];
            for (i = 0, n = texs.length; i &lt; n; i++) {
                var texID = texs[i];
                if (modifiedTextures.indexOf(texID) &lt; 0) {
                    modifiedTextures.push(texID);
                }
            }

            var attributeViews = this._chunkAttributeViewUses[chunkName];
            for (i = 0, n = attributeViews.length; i &lt; n; i++) {
                var attribViewKey = attributeViews[i];
                var attributeView = this._header.accessors.attributeViews[attribViewKey];
                var bufferView = attributeView.bufferView;
                var bytes = this._bufferBytes[bufferView];
                this._attributeViewElementProgression[attribViewKey] = (bytes - this._attribViewOffset[attribViewKey]) / attributeView.byteStride + 1;
            }
            var indexViews = this._chunkIndexViewUses[chunkName];
            for (i = 0, n = indexViews.length; i &lt; n; i++) {
                var indexViewKey = indexViews[i];
                var indexView = this._header.accessors.indexViews[indexViewKey];
                var bufferView = indexView.bufferView;
                var bytes = this._bufferBytes[bufferView];
                this._indexViewElementProgression[indexViewKey] = (bytes - this._indexViewOffset[indexViewKey]) / indexView.byteStride + 1;
            }
        };

        SRC.prototype._calculateElementsToDraw = function (meshID) {
            var i, j;
            var n, o;
            var mesh = this._header.meshes[meshID];

            if (!mesh.meta || !mesh.meta.attributeProgression) {
                if (this.isIndexed(meshID)) {
                    return this._header.accessors.indexViews[mesh.indices].count;
                } else {
                    return this._header.accessors.attributeViews[mesh.attributes[this._meshAttributeIDs[meshID][0]]].count;
                }
            }

            var attributeProgressionLevels = mesh.meta.attributeProgression;
            var currentLevel = attributeProgressionLevels.length - 1;
            var nextLevel = this._meshLastLevel[meshID];
            var attributeIDs = this._meshAttributeIDs[meshID];
            for (i = 0, n = attributeIDs.length; i &lt; n; i++) {
                var attribID = attributeIDs[i];
                var elements = this._attributeViewElementProgression[attribID];
                for (j = nextLevel, o = currentLevel; j &lt;= o; j++) {
                    var elementsNeeded = attributeProgressionLevels[j];
                    if (elementsNeeded &gt; elements) {
                        if (j &lt;= currentLevel) {
                            currentLevel = j - 1;
                        }
                        break;
                    }
                }
            }
            if (mesh.indices) {
                var indexProgressionLevels = mesh.meta.indexProgression;
                for (j = nextLevel, o = currentLevel; j &lt;= o; j++) {
                    var elementsNeeded = indexProgressionLevels[j];
                    if (elementsNeeded &gt; elements) {
                        if (j &lt;= currentLevel) {
                            currentLevel = j - 1;
                        }
                        break;
                    }
                }
            }

            if (currentLevel &gt;= 0) {
                this._meshLastLevel[meshID] = currentLevel;
                return attributeProgressionLevels[currentLevel];
            } else {
                return 0;
            }
        };

        SRC.prototype._createGeometryDescriptor = function (meshID) {
            var _this = this;
            var i;
            var n;
            var geoDesc = new pre.ChunkedGeometryDescriptor(this._url);
            var mesh = this._header.meshes[meshID];

            if (mesh.indices) {
                var indexAccessor = this._header.accessors.indexViews[mesh.indices];
                var indexBuffer = new pre.ChunkedBufferResource(indexAccessor.componentType, function (callback) {
                    return _this._buffers[indexAccessor.bufferView];
                }, 1, false, 0, indexAccessor.byteOffset, this._header.bufferViews[indexAccessor.bufferView].byteLength);
                geoDesc.attachResource(&quot;indices&quot;, indexBuffer);
            }

            var attributes = this._meshAttributeIDs[meshID];
            for (i = 0, n = attributes.length; i &lt; n; i++) {
                var attributeName = attributes[i];
                var attributeAccessor = this._header.accessors.attributeViews[mesh.attributes[attributeName]];
                (function (bufferViewName) {
                    var attributeBuffer = new pre.ChunkedBufferResource(attributeAccessor.componentType, function (callback) {
                        return _this._buffers[bufferViewName];
                    }, SRC._getComponentCount(attributeAccessor.type), false, attributeAccessor.byteStride, attributeAccessor.byteOffset, _this._header.bufferViews[attributeAccessor.bufferView].byteLength, attributeAccessor.decodeOffset, attributeAccessor.decodeScale);
                    geoDesc.attachResource(attributeName, attributeBuffer);
                })(attributeAccessor.bufferView);
            }
            geoDesc.setPrimitiveType(mesh.primitive);
            geoDesc.getVolume().setFromCenterSize(new Float32Array(mesh.bboxCenter), new Float32Array(mesh.bboxSize));
            geoDesc.setNumElements(this._calculateElementsToDraw(meshID));
            var subMeshLabels;
            if (mesh.meta &amp;&amp; mesh.meta.idMap &amp;&amp; (subMeshLabels = mesh.meta.subMeshLabels)) {
                for (i = 0, n = subMeshLabels.length; i &lt; n; i++) {
                    var subMeshLabel = subMeshLabels[i];
                    if (this._idUses[subMeshLabel] == null) {
                        this._idUses[subMeshLabel] = [meshID];
                    } else {
                        this._idUses[subMeshLabel].push(meshID);
                    }
                }
                var idMapID = mesh.meta.idMap;
                geoDesc.setLabels(subMeshLabels);
                geoDesc.setIDToLabelMap(this._idToLabelMap[idMapID]);
                geoDesc.setLabelToIDMap(this._labelToIDMap[idMapID]);
                var colorMap;
                if ((colorMap = this._header.meta.idMaps[idMapID].colors) != null) {
                    geoDesc.setIDToColorMap(colorMap);
                }
                if (this._idToVolumeMap) {
                    geoDesc.setIDToVolumeMap(this._idToVolumeMap);
                }
            } else {
                geoDesc.setLabels([this._url.split(&quot;#&quot;)[0] + &quot;#&quot; + meshID]);
            }

            this._geometries[meshID] = geoDesc;
            this._geometriesArray.push(geoDesc);
        };

        SRC.prototype._createAppearanceDescriptors = function () {
            var i;
            var n;
            this._appearances = {};
            for (i = 0, n = this._meshIDs.length; i &lt; n; i++) {
                var meshID = this._meshIDs[i];
                var mesh = this._header.meshes[meshID];
                if (!mesh.material) {
                    continue;
                }
                var materialID = mesh.material;
                var material = this._header.materials[materialID].instanceTechnique;
                var technique = this._header.techniques[material.technique];
                var appDesc = new pre.AppearanceDescriptor();

                SRC._parseMaterialString(appDesc, technique.parameters);
                SRC._parseMaterialString(appDesc, material.values);
                this._attachTextures(meshID, appDesc);

                this._appearances[meshID] = appDesc;
            }
        };

        SRC.prototype._createTextureResource = function (texID) {
            var texture;
            var texDesc;
            if ((texDesc = this._header.textures[texID]) == null) {
                return null;
            }
            texture = pre.ChunkedTextureResource.Create(pre.ResourceType.sampler2D, this._texBuffers[texDesc.textureView]);
            texture.setWidth(texDesc.width);
            texture.setHeight(texDesc.height);
            texture.setLevels(texDesc.imageByteLengths.length);
            texture.setFormat(texDesc.format);
            texture.setInternalFormat(texDesc.internalFormat);
            texture.setDataType(texDesc.type);
            this._textures[texID] = texture;
        };

        SRC.prototype._createForm = function (meshID) {
            var geometryDescriptor = this.requestGeometryDescriptor(meshID);
            var appearanceDescriptor = this.requestAppearanceDescriptor(meshID);
            this._forms[meshID] = new pre.Form(geometryDescriptor, appearanceDescriptor);
            this._formsArray.push(this._forms[meshID]);
        };

        SRC.prototype._parseIDMaps = function () {
            var i, j, n, o;
            if (this._header.meta &amp;&amp; this._header.meta.idMaps) {
                for (i = 0, n = this._idMapIDs.length; i &lt; n; i++) {
                    var idMapID = this._idMapIDs[i];
                    var idMap = this._header.meta.idMaps[idMapID].labels;
                    var bboxCenterMap = this._header.meta.idMaps[idMapID].bboxCenters;
                    var bboxSizeMap = this._header.meta.idMaps[idMapID].bboxSizes;
                    var reverseIDMap = {};

                    if (bboxCenterMap &amp;&amp; bboxSizeMap) {
                        this._idToVolumeMap = new Array(idMap.length);
                        for (j = 0, o = idMap.length; j &lt; o; j++) {
                            var id = idMap[j];
                            reverseIDMap[id] = j;
                            var volume = new pre.BoxVolume();
                            volume.setFromCenterSize(new Float32Array(bboxCenterMap[j]), new Float32Array(bboxSizeMap[j]));
                            this._idToVolumeMap[j] = volume;
                        }
                    } else {
                        for (j = 0, o = idMap.length; j &lt; o; j++) {
                            var id = idMap[j];
                            reverseIDMap[id] = j;
                        }
                    }

                    this._idToLabelMap[idMapID] = idMap;
                    this._labelToIDMap[idMapID] = reverseIDMap;
                }
            }
        };

        SRC.prototype._attachTextures = function (meshID, appDesc) {
            var i;
            var n;
            var mesh = this._header.meshes[meshID];
            if (!mesh.textures) {
                return;
            }
            var texIDs = Object.keys(mesh.textures);
            for (i = 0, n = texIDs.length; i &lt; n; i++) {
                var id = texIDs[i];
                var textureResource = this.requestTextureResource(id);
                appDesc.attachResource(id, textureResource);
                appDesc.attachResource(&quot;has&quot; + id.charAt(0).toUpperCase() + id.slice(1), this._cacheTrueFlagResource);
            }
        };

        SRC.prototype.getMeshIDs = function () {
            return this._meshIDs;
        };

        SRC.prototype.headerParsed = function () {
            return this._header != null;
        };

        SRC.prototype.isIndexed = function (meshID) {
            return this._header.meshes[meshID].indices;
        };

        SRC.prototype.requestAppearanceDescriptor = function (meshID) {
            if (!this._appearances) {
                this._createAppearanceDescriptors();
            }
            return this._appearances[meshID];
        };

        SRC.prototype.requestTextureResource = function (texID) {
            if (this._textures[texID] == null) {
                this._createTextureResource(texID);
            }
            return this._textures[texID];
        };

        SRC.prototype.requestGeometryDescriptor = function (meshID) {
            if (this._geometries[meshID] == null) {
                this._createGeometryDescriptor(meshID);
            }
            return this._geometries[meshID];
        };

        SRC.prototype.requestAllGeometryDescriptors = function () {
            if (this._geometriesArray.length &lt; this._meshIDs.length) {
                for (var i = 0; i &lt; this._meshIDs.length; i++) {
                    this.requestGeometryDescriptor(this._meshIDs[i]);
                }
            }
            return this._geometriesArray;
        };

        SRC.prototype.requestGeometryDescriptors = function (url) {
            var splitUrl = url.split(&quot;#&quot;);
            if (splitUrl.length &lt;= 1) {
                return this.requestAllGeometryDescriptors();
            } else {
                return [this.requestGeometryDescriptor(splitUrl[1])];
            }
        };

        SRC.prototype.requestForm = function (meshID) {
            if (this._forms[meshID] == null) {
                this._createForm(meshID);
            }
            return this._forms[meshID];
        };

        SRC.prototype.requestAllForms = function () {
            if (this._formsArray.length &lt; this._meshIDs.length) {
                for (var i = 0; i &lt; this._meshIDs.length; i++) {
                    this.requestForm(this._meshIDs[i]);
                }
            }
            return this._formsArray;
        };

        SRC.prototype.requestForms = function (url) {
            var splitUrl = url.split(&quot;#&quot;);
            if (splitUrl.length &lt;= 1) {
                return this.requestAllForms();
            } else {
                return [this.requestForm(splitUrl[1])];
            }
        };

        SRC.prototype.getLength = function () {
            return this._arrayBuffer.byteLength;
        };
        return SRC;
    })(util.Observable);
    util.SRC = SRC;
})(util || (util = {}));
var util;
(function (util) {
    var SRCLoader = (function () {
        function SRCLoader(applicationID) {
            this._applicationID = applicationID;
            this._pipelineControl = pre.Environment.getInstance().getApplication(this._applicationID).getPipelineControl();
        }
        SRCLoader.getInstance = function (applicationID) {
            var instance;
            if ((instance = SRCLoader._instances[applicationID]) == null) {
                instance = new SRCLoader(applicationID);
                SRCLoader._instances[applicationID] = instance;
            }
            return instance;
        };

        SRCLoader.prototype.loadSRC = function (url, observer) {
            var urlSplit = url.split(&quot;#&quot;);
            var baseUrl = urlSplit[0];
            var meshSelector = urlSplit[1];
            var src = SRCLoader._srcList[baseUrl];
            if (!src) {
                var src = new util.SRC(url);
                SRCLoader._srcList[baseUrl] = src;
                util.DownloadService.getInstance().get([baseUrl], [src.processArrayBuffer]);
            }
            if (src.headerParsed()) {
                observer.notify(src);
                this.notifyGeoChanged(src);
            } else {
                if (urlSplit.length &gt; 1) {
                    src.registerTaggedObserver(meshSelector, observer);
                } else {
                    src.registerObserver(observer);
                }
            }
        };

        SRCLoader.prototype.notifyGeoChanged = function (info) {
            this._pipelineControl.setFlag(3 /* GEOMETRY_CHANGED */);
        };

        SRCLoader.prototype.notifyAppChanged = function (info) {
            this._pipelineControl.setFlag(4 /* APPEARANCE_CHANGED */);
        };

        SRCLoader.prototype.uploadAllowed = function (src) {
            SRCLoader.downloadBytesThisFrame += src.getLength();
            return SRCLoader.downloadBytesThisFrame == src.getLength() || (SRCLoader.downloadBytesThisFrame &lt;= SRCLoader._maxDownloadBytesPerFrame &amp;&amp; !this._pipelineControl.isNavigating());
        };
        SRCLoader._srcList = {};
        SRCLoader.downloadBytesThisFrame = 0;
        SRCLoader._maxDownloadBytesPerFrame = 20 * 1024 * 1024;
        SRCLoader._instances = {};
        return SRCLoader;
    })();
    util.SRCLoader = SRCLoader;
})(util || (util = {}));
var util;
(function (util) {
    var ScreenShotUtility = (function () {
        function ScreenShotUtility() {
            this._callback = null;
            this._renderTarget = null;
            this._mimeType = &quot;image/png&quot;;
            this._takingScreenshot = false;
        }
        ScreenShotUtility.prototype.getScreenshotRenderTarget = function (width, height) {
            if (!this._renderTarget || this._renderTarget.getWidth() != width || this._renderTarget.getHeight() != height) {
                this._renderTarget = new renderer.FrameBufferRenderTarget(width, height);
            }
            return this._renderTarget;
        };

        ScreenShotUtility.prototype.takeScreenShot = function (callback, mimeType) {
            if (typeof mimeType === &quot;undefined&quot;) { mimeType = &quot;image/png&quot;; }
            this._callback = callback;
            this._mimeType = mimeType;
            this._takingScreenshot = true;
        };

        ScreenShotUtility.prototype.isTakingScreenshot = function () {
            return this._takingScreenshot;
        };

        ScreenShotUtility.prototype.finishScreenshot = function (renderer) {
            var bindingManager = renderer.getBindingManager();
            this._renderTarget.bind(renderer);
            this._renderTarget.setDirty();
            var pixelBuffer = this._renderTarget.getPixelBuffer(0 /* COLOR_TARGET0 */);
            this._renderTarget.unbind(renderer);

            var width = this._renderTarget.getWidth();
            var height = this._renderTarget.getHeight();

            var canvas1 = document.createElement('canvas');
            canvas1.width = width;
            canvas1.height = height;
            var context1 = canvas1.getContext('2d');

            var imageData = context1.createImageData(width, height);
            imageData.data.set(pixelBuffer);
            context1.putImageData(imageData, 0, 0);

            var canvas2 = document.createElement('canvas');
            canvas2.width = width;
            canvas2.height = height;
            var context2 = canvas2.getContext('2d');

            context2.scale(1, -1);
            context2.translate(0, -canvas2.height);
            context2.drawImage(canvas1, 0, 0);

            this._callback(canvas2.toDataURL(this._mimeType));
            this._takingScreenshot = false;
        };
        return ScreenShotUtility;
    })();
    util.ScreenShotUtility = ScreenShotUtility;
})(util || (util = {}));
var util;
(function (util) {
    var SelectionController = (function () {
        function SelectionController(selectionHandler) {
            this._pickedLabels = [];
            this._pickedLabelsReverseMap = {};
            this._selectionHandler = selectionHandler;
        }
        SelectionController.prototype._removeLabel = function (label, index) {
            this._selectionHandler.onRemove(label, index);
            this._pickedLabels[index] = null;
            this._pickedLabelsReverseMap[label] = null;
        };

        SelectionController.prototype.addToSelection = function (label, additive) {
            if (typeof additive === &quot;undefined&quot;) { additive = false; }
            var idx;
            if (!additive) {
                this.emptySelection();
            }

            if (this._pickedLabelsReverseMap[label] == null) {
                idx = this._pickedLabels.push(label) - 1;
                this._pickedLabelsReverseMap[label] = idx;
                this._selectionHandler.onAdd(label, idx);
            }
        };

        SelectionController.prototype.removeFromSelection = function (label) {
            var idx = this._pickedLabelsReverseMap[label];
            if (idx != null) {
                this._removeLabel(this._pickedLabels[idx], idx);
            }
        };

        SelectionController.prototype.setSelectionHandler = function (selectionHandler) {
            this._selectionHandler = selectionHandler;
        };

        SelectionController.prototype.toggleSelection = function (label, additive) {
            if (typeof additive === &quot;undefined&quot;) { additive = false; }
            var idx = this._pickedLabels.indexOf(label);
            if (idx != -1) {
                this._removeLabel(this._pickedLabels[idx], idx);
            } else {
                this.addToSelection(label, additive);
            }
        };

        SelectionController.prototype.emptySelection = function () {
            for (var i = 0; i &lt; this._pickedLabels.length; ++i) {
                this._removeLabel(this._pickedLabels[i], i);
            }

            this._pickedLabels.length = 0;
        };
        return SelectionController;
    })();
    util.SelectionController = SelectionController;
})(util || (util = {}));
var util;
(function (util) {
    var Measurement = (function () {
        function Measurement() {
            this.startTime = 0;
            this.value = 0;
        }
        return Measurement;
    })();
    util.Measurement = Measurement;

    var ValueGroup = (function () {
        function ValueGroup() {
            this.name = &quot;&quot;;
            this.frameID = -1;
            this.values = {};
        }
        ValueGroup.prototype.clear = function (frameID) {
            this.frameID = frameID;
            var v;
            for (v in this.values) {
                this.values[v] = 0;
            }
        };
        return ValueGroup;
    })();
    util.ValueGroup = ValueGroup;

    var Statistics = (function () {
        function Statistics() {
            this._valueGroups = {};
            this._measurements = {};
            this._currentFrameID = -1;
            if (Statistics._instance) {
                throw new Error(&quot;Instantion failed: use Statistics.getInstance() instead. &quot;);
            }

            Statistics._instance = this;
        }
        Statistics.prototype._getGroup = function (identifier) {
            var group;
            if (!this._valueGroups[identifier]) {
                group = new ValueGroup();
                group.name = identifier;
                this._valueGroups[identifier] = group;
            }
            return this._valueGroups[identifier];
        };

        Statistics.getInstance = function () {
            if (Statistics._instance == null) {
                Statistics._instance = new Statistics();
            }
            return Statistics._instance;
        };

        Statistics.prototype.reset = function (frameId) {
            this._currentFrameID = frameId;

            var i, j;
            var keys;

            keys = Object.keys(this._measurements);
            for (i = 0; i &lt; keys.length; ++i) {
                this._measurements[keys[i]].value = 0;
            }
        };

        Statistics.prototype.addValue = function (identifier, value, group) {
            if (typeof group === &quot;undefined&quot;) { group = &quot;default&quot;; }
            var valueGroup = this._getGroup(group);
            if (valueGroup.frameID &lt; this._currentFrameID) {
                valueGroup.clear(this._currentFrameID);
            }

            if (valueGroup.values[identifier] === undefined) {
                valueGroup.values[identifier] = value;
            } else {
                valueGroup.values[identifier] += value;
            }
        };

        Statistics.prototype.getValue = function (identifier, group) {
            if (typeof group === &quot;undefined&quot;) { group = &quot;default&quot;; }
            var valueGroup = this._getGroup(group);

            if (valueGroup.values[identifier] === undefined)
                return -1;

            return valueGroup.values[identifier];
        };

        Statistics.prototype.getValueGroups = function () {
            return this._valueGroups;
        };

        Statistics.prototype.startMeasurement = function (identifier) {
            if (this._measurements[identifier] === undefined)
                this._measurements[identifier] = new Measurement();

            var val = performance.now();
            this._measurements[identifier].startTime = val;
            return val;
        };

        Statistics.prototype.stopMeasurement = function (identifier) {
            if (this._measurements[identifier] === undefined)
                return 0;

            var val = performance.now() - this._measurements[identifier].startTime;
            this._measurements[identifier].value += val;
            return val;
        };

        Statistics.prototype.getMeasurements = function () {
            return this._measurements;
        };

        Statistics.prototype.print = function () {
            var str = &quot;&quot;;

            var measures = Object.keys(this._measurements);

            for (var i = 0; i &lt; measures.length; ++i) {
                str += &quot; [&quot; + measures[i] + &quot; : &quot; + this._measurements[measures[i]].value + &quot;]\n&quot;;
            }
            console.log(str);
        };
        Statistics._instance = null;
        return Statistics;
    })();
    util.Statistics = Statistics;
})(util || (util = {}));
var pre;
(function (pre) {
    var StatsViewer = (function () {
        function StatsViewer() {
            this._viewer = null;
            this._valueList = null;
            this._measurementsList = null;
            this._createDOMElements();
        }
        StatsViewer.prototype._toFixed = function (val) {
            var fixed = (val &lt; 1) ? 2 : (val &lt; 10) ? 2 : 2;
            return val.toFixed(fixed).toString();
        };

        StatsViewer.prototype._toThousandSeperator = function (value) {
            return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, &quot;,&quot;);
        };

        StatsViewer.prototype._createDOMElements = function () {
            this._viewer = document.createElement('div');
            this._viewer.className = 'pre-stats-viewer-hidden';

            var title = document.createElement('div');
            title.className = 'pre-stats-head';

            var subTitle = document.createElement('span');
            subTitle.className = 'pre-stats-head2';
            title.appendChild(subTitle);

            this._measurementsList = document.createElement('ul');
            this._measurementsList.className = 'pre-stats-list';

            this._valueList = document.createElement('ul');
            this._valueList.className = 'pre-stats-list';

            this._viewer.appendChild(title);
            this._viewer.appendChild(this._measurementsList);
            this._viewer.appendChild(this._valueList);
        };

        StatsViewer.prototype.update = function (stats) {
            var valueGroups = stats.getValueGroups();
            var measurements = stats.getMeasurements();

            this._measurementsList.innerHTML = &quot;&quot;;
            this._valueList.innerHTML = &quot;&quot;;

            var list;
            var listItem;
            var title;
            var value;
            var bunnyIcon;

            for (var m in measurements) {
                listItem = document.createElement('li');
                listItem.className = 'pre-stats-item';

                title = document.createElement('div');
                title.className = 'pre-stats-item-title';
                title.appendChild(document.createTextNode(m));

                value = document.createElement('div');
                value.className = 'pre-stats-item-value';
                value.appendChild(document.createTextNode(this._toFixed(measurements[m].value)));

                listItem.appendChild(title);
                listItem.appendChild(value);

                this._measurementsList.appendChild(listItem);
            }

            for (var g in valueGroups) {
                var valueGroup = valueGroups[g];

                list = document.createElement('ul');
                list.className = 'pre-stats-list';

                title = document.createElement('div');
                title.className = 'pre-stats-item-title';

                title.appendChild(document.createTextNode(valueGroup.name));
                list.appendChild(title);

                for (var v in valueGroup.values) {
                    listItem = document.createElement('li');
                    listItem.className = 'pre-stats-item';

                    title = document.createElement('div');
                    title.className = 'pre-stats-item-title';

                    if (v == &quot;pipelineHint&quot;) {
                        title.appendChild(document.createTextNode(&quot;Rendering hint&quot;));

                        value = document.createElement('div');
                        value.className = 'pre-stats-item-value';

                        if (valueGroup.values[v] == 1) {
                            bunnyIcon = document.createElement('div');
                            bunnyIcon.className = 'pre-stats-bunnyIcon';
                            value.appendChild(bunnyIcon);
                        } else {
                            value.appendChild(document.createTextNode(&quot;NONE&quot;));
                        }
                        listItem.appendChild(title);
                        listItem.appendChild(value);
                    } else {
                        title.appendChild(document.createTextNode(v));

                        value = document.createElement('div');
                        value.className = 'pre-stats-item-value';
                        value.appendChild(document.createTextNode(this._toThousandSeperator(valueGroup.values[v])));

                        listItem.appendChild(title);
                        listItem.appendChild(value);
                    }

                    list.appendChild(listItem);
                }
                this._valueList.appendChild(list);
            }
        };

        StatsViewer.prototype.attachTo = function (element) {
            element.appendChild(this._viewer);
        };

        StatsViewer.prototype.setVisible = function (flag) {
            this._viewer.className = flag ? 'pre-stats-viewer' : 'pre-stats-viewer-hidden';
        };
        return StatsViewer;
    })();
    pre.StatsViewer = StatsViewer;
})(pre || (pre = {}));
var util;
(function (util) {
    var TouchInfo = (function () {
        function TouchInfo(id) {
            this.localX = -1;
            this.localY = -1;
            this.normalizedLocalX = -1;
            this.normalizedLocalY = -1;
            this.globalX = -1;
            this.globalY = -1;
            this.id = id;
        }
        return TouchInfo;
    })();
    util.TouchInfo = TouchInfo;
})(util || (util = {}));
var util;
(function (util) {
    var TransformMatrixTransition = (function () {
        function TransformMatrixTransition() {
            this._startMat = mat4.create();
            this._endMat = mat4.create();
            this._diffMatLog = mat4.create();
            this._progressMatLog = mat4.create();
        }
        TransformMatrixTransition.prototype.setMatrices = function (startMat, endMat) {
            mat4.copy(this._startMat, startMat);
            mat4.copy(this._endMat, endMat);

            var startMatInv = mat4.create();
            mat4.invert(startMatInv, startMat);

            mat4.copy(this._diffMatLog, endMat);
            mat4.multiply(this._diffMatLog, this._diffMatLog, startMatInv);
            util.mat4Ext.log(this._diffMatLog, this._diffMatLog);
        };

        TransformMatrixTransition.prototype.getValue = function (result, blendFactor) {
            blendFactor = Math.max(blendFactor, 0.0);
            blendFactor = Math.min(blendFactor, 1.0);

            if (blendFactor &gt;= 1.0) {
                mat4.copy(result, this._endMat);
                return;
            }

            util.mat4Ext.multScalar(this._progressMatLog, this._diffMatLog, blendFactor);

            util.mat4Ext.exp(this._progressMatLog, this._progressMatLog);

            mat4.multiply(result, this._progressMatLog, this._startMat);
        };
        return TransformMatrixTransition;
    })();
    util.TransformMatrixTransition = TransformMatrixTransition;
})(util || (util = {}));
var util;
(function (util) {
    (function (TransitionType) {
        TransitionType[TransitionType[&quot;LINEAR&quot;] = 0] = &quot;LINEAR&quot;;
        TransitionType[TransitionType[&quot;SINE&quot;] = 1] = &quot;SINE&quot;;
    })(util.TransitionType || (util.TransitionType = {}));
    var TransitionType = util.TransitionType;

    var ScalarTransition = (function () {
        function ScalarTransition() {
        }
        ScalarTransition.getValue = function (transitionType, time) {
            switch (transitionType) {
                case 0 /* LINEAR */:
                    return time;

                case 1 /* SINE */:
                    return (Math.sin((time * Math.PI) - (Math.PI * 0.5)) + 1) * 0.5;

                default:
                    return time;
            }
        };
        return ScalarTransition;
    })();
    util.ScalarTransition = ScalarTransition;
})(util || (util = {}));

var util;
(function (util) {
    var TriangleMeshGenerator = (function () {
        function TriangleMeshGenerator() {
        }
        TriangleMeshGenerator._readVec3 = function (vec, array, index) {
            vec3.set(vec, array[index], array[index + 1], array[index + 2]);
        };

        TriangleMeshGenerator._writeVec3 = function (array, index, vec) {
            array[index] = vec[0];
            array[index + 1] = vec[1];
            array[index + 2] = vec[2];
        };

        TriangleMeshGenerator.createTriIndicesFromQuadIndices = function (quadIndices, indexEncoding) {
            if (typeof quadIndices.length == 'undefined') {
                util.Log.postError(&quot;Cannot process quad index list that is not an array or typed array view.&quot;);
                return;
            }

            var numQuadIndices = quadIndices.length;

            if (numQuadIndices % 4 != 0) {
                util.Log.postWarning(&quot;Trying to convert a quad index list with a number of entries that is not a &quot; + &quot;multiple of 4 (&quot; + numQuadIndices + &quot;) to triangles. &quot; + &quot;This will likely produce unexpected results.&quot;);
            }

            var numTriIndices = 1.5 * numQuadIndices;
            var i, j;

            var triIndices = TriangleMeshGenerator._createTypedArrayBuffer(indexEncoding, numTriIndices);

            j = 0;
            for (i = 0; i &lt; numQuadIndices; i += 4, j += 6) {
                triIndices[j] = quadIndices[i];
                triIndices[j + 1] = quadIndices[i + 1];
                triIndices[j + 2] = quadIndices[i + 3];
                triIndices[j + 3] = quadIndices[i + 3];
                triIndices[j + 4] = quadIndices[i + 1];
                triIndices[j + 5] = quadIndices[i + 2];
            }

            return triIndices;
        };

        TriangleMeshGenerator.createFlatShadedNormals = function (indices, positionData, positionEncoding, normalEncoding) {
            var numTriangles = indices.length / 3;

            var newPositions = TriangleMeshGenerator._createTypedArrayBuffer(positionEncoding, numTriangles * 3 * 3);
            var normals = TriangleMeshGenerator._createTypedArrayBuffer(normalEncoding, numTriangles * 3 * 3);

            var oldPositions = positionData.array;

            var i;
            var p0 = vec3.create();
            var p1 = vec3.create();
            var p2 = vec3.create();
            var e0 = vec3.create();
            var e1 = vec3.create();
            var n = vec3.create();

            for (i = 0; i &lt; indices.length; i += 3) {
                TriangleMeshGenerator._readVec3(p0, oldPositions, indices[i] * 3);
                TriangleMeshGenerator._readVec3(p1, oldPositions, indices[i + 1] * 3);
                TriangleMeshGenerator._readVec3(p2, oldPositions, indices[i + 2] * 3);

                vec3.subtract(e0, p1, p0);
                vec3.subtract(e1, p2, p0);

                vec3.cross(n, e0, e1);
                vec3.normalize(n, n);

                TriangleMeshGenerator._writeVec3(newPositions, i * 3, p0);
                TriangleMeshGenerator._writeVec3(newPositions, i * 3 + 3, p1);
                TriangleMeshGenerator._writeVec3(newPositions, i * 3 + 6, p2);

                TriangleMeshGenerator._writeVec3(normals, i * 3, n);
                TriangleMeshGenerator._writeVec3(normals, i * 3 + 3, n);
                TriangleMeshGenerator._writeVec3(normals, i * 3 + 6, n);

                indices[i] = i;
                indices[i + 1] = i + 1;
                indices[i + 2] = i + 2;
            }

            positionData.array = newPositions;

            return normals;
        };

        TriangleMeshGenerator._createTypedArrayBuffer = function (encoding, numEntries) {
            switch (encoding) {
                case pre.ResourceType.UINT_8:
                    return new Uint8Array(new ArrayBuffer(numEntries));
                    break;

                case pre.ResourceType.UINT_16:
                    return new Uint16Array(new ArrayBuffer(numEntries * 2));
                    break;

                case pre.ResourceType.UINT_32:
                    return new Uint32Array(new ArrayBuffer(numEntries * 4));
                    break;

                case pre.ResourceType.FLOAT_32:
                    return new Float32Array(new ArrayBuffer(numEntries * 4));
                    break;

                default:
                    util.Log.postError(&quot;Cannot create typed array buffer for given encoding '&quot; + pre.ResourceType[encoding] + &quot;'.&quot;);
                    return null;
                    break;
            }
        };
        return TriangleMeshGenerator;
    })();
    util.TriangleMeshGenerator = TriangleMeshGenerator;
})(util || (util = {}));

window[&quot;requestAnimFrame&quot;] = (function () {
    return window[&quot;requestAnimationFrame&quot;] || window[&quot;webkitRequestAnimationFrame&quot;] || window[&quot;mozRequestAnimationFrame&quot;] || function (callback) {
        window.setTimeout(callback, 1000 / 60);
    };
})();

if (typeof window.performance === 'undefined') {
    window.performance = {};
}
if (!window.performance.now) {
    var nowOffset = Date.now();
    if (performance.timing &amp;&amp; performance.timing.navigationStart) {
        nowOffset = performance.timing.navigationStart;
    }
    window.performance.now = function now() {
        return Date.now() - nowOffset;
    };
}

if ((Function.prototype).name === undefined &amp;&amp; Object.defineProperty !== undefined) {
    Object.defineProperty(Function.prototype, 'name', {
        get: function () {
            var funcNameRegex = /function\s([^(]{1,})\(/;
            var results = (funcNameRegex).exec((this).toString());
            return (results &amp;&amp; results.length &gt; 1) ? results[1].trim() : &quot;&quot;;
        },
        set: function (value) {
        }
    });
}

function whichButton(event) {
    var button = 1;
    if (event.which) {
        if (event.which == 3)
            button = 2;
        if (event.which == 2)
            button = 3;
    } else if (event.button) {
        if (event.button == 2)
            button = 2;
        if (event.button == 4)
            button = 3;
    }
    return button;
}
var x3dom;
(function (x3dom) {
    var BindableStack = (function () {
        function BindableStack() {
            this._nodeTypeNameToBindables = {};
            var nodeType;

            for (nodeType in BindableStack._NodeClassToDefaultBindable) {
                this._nodeTypeNameToBindables[nodeType] = [];
            }
        }
        BindableStack._GetDefaultBindable = function (nodeType) {
            var result = BindableStack._NodeClassToDefaultBindable[nodeType];
            if (typeof result != 'undefined') {
                return result;
            } else {
                util.Log.postError(&quot;Unable to find default bindable for given node type '&quot; + nodeType + &quot;'.&quot;);
                return null;
            }
        };

        BindableStack.RegisterBindableClass = function (nodeType, x3domClass) {
            BindableStack._NodeClassToDefaultBindable[nodeType] = new x3domClass();
        };

        BindableStack.prototype.pushBindableNode = function (node) {
            var nodeType = node.getNodeTypeName().toLowerCase();
            var bindables = (this._nodeTypeNameToBindables[nodeType]);

            if (typeof bindables === 'undefined') {
                util.Log.postError(&quot;Cannot find bindable stack for unregistered bindable type '&quot; + nodeType + &quot;'. Unable to push bindable node.&quot;);
                return;
            }

            bindables.push(node);
        };

        BindableStack.prototype.removeBindableNode = function (node) {
            var nodeType = node.getNodeTypeName().toLowerCase();
            var bindables = (this._nodeTypeNameToBindables[nodeType]);

            if (typeof bindables === 'undefined') {
                util.Log.postError(&quot;Cannot find bindable stack for unregistered bindable type '&quot; + nodeType + &quot;'. Unable to remove bindable node.&quot;);
                return;
            }

            bindables.splice(bindables.indexOf(node), 1);
        };

        BindableStack.prototype.getActiveBindable = function (nodeType) {
            var bindables = this._nodeTypeNameToBindables[nodeType.toLowerCase()];

            if (typeof bindables === 'undefined') {
                util.Log.postError(&quot;Cannot find bindable stack for unregistered bindable type '&quot; + nodeType + &quot;'. Unable to return active bindable.&quot;);
                return null;
            } else if (bindables.length &gt; 0) {
                return bindables[0];
            } else {
                return BindableStack._GetDefaultBindable(nodeType);
            }
        };
        BindableStack._NodeClassToDefaultBindable = {};
        return BindableStack;
    })();
    x3dom.BindableStack = BindableStack;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var DOMAttachmentTraverser = (function () {
        function DOMAttachmentTraverser() {
        }
        DOMAttachmentTraverser.getInstance = function () {
            if (DOMAttachmentTraverser._instance === null) {
                DOMAttachmentTraverser._instance = new DOMAttachmentTraverser();
            }
            return DOMAttachmentTraverser._instance;
        };

        DOMAttachmentTraverser.prototype.attachX3DOMObject = function (domNode, x3dDocumentObject) {
            var def, use, i, childElement, x3domObject;

            if (domNode[&quot;x3domObject&quot;]) {
                this.removeX3DOMObject(domNode, x3dDocumentObject);
            }

            use = domNode.getAttribute(&quot;USE&quot;);

            if (!use) {
                x3domObject = this.createX3DOMObject(domNode, x3dDocumentObject);

                if (!x3domObject) {
                    util.Log.postError(&quot;Cannot create X3DOM representation for unknown element type &quot; + domNode.nodeName);
                    return;
                }

                def = domNode.getAttribute(&quot;DEF&quot;);

                if (def) {
                    x3dom.UseMap.registerNodeDEF(def, x3domObject);
                }
            } else {
                x3domObject = x3dom.UseMap.getNodeByDEF(use);

                if (x3domObject &amp;&amp; x3domObject instanceof x3dom.X3DBindableNode) {
                    util.Log.postError(&quot;Invalid USE definition'&quot; + use + &quot;': Bindable nodes should never be USEd.&quot;);
                    return;
                }

                if (!x3domObject) {
                    util.Log.postError(&quot;Cannot find matching DEF for USE definition'&quot; + use + &quot;'. Is this a valid DEF on a valid X3D Node Type?&quot;);
                    return;
                }

                domNode[&quot;x3domObject&quot;] = x3domObject;
            }

            if (x3domObject instanceof x3dom.X3DDocument) {
                x3dDocumentObject = x3domObject;
            }

            for (i = 0; i &lt; domNode.childNodes.length; ++i) {
                childElement = domNode.childNodes[i];

                if (childElement.nodeType != 1) {
                    continue;
                }

                this.attachX3DOMObject(childElement, x3dDocumentObject);

                if (childElement[&quot;x3domObject&quot;]) {
                    x3domObject.addChild(childElement[&quot;x3domObject&quot;]);
                } else {
                    util.Log.postError(&quot;X3DOM object for child could not be created, cannot create parent-child link.&quot;);
                }
            }

            return x3domObject;
        };

        DOMAttachmentTraverser.prototype.createX3DOMObject = function (domNode, x3dDocumentObject) {
            var x3domObject = null;

            var nodeTypeName = domNode.nodeName.toLowerCase();

            if (typeof x3dom.X3DOMObject.X3domObjectClasses[nodeTypeName] != 'undefined') {
                x3domObject = new x3dom.X3DOMObject.X3domObjectClasses[nodeTypeName];

                domNode[&quot;x3domObject&quot;] = x3domObject;

                x3domObject._originalDOMNode = domNode;

                x3domObject.syncWithDOM();
            } else {
                util.Log.postError(&quot;Cannot create X3DOM object for unknown type '&quot; + nodeTypeName + &quot;'.&quot;);
            }

            return x3domObject;
        };

        DOMAttachmentTraverser.prototype.removeX3DOMObject = function (domNode, x3dDocumentObject) {
            var x3domObject = domNode[&quot;x3domObject&quot;];

            if (x3domObject) {
                delete domNode[&quot;x3domObject&quot;];

                x3domObject._originalDOMNode = null;
            } else {
                util.Log.postError(&quot;Attempt to remove X3DOM object from a DOM node of type '&quot; + domNode.nodeName + &quot;', but no X3DOM object attached.&quot;);
            }
        };
        DOMAttachmentTraverser._instance = null;
        return DOMAttachmentTraverser;
    })();
    x3dom.DOMAttachmentTraverser = DOMAttachmentTraverser;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var UseMap = (function () {
        function UseMap() {
        }
        UseMap.registerNodeDEF = function (def, node) {
            if (typeof UseMap._defToNode[def] != 'undefined') {
                util.Log.postWarning(&quot;Defining DEF='&quot; + def + &quot;' again - this might result in unexpected behavior.&quot;);
            }

            UseMap._defToNode[def] = node;
        };

        UseMap.clearNodeDEF = function (def) {
            if (typeof UseMap._defToNode[def] != 'undefined') {
                delete UseMap._defToNode[def];
            }
        };

        UseMap.getNodeByDEF = function (def) {
            if (typeof UseMap._defToNode[def] != 'undefined') {
                return UseMap._defToNode[def];
            } else {
                return null;
            }
        };
        UseMap._defToNode = {};
        return UseMap;
    })();
    x3dom.UseMap = UseMap;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var UserInputController = (function () {
        function UserInputController(document) {
            this._selectionEnabled = true;
            this._freezeVisibilityFlag = true;
            this._document = document;
            this._picker = this._document.getNamespace().getApplication().getPicker();
            var selectionHandler = new util.HighlightSelectionHandler(this._document.getNamespace().getApplication());
            this._selectionController = new util.SelectionController(selectionHandler);
        }
        UserInputController.prototype.setSelectionEnabled = function (val) {
            if (typeof val === &quot;undefined&quot;) { val = true; }
            this._selectionEnabled = val;
        };

        UserInputController.prototype.keyPress = function (keyCode, timestamp) {
            if (keyCode === 32) {
                this._document.getApplication().toggleStatsViewer();
            }

            if (keyCode === 65) {
                this._document.showAll();
            }

            if (keyCode === 70) {
                pre.DrawableCollector.setVisibilityFreeze(this._freezeVisibilityFlag);
                this._freezeVisibilityFlag = !this._freezeVisibilityFlag;
            }

            if (keyCode === 86) {
                var settings = this._document.getNamespace().getApplication().getSettings();
                settings.showDebugVolumes = !settings.showDebugVolumes;
                this._document.getPipelineControl().setFlag(5 /* VIEW_CHANGED */);
            }
        };

        UserInputController.prototype.pointerMotion = function (pointerX, pointerY, normalizedPointerX, normalizedPointerY, pressedButton, timestamp) {
        };

        UserInputController.prototype.pointerActionTriggered = function (pointerX, pointerY, normalizedPointerX, normalizedPointerY, pressedButton, type, timestamp) {
            if (type == 0 /* CLICKED */ &amp;&amp; (pressedButton == 1 /* FIRST */ || pressedButton == 2 /* SECOND */) || type == 4 /* TOUCH_PICKED */) {
                var label = this._picker.getPickedLabel(normalizedPointerX, normalizedPointerY, pressedButton, timestamp);

                if (label &amp;&amp; this._selectionEnabled) {
                    this._selectionController.toggleSelection(label, true);
                }
            }
        };

        UserInputController.prototype.wheelScrolled = function (pointerX, pointerY, normalizedPointerX, normalizedPointerY, delta, timestamp) {
        };
        return UserInputController;
    })();
    x3dom.UserInputController = UserInputController;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DDocument = (function (_super) {
        __extends(X3DDocument, _super);
        function X3DDocument() {
            _super.call(this);
            this._canvasView = null;
            this._divDOMNode = null;
            this._userInputController = null;

            this._x3dNamespace = new x3dom.X3DNamespace();

            var application = pre.Environment.getInstance().requestNewApplication(document.createElement(&quot;canvas&quot;), this._x3dNamespace.getBindableStack().getActiveBindable(&quot;viewpoint&quot;).getCamera());

            this._x3dNamespace.setApplication(application);

            this._canvasView = application.getCanvasViews()[0];

            pre.PipelineFactory.createDefaultPipeline(application);

            this._navController = new navigation.ExamineNavigationController();
            application.setNavigationController(this._navController);

            this._userInputController = new x3dom.UserInputController(this);
            application.addKeyObserver(this._userInputController);
            application.addPointerObserver(this._userInputController);
        }
        X3DDocument.prototype.init = function () {
            this._x3dNamespace.getApplication().setRenderTreeRoot(this.buildRenderTree()[0]);
        };

        X3DDocument.prototype.getCanvasView = function () {
            return this._canvasView;
        };

        X3DDocument.prototype.getApplication = function () {
            return this._x3dNamespace.getApplication();
        };

        X3DDocument.prototype.getPipelineControl = function () {
            return this.getNamespace().getApplication().getPipelineControl();
        };

        X3DDocument.prototype.getNavigationController = function () {
            return this._navController;
        };

        X3DDocument.prototype.syncWithDOM = function () {
            var x3dElementDomNode = this._originalDOMNode;

            var parentElement = x3dElementDomNode.parentElement;
            var parentStyle;
            var styleAttrib;

            if (x3dElementDomNode) {
                if (!this._divDOMNode) {
                    this._divDOMNode = document.createElement(&quot;div&quot;);

                    parentStyle = window.getComputedStyle(parentElement, null);
                    for (styleAttrib in parentStyle) {
                    }

                    this._divDOMNode.style.width = &quot;100%&quot;;
                    this._divDOMNode.style.height = &quot;100%&quot;;
                    this._divDOMNode.style.position = &quot;relative&quot;;

                    parentElement.appendChild(this._divDOMNode);
                }

                this._canvasView.updateCanvasElement(this._divDOMNode);
            }
        };

        X3DDocument.prototype.renderScene = function () {
            var that = this;

            var application = this._x3dNamespace.getApplication();

            if (application) {
                var viewpoint = this._x3dNamespace.getBindableStack().getActiveBindable(&quot;viewpoint&quot;);

                var light;

                if (viewpoint) {
                    this._navController.setCamera(viewpoint.getCamera(true));

                    var context = application.getContext();

                    if (context.getCamera() != viewpoint.getCamera(true)) {
                        var camera = viewpoint.getCamera();
                        context.setCamera(camera);
                        camera.setAspectRatio(that._canvasView.getAspectRatio());
                        context.getCamera().toggleAutoComputeNearFar(true);
                    }

                    if (context.getLightsCount() == 0) {
                        this._lightDirRes = pre.Resource.Create(pre.ResourceType.vec3f, vec3.fromValues(0, 0, -1));

                        var lightColorRes = pre.Resource.Create(pre.ResourceType.vec3f, vec3.fromValues(1, 1, 1));

                        light = new pre.DirectionalLight(this._lightDirRes, lightColorRes);

                        context.addLight(light);

                        application.getPipelineControl().setFlag(4 /* APPEARANCE_CHANGED */);
                    }

                    vec4.copy(this._lightDirRes.getData(), viewpoint.getCamera(true).getViewDir());
                    this._lightDirRes.setDirty();

                    application.runPipeline();
                } else {
                    util.Log.postError(&quot;Cannot render X3D scene: no active viewpoint found.&quot;);
                }
            } else {
                util.Log.postError(&quot;Cannot render X3D scene: no render pipeline configuration specified.&quot;);
            }
        };

        X3DDocument.prototype.showAll = function () {
            this.show(this.getRenderTreeNodes()[0].requestLocalVolume());
        };

        X3DDocument.prototype.show = function (volume) {
            if (volume.isValid() &amp;&amp; volume.getDiameter() &gt; 0) {
                this._x3dNamespace.getApplication().fitView(volume, 1000, this._navController.getCamera());

                this._x3dNamespace.getApplication().getPipelineControl().setFlag(5 /* VIEW_CHANGED */);
            } else {
                util.Log.postWarning(&quot;Volume invalid or of zero size - cannot fit view.&quot;);
            }
        };

        X3DDocument.prototype.showAllAligned = function (vx, vy, vz, ux, uy, uz) {
            var sceneVolume = this.getRenderTreeNodes()[0].requestLocalVolume();

            var viewDir = vec3.fromValues(vx, vy, vz);
            var upVec = vec3.fromValues(ux, uy, uz);

            this._x3dNamespace.getApplication().fitViewAligned(sceneVolume, viewDir, upVec, 1000, this._navController.getCamera());

            this._x3dNamespace.getApplication().getPipelineControl().setFlag(5 /* VIEW_CHANGED */);
        };
        return X3DDocument;
    })(x3dom.X3DOMObject);
    x3dom.X3DDocument = X3DDocument;

    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;x3d&quot;, X3DDocument);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DNamespace = (function () {
        function X3DNamespace() {
            this._bindableStack = new x3dom.BindableStack();
            this._application = null;
        }
        X3DNamespace.prototype.getBindableStack = function () {
            return this._bindableStack;
        };

        X3DNamespace.prototype.setApplication = function (application) {
            this._application = application;
        };

        X3DNamespace.prototype.getApplication = function () {
            return this._application;
        };
        return X3DNamespace;
    })();
    x3dom.X3DNamespace = X3DNamespace;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DOMApplication = (function () {
        function X3DOMApplication() {
            this._x3dDocumentObjects = [];
        }
        X3DOMApplication.prototype._continuousRenderingLoop = function () {
            var i;

            for (i = 0; i &lt; this._x3dDocumentObjects.length; ++i) {
                this._x3dDocumentObjects[i].renderScene();
            }

            var that = this;
            window[&quot;requestAnimFrame&quot;](function () {
                that._continuousRenderingLoop();
            });
        };

        X3DOMApplication.prototype.onWindowLoad = function () {
            var x3dObject;

            var x3dElements = document.getElementsByTagName('X3D');

            var i;
            for (i = 0; i &lt; x3dElements.length; ++i) {
                if (x3dElements[i].x3domObject != null) {
                    return;
                }
                x3dom.DOMAttachmentTraverser.getInstance().attachX3DOMObject(x3dElements[i], null);

                x3dObject = x3dElements[i].x3domObject;

                if (x3dObject) {
                    this._x3dDocumentObjects.push(x3dObject);

                    x3dObject.init();
                } else {
                    util.Log.postWarning(&quot;Found uninitialized X3D element.&quot;);
                }
            }

            var that = this;
            window[&quot;requestAnimFrame&quot;](function () {
                that._continuousRenderingLoop();
            });
        };

        X3DOMApplication.prototype.onWindowUnload = function () {
        };

        X3DOMApplication.prototype.onWindowReload = function () {
        };
        return X3DOMApplication;
    })();
    x3dom.X3DOMApplication = X3DOMApplication;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DOMNode = (function (_super) {
        __extends(X3DOMNode, _super);
        function X3DOMNode() {
            _super.call(this);
            this._fields = {};
        }
        X3DOMNode.prototype.syncWithDOM = function () {
            _super.prototype.syncWithDOM.call(this);
            this.readFieldValuesFromDOM();
        };

        X3DOMNode.prototype.getNodeTypeName = function () {
            return this.constructor.name;
        };

        X3DOMNode.prototype.getField = function (name) {
            return this._fields[name];
        };

        X3DOMNode.prototype.readFieldValuesFromDOM = function () {
            var fieldName, field;

            if (this._originalDOMNode) {
                for (fieldName in this._fields) {
                    if (this._originalDOMNode.hasAttribute(fieldName)) {
                        this._fields[fieldName].setValueByString(this._originalDOMNode.getAttribute(fieldName));
                    }
                }
            } else {
                util.Log.postError(&quot;Trying to read field values from DOM, but no DOM node is associated with this object.&quot;);
            }
        };
        return X3DOMNode;
    })(x3dom.X3DOMObject);
    x3dom.X3DOMNode = X3DOMNode;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DOMScene = (function (_super) {
        __extends(X3DOMScene, _super);
        function X3DOMScene() {
            _super.apply(this, arguments);
        }
        return X3DOMScene;
    })(x3dom.X3DOMObject);
    x3dom.X3DOMScene = X3DOMScene;

    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;scene&quot;, X3DOMScene);
})(x3dom || (x3dom = {}));
var x3domMainApp = new x3dom.X3DOMApplication();

window.addEventListener('load', function () {
    x3domMainApp.onWindowLoad();
}, false);
window.addEventListener('unload', function () {
    x3domMainApp.onWindowUnload();
}, false);
window.addEventListener('reload', function () {
    x3domMainApp.onWindowReload();
}, false);

if (document.readyState === &quot;complete&quot;) {
    x3domMainApp.onWindowLoad();
}
;
var x3dom;
(function (x3dom) {
    var Field = (function () {
        function Field() {
        }
        Field.prototype.toString = function () {
            return &quot;&quot;;
        };

        Field.prototype.setValueByString = function (str) {
        };

        Field.prototype.getValue = function () {
        };
        return Field;
    })();
    x3dom.Field = Field;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var SFBool = (function (_super) {
        __extends(SFBool, _super);
        function SFBool(b) {
            _super.call(this);
            this._value = null;

            this._value = b;
        }
        SFBool.prototype.toString = function () {
            return (this._value ? &quot;TRUE&quot; : &quot;FALSE&quot;);
        };

        SFBool.prototype.setValueByString = function (str) {
            this._value = (str.trim().toLowerCase() === &quot;true&quot;);
        };

        SFBool.prototype.getValue = function () {
            return this._value;
        };
        return SFBool;
    })(x3dom.Field);
    x3dom.SFBool = SFBool;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var SFColor = (function (_super) {
        __extends(SFColor, _super);
        function SFColor(r, g, b) {
            if (typeof r === &quot;undefined&quot;) { r = 0; }
            if (typeof g === &quot;undefined&quot;) { g = 0; }
            if (typeof b === &quot;undefined&quot;) { b = 0; }
            _super.call(this);
            this._value = null;

            this._value = vec3.fromValues(r, g, b);
        }
        SFColor.prototype.getValue = function () {
            return this._value;
        };

        SFColor.prototype.setValueByString = function (str) {
            var valuesStr = str.split(&quot; &quot;);

            var r, g, b;

            if (valuesStr.length &gt;= 3) {
                r = parseFloat(valuesStr[0]);
                g = parseFloat(valuesStr[1]);
                b = parseFloat(valuesStr[2]);

                if (isFinite(r) &amp;&amp; isFinite(g) &amp;&amp; isFinite(b)) {
                    vec3.set(this._value, r, g, b);
                } else {
                    util.Log.postError(&quot;Cannot extract SFColor values from string '&quot; + str + &quot;': at least one entry is not a finite number.&quot;);
                }
            } else {
                util.Log.postError(&quot;Cannot extract SFColor values from string '&quot; + str + &quot;': not enough components given.&quot;);
            }
        };
        return SFColor;
    })(x3dom.Field);
    x3dom.SFColor = SFColor;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var SFFloat = (function (_super) {
        __extends(SFFloat, _super);
        function SFFloat(f) {
            if (typeof f === &quot;undefined&quot;) { f = 0; }
            _super.call(this);
            this._value = null;

            this._value = f;
        }
        SFFloat.prototype.toString = function () {
            return this._value.toString();
        };

        SFFloat.prototype.setValueByString = function (str) {
            this._value = parseFloat(str);
        };

        SFFloat.prototype.getValue = function () {
            return this._value;
        };

        SFFloat.prototype.getFetch = function () {
            var _this = this;
            return function (callback) {
                return [_this._value];
            };
        };
        return SFFloat;
    })(x3dom.Field);
    x3dom.SFFloat = SFFloat;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var SFInt = (function (_super) {
        __extends(SFInt, _super);
        function SFInt(f) {
            if (typeof f === &quot;undefined&quot;) { f = 0; }
            _super.call(this);
            this._value = null;

            this._value = Math.round(f);
        }
        SFInt.prototype.toString = function () {
            return Math.round(this._value).toString();
        };

        SFInt.prototype.setValueByString = function (str) {
            this._value = parseInt(str);
        };

        SFInt.prototype.getValue = function () {
            return this._value;
        };

        SFInt.prototype.getFetch = function () {
            var _this = this;
            return function (callback) {
                return [_this._value];
            };
        };
        return SFInt;
    })(x3dom.Field);
    x3dom.SFInt = SFInt;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var SFMatrix4f = (function (_super) {
        __extends(SFMatrix4f, _super);
        function SFMatrix4f() {
            _super.call(this);
            this._value = null;

            this._value = mat4.create();
        }
        SFMatrix4f.prototype.toString = function () {
            var str = &quot;&quot; + this._value[0];

            var i;
            for (i = 1; i &lt; 16; ++i) {
                str += &quot; &quot; + this._value[i];
            }

            return str;
        };

        SFMatrix4f.prototype.setValueByString = function (str) {
            var valuesStr = str.split(&quot; &quot;);

            var i, v;

            if (valuesStr.length &gt;= 16) {
                for (i = 0; i &lt; 16; ++i) {
                    v = parseFloat(valuesStr[i]);

                    if (isFinite(v)) {
                        this._value[i] = v;
                    } else {
                        util.Log.postError(&quot;Cannot extract SFMatrix4f values from string '&quot; + str + &quot;': at least one entry is not a finite number.&quot;);
                        return;
                    }
                }
            } else {
                util.Log.postError(&quot;Cannot extract SFMatrix4f values from string '&quot; + str + &quot;': not enough components given.&quot;);
            }
        };

        SFMatrix4f.prototype.setValueByArray = function (arr) {
            var i, v;

            if (arr.length &gt;= 16) {
                for (i = 0; i &lt; 16; ++i) {
                    v = arr[i];

                    if (isFinite(v)) {
                        this._value[i] = v;
                    } else {
                        util.Log.postError(&quot;Cannot extract SFMatrix4f values from array '&quot; + arr + &quot;': at least one entry is not a finite number.&quot;);
                        return;
                    }
                }
            } else {
                util.Log.postError(&quot;Cannot extract SFMatrix4f values from array '&quot; + arr + &quot;': not enough components given.&quot;);
            }
        };

        SFMatrix4f.prototype.getValue = function () {
            return this._value;
        };
        return SFMatrix4f;
    })(x3dom.Field);
    x3dom.SFMatrix4f = SFMatrix4f;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var SFRotation = (function (_super) {
        __extends(SFRotation, _super);
        function SFRotation(axisX, axisY, axisZ, angleRad) {
            _super.call(this);
            this._value = quat.create();

            quat.setAxisAngle(this._value, new Float32Array([axisX, axisY, axisZ]), angleRad);
        }
        SFRotation.prototype.toString = function () {
            return quat.str(this._value);
        };

        SFRotation.prototype.setValueByString = function (str) {
            var valuesStr = str.split(&quot; &quot;);

            var x, y, z, w;
            var axis;

            if (valuesStr.length &gt;= 4) {
                x = parseFloat(valuesStr[0]);
                y = parseFloat(valuesStr[1]);
                z = parseFloat(valuesStr[2]);
                w = parseFloat(valuesStr[3]);

                if (isFinite(x) &amp;&amp; isFinite(y) &amp;&amp; isFinite(z) &amp;&amp; isFinite(w)) {
                    axis = vec3.fromValues(x, y, z);
                    vec3.normalize(axis, axis);

                    quat.setAxisAngle(this._value, axis, w);
                } else {
                    util.Log.postError(&quot;Cannot extract SFRotation values from string '&quot; + str + &quot;': at least one entry is not a finite number.&quot;);
                }
            } else {
                util.Log.postError(&quot;Cannot extract SFRotation values from string '&quot; + str + &quot;': not enough components given.&quot;);
            }
        };

        SFRotation.prototype.getValue = function () {
            return this._value;
        };
        return SFRotation;
    })(x3dom.Field);
    x3dom.SFRotation = SFRotation;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var SFString = (function (_super) {
        __extends(SFString, _super);
        function SFString(str) {
            if (typeof str === &quot;undefined&quot;) { str = &quot;&quot;; }
            _super.call(this);
            this._value = null;

            this._value = str;
        }
        SFString.prototype.toString = function () {
            return this._value;
        };

        SFString.prototype.setValueByString = function (str) {
            this._value = str;
        };

        SFString.prototype.getValue = function () {
            return this._value;
        };
        return SFString;
    })(x3dom.Field);
    x3dom.SFString = SFString;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var SFVec3f = (function (_super) {
        __extends(SFVec3f, _super);
        function SFVec3f(x, y, z) {
            if (typeof x === &quot;undefined&quot;) { x = 0; }
            if (typeof y === &quot;undefined&quot;) { y = 0; }
            if (typeof z === &quot;undefined&quot;) { z = 0; }
            _super.call(this);
            this._value = null;

            this._value = vec3.fromValues(x, y, z);
        }
        SFVec3f.prototype.toString = function () {
            return this._value[0] + &quot; &quot; + this._value[1] + &quot; &quot; + this._value[2];
        };

        SFVec3f.prototype.setValueByString = function (str) {
            var valuesStr = str.split(&quot; &quot;);

            var x, y, z;

            if (valuesStr.length &gt;= 3) {
                x = parseFloat(valuesStr[0]);
                y = parseFloat(valuesStr[1]);
                z = parseFloat(valuesStr[2]);

                if (isFinite(x) &amp;&amp; isFinite(y) &amp;&amp; isFinite(z)) {
                    vec3.set(this._value, x, y, z);
                } else {
                    util.Log.postError(&quot;Cannot extract SFVec3f values from string '&quot; + str + &quot;': at least one entry is not a finite number.&quot;);
                }
            } else {
                util.Log.postError(&quot;Cannot extract SFVec3f values from string '&quot; + str + &quot;': not enough components given.&quot;);
            }
        };

        SFVec3f.prototype.setValueByArray = function (arr) {
            var x, y, z;

            if (arr.length &gt;= 3) {
                x = arr[0];
                y = arr[1];
                z = arr[2];

                if (isFinite(x) &amp;&amp; isFinite(y) &amp;&amp; isFinite(z)) {
                    vec3.set(this._value, x, y, z);
                } else {
                    util.Log.postError(&quot;Cannot extract SFVec3f values from array '&quot; + arr + &quot;': at least one entry is not a finite number.&quot;);
                }
            } else {
                util.Log.postError(&quot;Cannot extract SFVec3f values from array '&quot; + arr + &quot;': not enough components given.&quot;);
            }
        };

        SFVec3f.prototype.getValue = function () {
            return this._value;
        };
        return SFVec3f;
    })(x3dom.Field);
    x3dom.SFVec3f = SFVec3f;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DNode = (function (_super) {
        __extends(X3DNode, _super);
        function X3DNode() {
            _super.call(this);
        }
        return X3DNode;
    })(x3dom.X3DOMNode);
    x3dom.X3DNode = X3DNode;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DChildNode = (function (_super) {
        __extends(X3DChildNode, _super);
        function X3DChildNode() {
            _super.call(this);
        }
        return X3DChildNode;
    })(x3dom.X3DNode);
    x3dom.X3DChildNode = X3DChildNode;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DBindableNode = (function (_super) {
        __extends(X3DBindableNode, _super);
        function X3DBindableNode() {
            _super.apply(this, arguments);
        }
        X3DBindableNode.prototype._namespaceChanged = function (oldNamespace, newNamespace) {
            _super.prototype._namespaceChanged.call(this, oldNamespace, newNamespace);

            if (oldNamespace) {
                oldNamespace.getBindableStack().removeBindableNode(this);
            }

            if (newNamespace) {
                newNamespace.getBindableStack().pushBindableNode(this);
            }
        };
        return X3DBindableNode;
    })(x3dom.X3DChildNode);
    x3dom.X3DBindableNode = X3DBindableNode;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DGeometryNode = (function (_super) {
        __extends(X3DGeometryNode, _super);
        function X3DGeometryNode() {
            _super.apply(this, arguments);
            this._geometryDescriptors = [];
        }
        X3DGeometryNode.prototype._updateGeometryDescriptor = function () {
        };

        X3DGeometryNode.prototype.getGeometryDescriptors = function () {
            if (this._geometryDescriptors.length == 0) {
                this._updateGeometryDescriptor();
            }

            return this._geometryDescriptors;
        };
        return X3DGeometryNode;
    })(x3dom.X3DNode);
    x3dom.X3DGeometryNode = X3DGeometryNode;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var Box = (function (_super) {
        __extends(Box, _super);
        function Box() {
            _super.apply(this, arguments);
        }
        Box.prototype._updateGeometryDescriptor = function () {
            if (this._geometryDescriptors.length != 0) {
                return;
            }

            if (!Box._boxGeometry) {
                Box._boxGeometry = new pre.GeometryDescriptor();
                util.BasicShapes.AddBoxToDescriptor(Box._boxGeometry);
            }

            this._geometryDescriptors.push(Box._boxGeometry);

            var boxVol = new pre.BoxVolume(vec3.fromValues(-1, -1, -1), vec3.fromValues(1, 1, 1));
            this._geometryDescriptors[0].copyVolume(boxVol);
        };
        return Box;
    })(x3dom.X3DGeometryNode);
    x3dom.Box = Box;

    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;box&quot;, Box);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DBoundedObject = (function (_super) {
        __extends(X3DBoundedObject, _super);
        function X3DBoundedObject() {
            _super.call(this);

            this._fields[&quot;bboxCenter&quot;] = new x3dom.SFVec3f(0, 0, 0);
            this._fields[&quot;bboxSize&quot;] = new x3dom.SFVec3f(-1, -1, -1);
        }
        return X3DBoundedObject;
    })(x3dom.X3DOMNode);
    x3dom.X3DBoundedObject = X3DBoundedObject;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DShapeNode = (function (_super) {
        __extends(X3DShapeNode, _super);
        function X3DShapeNode() {
            _super.call(this);
            this._forms = [];
        }
        X3DShapeNode.prototype.removeForm = function (form) {
            var pos = this._forms.indexOf(form);
            if (pos &gt;= 0) {
                this._forms.splice(pos, 1);
            }
        };

        X3DShapeNode.prototype.removeAllForms = function () {
            this._forms.length = 0;
        };

        X3DShapeNode.prototype.getForms = function () {
            return this._forms;
        };

        X3DShapeNode.prototype.updateForms = function (forms) {
            if (forms) {
                this._forms = forms;
            }
            var renderTreeNodes = this.getRenderTreeNodes();
            for (var j = 0, n = renderTreeNodes.length; j &lt; n; ++j) {
                renderTreeNodes[j].replaceDrawables(this._forms);
                renderTreeNodes[j].setVolumeDirty();
            }
        };
        return X3DShapeNode;
    })(x3dom.X3DBoundedObject);
    x3dom.X3DShapeNode = X3DShapeNode;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var ExternalGeometry = (function (_super) {
        __extends(ExternalGeometry, _super);
        function ExternalGeometry() {
            _super.call(this);
            this._fields[&quot;url&quot;] = new x3dom.SFString(&quot;&quot;);
        }
        ExternalGeometry.prototype._updateGeometryDescriptor = function () {
            var _this = this;
            if (this._geometryDescriptors.length == 0) {
                var that = this;
                var callback = function (src) {
                    var geoDescs = src.requestGeometryDescriptors(_this._fields[&quot;url&quot;].getValue());
                    var volume = that._geometryDescriptors[0].getVolume();
                    for (i = 0; i &lt; geoDescs.length; ++i) {
                        if (!geoDescs[i].getVolume().isValid()) {
                            util.Log.postWarning(&quot;External Shape: No bounding box given in SRC. Using the bounding box of the proxy geometry&quot;);
                            geoDescs[i].copyVolume(volume);
                        }
                    }

                    that._geometryDescriptors = geoDescs;
                    for (var i = 0; i &lt; that._parents.length; i++) {
                        if (that._parents[i] instanceof x3dom.X3DShapeNode) {
                            that._parents[i].syncWithRenderTree();
                        }
                    }
                };
                var parent = this._parents[0];
                var geoDesc = util.ProxyShapes.createProxyGeometry(this._x3dNamespace.getApplication().getIdentifier(), this._fields[&quot;url&quot;].getValue(), callback, parent.getField(&quot;bboxCenter&quot;).getValue(), parent.getField(&quot;bboxSize&quot;).getValue());

                this._geometryDescriptors.push(geoDesc);
            }
        };
        return ExternalGeometry;
    })(x3dom.X3DGeometryNode);
    x3dom.ExternalGeometry = ExternalGeometry;
    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;externalgeometry&quot;, ExternalGeometry);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DGroupingNode = (function (_super) {
        __extends(X3DGroupingNode, _super);
        function X3DGroupingNode() {
            _super.apply(this, arguments);
        }
        return X3DGroupingNode;
    })(x3dom.X3DBoundedObject);
    x3dom.X3DGroupingNode = X3DGroupingNode;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var Group = (function (_super) {
        __extends(Group, _super);
        function Group() {
            _super.call(this);
        }
        return Group;
    })(x3dom.X3DGroupingNode);
    x3dom.Group = Group;

    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;group&quot;, Group);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var MatrixTransform = (function (_super) {
        __extends(MatrixTransform, _super);
        function MatrixTransform() {
            _super.call(this);
            this._matrix = mat4.create();

            this._fields[&quot;matrix&quot;] = new x3dom.SFMatrix4f();
        }
        MatrixTransform.prototype.updateCache = function () {
            this._matrix = this._fields[&quot;matrix&quot;].getValue();
        };

        MatrixTransform.prototype.syncWithDOM = function () {
            _super.prototype.syncWithDOM.call(this);

            this._matrix = this._fields[&quot;matrix&quot;].getValue();
        };

        MatrixTransform.prototype.syncWithRenderTree = function () {
            var renderTreeNodes = this.getRenderTreeNodes();
            for (var i = 0, n = renderTreeNodes.length; i &lt; n; ++i) {
                renderTreeNodes[i].setLocalMatrix(this._matrix);
            }
        };
        return MatrixTransform;
    })(x3dom.X3DGroupingNode);
    x3dom.MatrixTransform = MatrixTransform;

    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;matrixtransform&quot;, MatrixTransform);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var StaticGroup = (function (_super) {
        __extends(StaticGroup, _super);
        function StaticGroup() {
            _super.call(this);
            this._fields[&quot;type&quot;] = new x3dom.SFString();
            this._fields[&quot;maxDepth&quot;] = new x3dom.SFInt();
            this._fields[&quot;maxDepth&quot;].setValueByString(&quot;5&quot;);
            this._fields[&quot;traverserType&quot;] = new x3dom.SFInt();
            this._fields[&quot;traverserType&quot;].setValueByString(&quot;0&quot;);
        }
        StaticGroup.prototype._createNode = function (parent) {
            var node = (this._fields[&quot;type&quot;].getValue() == &quot;asm&quot;) ? new pre.ASMCuller(this._x3dNamespace.getApplication()) : new pre.Octree(this._x3dNamespace.getApplication());

            node.setPickListener(this);

            node.setMaxDepth(this._fields[&quot;maxDepth&quot;].getValue());
            node.setTraverserType(this._fields[&quot;traverserType&quot;].getValue());

            node.setParent(parent);
            node.setVolumeDirty();
            this.updateDrawables(node);
            return node;
        };

        StaticGroup.prototype.updateDrawables = function (node) {
            return false;
        };

        StaticGroup.prototype.syncWithDOM = function () {
            _super.prototype.syncWithDOM.call(this);
        };
        return StaticGroup;
    })(x3dom.X3DGroupingNode);
    x3dom.StaticGroup = StaticGroup;

    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;staticgroup&quot;, StaticGroup);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var Transform = (function (_super) {
        __extends(Transform, _super);
        function Transform() {
            _super.call(this);
            this._matrix = mat4.create();

            this._fields[&quot;center&quot;] = new x3dom.SFVec3f(0, 0, 0);
            this._fields[&quot;rotation&quot;] = new x3dom.SFRotation(0, 0, 1, 0);
            this._fields[&quot;scale&quot;] = new x3dom.SFVec3f(1, 1, 1);
            this._fields[&quot;scaleOrientation&quot;] = new x3dom.SFRotation(0, 0, 1, 0);
            this._fields[&quot;translation&quot;] = new x3dom.SFVec3f(0, 0, 0);
        }
        Transform.prototype.syncWithDOM = function () {
            _super.prototype.syncWithDOM.call(this);

            mat4.identity(this._matrix);

            mat4.translate(this._matrix, this._matrix, this._fields[&quot;translation&quot;].getValue());

            var centerVec = vec3.create();
            vec3.copy(centerVec, this._fields[&quot;center&quot;].getValue());
            mat4.translate(this._matrix, this._matrix, centerVec);

            var rotationMatrix = mat4.create();
            mat4.fromQuat(rotationMatrix, this._fields[&quot;rotation&quot;].getValue());
            mat4.mul(this._matrix, this._matrix, rotationMatrix);

            var scaleRotationMatrix = mat4.create();
            mat4.fromQuat(scaleRotationMatrix, this._fields[&quot;scaleOrientation&quot;].getValue());
            mat4.mul(this._matrix, this._matrix, scaleRotationMatrix);

            mat4.scale(this._matrix, this._matrix, this._fields[&quot;scale&quot;].getValue());

            mat4.transpose(scaleRotationMatrix, scaleRotationMatrix);
            mat4.mul(this._matrix, this._matrix, scaleRotationMatrix);

            vec3.negate(centerVec, centerVec);
            mat4.translate(this._matrix, this._matrix, centerVec);
        };

        Transform.prototype.syncWithRenderTree = function () {
            var renderTreeNodes = this.getRenderTreeNodes();
            for (var i = 0, n = renderTreeNodes.length; i &lt; n; ++i) {
                renderTreeNodes[i].setLocalMatrix(this._matrix);
            }
        };

        Transform.prototype.getLocalTransformationMatrix = function () {
            return this._matrix;
        };
        return Transform;
    })(x3dom.X3DGroupingNode);
    x3dom.Transform = Transform;

    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;transform&quot;, Transform);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DViewpointNode = (function (_super) {
        __extends(X3DViewpointNode, _super);
        function X3DViewpointNode(camera) {
            _super.call(this);
            this._localViewMatrix = mat4.create();
            this._baseViewMatrix = mat4.create();
            this._dirtyBaseViewMatrix = true;
            this._camera = null;

            this._camera = camera;

            this._fields[&quot;centerOfRotation&quot;] = new x3dom.SFVec3f(0, 0, 0);
            this._fields[&quot;description&quot;] = new x3dom.SFString(&quot;&quot;);
            this._fields[&quot;jump&quot;] = new x3dom.SFBool(true);
            this._fields[&quot;orientation&quot;] = new x3dom.SFRotation(0, 0, 1, 0);
            this._fields[&quot;position&quot;] = new x3dom.SFVec3f(0, 0, 10);
            this._fields[&quot;retainUserOffsets&quot;] = new x3dom.SFBool(false);

            this._updateLocalViewMatrix();
            this._updateCameraViewMatrix();

            vec3.copy(this._camera.getMutableCenterOfRotation(), this._fields[&quot;centerOfRotation&quot;].getValue());
            this._camera.dirtyMutableCenterOfRotation();
        }
        X3DViewpointNode.prototype._updateLocalViewMatrix = function () {
            mat4.identity(this._localViewMatrix);

            var rotationMatrix = mat4.create();
            mat4.fromQuat(rotationMatrix, this._fields[&quot;orientation&quot;].getValue());
            mat4.transpose(rotationMatrix, rotationMatrix);

            mat4.mul(this._localViewMatrix, this._localViewMatrix, rotationMatrix);

            var viewerOffset = vec3.create();
            vec3.negate(viewerOffset, this._fields[&quot;position&quot;].getValue());

            mat4.translate(this._localViewMatrix, this._localViewMatrix, viewerOffset);

            this._dirtyBaseViewMatrix = true;
        };

        X3DViewpointNode.prototype._requestBaseViewMatrix = function () {
            if (this._dirtyBaseViewMatrix) {
                var toWorldMatrix = this.getToWorldMatrix();
                var toWorldMatrixInv = mat4.create();
                mat4.invert(toWorldMatrixInv, toWorldMatrix);

                mat4.mul(this._baseViewMatrix, toWorldMatrixInv, this._localViewMatrix);

                this._dirtyBaseViewMatrix = false;
            }

            return this._baseViewMatrix;
        };

        X3DViewpointNode.prototype._computeUserOffsetMatrix = function () {
            var baseViewMatrixInv = mat4.create();
            mat4.invert(baseViewMatrixInv, this._requestBaseViewMatrix());

            var userOffsetMatrix = mat4.create();
            mat4.mul(userOffsetMatrix, this._camera.getMutableViewMatrix(), baseViewMatrixInv);

            return userOffsetMatrix;
        };

        X3DViewpointNode.prototype._updateCameraViewMatrix = function (userOffsetMatrix) {
            if (typeof userOffsetMatrix === &quot;undefined&quot;) { userOffsetMatrix = null; }
            if (!this.isUSEd()) {
                if (userOffsetMatrix) {
                    mat4.mul(this._camera.getMutableViewMatrix(), userOffsetMatrix, this._requestBaseViewMatrix());
                } else {
                    mat4.copy(this._camera.getMutableViewMatrix(), this._requestBaseViewMatrix());
                }

                this._camera.dirtyMutableViewMatrix();
            } else {
                util.Log.postError(&quot;Unable to update camera view matrix: viewpoint node has multiple ancestors.&quot;);
            }
        };

        X3DViewpointNode.prototype.syncWithDOM = function () {
            _super.prototype.syncWithDOM.call(this);

            var userOffsetMatrix = this._computeUserOffsetMatrix();
            this._updateLocalViewMatrix();
            this._updateCameraViewMatrix(userOffsetMatrix);

            vec3.copy(this._camera.getMutableCenterOfRotation(), this._fields[&quot;centerOfRotation&quot;].getValue());
            this._camera.dirtyMutableCenterOfRotation();
        };

        X3DViewpointNode.prototype.getToWorldMatrix = function () {
            if (!this.isUSEd()) {
                var renderTreeNodes = this.getRenderTreeNodes();
                var toWorldMatrix = renderTreeNodes.length ? renderTreeNodes[0].requestToWorldMatrix() : null;

                if (!toWorldMatrix) {
                    toWorldMatrix = mat4.create();
                }

                return toWorldMatrix;
            } else {
                util.Log.postError(&quot;Unable to return toWorld matrix: viewpoint node has multiple ancestors.&quot;);
                return null;
            }
        };

        X3DViewpointNode.prototype.getCamera = function (preventUpdate) {
            if (typeof preventUpdate === &quot;undefined&quot;) { preventUpdate = false; }
            if (!preventUpdate) {
                this._updateCameraViewMatrix(this._computeUserOffsetMatrix());
            }

            return this._camera;
        };
        return X3DViewpointNode;
    })(x3dom.X3DBindableNode);
    x3dom.X3DViewpointNode = X3DViewpointNode;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var Viewpoint = (function (_super) {
        __extends(Viewpoint, _super);
        function Viewpoint() {
            _super.call(this, new pre.PerspectiveCamera());

            this._fields[&quot;fieldOfView&quot;] = new x3dom.SFFloat(0.7853981);

            this._camera.setFieldOfView(this._fields[&quot;fieldOfView&quot;].getValue());
        }
        return Viewpoint;
    })(x3dom.X3DViewpointNode);
    x3dom.Viewpoint = Viewpoint;

    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;viewpoint&quot;, Viewpoint);
    x3dom.BindableStack.RegisterBindableClass(&quot;viewpoint&quot;, Viewpoint);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DAppearanceNode = (function (_super) {
        __extends(X3DAppearanceNode, _super);
        function X3DAppearanceNode() {
            _super.apply(this, arguments);
            this._appearanceDescriptor = null;
        }
        X3DAppearanceNode.prototype._updateApperanceDescriptor = function () {
        };

        X3DAppearanceNode.prototype.getAppearanceDescriptor = function () {
            if (this._appearanceDescriptor == null) {
                this._updateApperanceDescriptor();
            }
            return this._appearanceDescriptor;
        };
        return X3DAppearanceNode;
    })(x3dom.X3DNode);
    x3dom.X3DAppearanceNode = X3DAppearanceNode;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DAppearanceChildNode = (function (_super) {
        __extends(X3DAppearanceChildNode, _super);
        function X3DAppearanceChildNode() {
            _super.apply(this, arguments);
        }
        return X3DAppearanceChildNode;
    })(x3dom.X3DNode);
    x3dom.X3DAppearanceChildNode = X3DAppearanceChildNode;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var X3DMaterialNode = (function (_super) {
        __extends(X3DMaterialNode, _super);
        function X3DMaterialNode() {
            _super.apply(this, arguments);
        }
        X3DMaterialNode.prototype.applyToDescriptor = function (appearance) {
        };
        return X3DMaterialNode;
    })(x3dom.X3DAppearanceChildNode);
    x3dom.X3DMaterialNode = X3DMaterialNode;
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var Appearance = (function (_super) {
        __extends(Appearance, _super);
        function Appearance() {
            _super.apply(this, arguments);
        }
        Appearance.prototype._updateApperanceDescriptor = function () {
            if (!this._appearanceDescriptor) {
                this._appearanceDescriptor = new pre.AppearanceDescriptor();
                this._updateMaterial();
            }
        };

        Appearance.prototype._updateMaterial = function () {
            var i;
            for (i = 0; i &lt; this._children.length; ++i) {
                if (this._children[i] instanceof x3dom.X3DAppearanceChildNode) {
                    this._children[i].applyToDescriptor(this._appearanceDescriptor);
                }
            }
        };
        return Appearance;
    })(x3dom.X3DAppearanceNode);
    x3dom.Appearance = Appearance;
    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;appearance&quot;, Appearance);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var Material = (function (_super) {
        __extends(Material, _super);
        function Material() {
            _super.call(this);

            this._fields[&quot;ambientIntensity&quot;] = new x3dom.SFFloat(0.2);
            this._fields[&quot;diffuseColor&quot;] = new x3dom.SFColor(0.8, 0.8, 0.8);
            this._fields[&quot;emissiveColor&quot;] = new x3dom.SFColor(0, 0, 0);
            this._fields[&quot;shininess&quot;] = new x3dom.SFFloat(0.2);
            this._fields[&quot;specularColor&quot;] = new x3dom.SFColor(0, 0, 0);
            this._fields[&quot;transparency&quot;] = new x3dom.SFFloat(0);
        }
        Material.prototype.applyToDescriptor = function (appearance) {
            var that = this;

            appearance._resources[&quot;diffuseColor&quot;] = new pre.Resource(pre.ResourceType.vec3f, function (callback) {
                return that._fields[&quot;diffuseColor&quot;].getValue();
            });

            appearance._resources[&quot;specularColor&quot;] = new pre.Resource(pre.ResourceType.vec3f, function () {
                return that._fields[&quot;specularColor&quot;].getValue();
            });
        };
        return Material;
    })(x3dom.X3DMaterialNode);
    x3dom.Material = Material;
    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;material&quot;, Material);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var ExternalShape = (function (_super) {
        __extends(ExternalShape, _super);
        function ExternalShape() {
            _super.call(this);
            this._src = null;
            this._nrOfVisibleFramesBeforeLoad = 5;
            this._fields[&quot;url&quot;] = new x3dom.SFString(&quot;&quot;);
            this._fields[&quot;bboxCenter&quot;] = new x3dom.SFVec3f();
            this._fields[&quot;bboxSize&quot;] = new x3dom.SFVec3f();
            this._fields[&quot;min&quot;] = new x3dom.SFVec3f();
            this._fields[&quot;max&quot;] = new x3dom.SFVec3f();
        }
        ExternalShape.prototype.syncWithRenderTree = function () {
            var _this = this;
            this._nrOfVisibleFramesBeforeLoad--;

            if (this._nrOfVisibleFramesBeforeLoad &gt; 0) {
            }

            if (ExternalShape._defaultApperanceDescriptor == null) {
                ExternalShape._defaultApperanceDescriptor = new pre.AppearanceDescriptor();
                var defaultMaterial = new x3dom.Material();
                defaultMaterial.applyToDescriptor(ExternalShape._defaultApperanceDescriptor);
            }

            var that = this;
            var callback = function (src) {
                var forms = src.requestForms(_this._fields[&quot;url&quot;].getValue());
                var i;
                var volume = that._forms[0].getVolume();

                for (i = 0; i &lt; forms.length; ++i) {
                    if (forms[i].getAppearanceDescriptor() == null) {
                        forms[i].setAppearanceDescriptor(ExternalShape._defaultApperanceDescriptor);
                    }
                    if (!forms[i].getGeometryDescriptor().getVolume().isValid()) {
                        util.Log.postWarning(&quot;External Shape: No bounding box given in SRC. Using the bounding box of the proxy geometry&quot;);
                        forms[i].getGeometryDescriptor().copyVolume(volume);
                    }
                }
                that.updateForms(forms);
            };

            var form = util.ProxyShapes.createProxyForm(this._x3dNamespace.getApplication().getIdentifier(), this._fields[&quot;url&quot;].getValue(), callback, this._fields[&quot;bboxCenter&quot;].getValue(), this._fields[&quot;bboxSize&quot;].getValue());

            this._forms.push(form);
            this.updateForms();
        };
        ExternalShape._defaultApperanceDescriptor = null;
        return ExternalShape;
    })(x3dom.X3DShapeNode);
    x3dom.ExternalShape = ExternalShape;
    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;externalshape&quot;, ExternalShape);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var ImageTexture = (function (_super) {
        __extends(ImageTexture, _super);
        function ImageTexture() {
            _super.call(this);
            this._texResource = null;
            this._flagResource = null;

            this._fields[&quot;url&quot;] = new x3dom.SFString(&quot;&quot;);
        }
        ImageTexture.prototype.applyToDescriptor = function (appearance) {
            var that = this;
            var url = this._fields[&quot;url&quot;].getValue();
            if (this._texResource == null || this._url != url) {
                this._url = url;
                this._texResource = pre.TextureResource.CreateLazy(pre.ResourceType.sampler2D, function (callback) {
                    var image = new Image();
                    image.onload = function () {
                        that._texResource.setWidth(image.width);
                        that._texResource.setHeight(image.height);
                        callback(image);
                        that._x3dNamespace.getApplication().getPipelineControl().setFlag(4 /* APPEARANCE_CHANGED */);
                    };
                    image.src = url;
                    return null;
                });
                this._flagResource = pre.Resource.Create(pre.ResourceType.bool, new Int32Array([1]));
            }
            appearance._resources[&quot;diffuseTexture&quot;] = this._texResource;
            appearance._resources[&quot;hasDiffuseTexture&quot;] = this._flagResource;
        };
        return ImageTexture;
    })(x3dom.X3DAppearanceChildNode);
    x3dom.ImageTexture = ImageTexture;
    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;imagetexture&quot;, ImageTexture);
})(x3dom || (x3dom = {}));
var x3dom;
(function (x3dom) {
    var Shape = (function (_super) {
        __extends(Shape, _super);
        function Shape() {
            _super.apply(this, arguments);
        }
        Shape.prototype.syncWithRenderTree = function () {
            var geometryChild = null;
            var appearanceChild = null;

            var i;
            for (i = 0; i &lt; this._children.length; ++i) {
                if (this._children[i] instanceof x3dom.X3DGeometryNode) {
                    geometryChild = this._children[i];
                } else if (this._children[i] instanceof x3dom.X3DAppearanceNode) {
                    appearanceChild = this._children[i];
                }
            }

            if (!geometryChild) {
                util.Log.postError(&quot;Cannot create rendering representation for Shape, no Geometry node attached.&quot;);
                return;
            }

            if (!appearanceChild) {
                util.Log.postError(&quot;Cannot create rendering representation for Shape, no Appearance node attached.&quot;);
                return;
            }

            var geometryDescriptors = geometryChild.getGeometryDescriptors();
            var appearanceDescriptor = appearanceChild.getAppearanceDescriptor();

            if (geometryDescriptors.length == 0) {
                util.Log.postError(&quot;Cannot create rendering representation for Shape, no geometry descriptor available.&quot;);
                return;
            }

            if (!appearanceDescriptor) {
                util.Log.postError(&quot;Cannot create rendering representation for Shape, no appearance descriptor available.&quot;);
                return;
            }

            this._forms.length = 0;
            for (i = 0; i &lt; geometryDescriptors.length; i++) {
                this._forms.push(new pre.Form(geometryDescriptors[i], appearanceDescriptor));
            }
            this.updateForms();
        };
        return Shape;
    })(x3dom.X3DShapeNode);
    x3dom.Shape = Shape;
    x3dom.X3DOMObject.RegisterX3DOMObjectClass(&quot;shape&quot;, Shape);
})(x3dom || (x3dom = {}));
var pre;
(function (pre) {
    var CustomShaderRenderPass = (function (_super) {
        __extends(CustomShaderRenderPass, _super);
        function CustomShaderRenderPass(application, customShaderDesc) {
            _super.call(this, application);
            this._customShaderDescriptor = null;
            this._programID = -1;
            this._customShaderDescriptor = customShaderDesc;
            this._programID = this._shaderService.requestShaderProgram(this._customShaderDescriptor, this._application);
        }
        CustomShaderRenderPass.prototype._render = function () {
            var i = 0, n = this._drawables.length;

            if (!n) {
                return;
            }
            this._bindShaderProgram(this._programID);
            this._bindingManager.bindResourceContainer(this._resources, 2 /* PASS */);

            _super.prototype._render.call(this);
        };

        CustomShaderRenderPass.prototype._renderDrawable = function (drawable) {
            this._bindAppearance(drawable.getDrawingInfo().appearanceClass);
            drawable.draw(this._renderer);
        };
        return CustomShaderRenderPass;
    })(pre.SimpleRenderPass);
    pre.CustomShaderRenderPass = CustomShaderRenderPass;
})(pre || (pre = {}));
//# sourceMappingURL=pre.js.map
</pre>
</body>
</html>
